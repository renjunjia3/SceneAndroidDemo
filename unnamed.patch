Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/ArraySwipeAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/ArraySwipeAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/ArraySwipeAdapter.java	(revision )
@@ -0,0 +1,105 @@
+package com.scene.mylib.view.swipelayout.adapters;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.implments.SwipeItemMangerImpl;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeAdapterInterface;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeItemMangerInterface;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.List;
+
+public abstract class ArraySwipeAdapter<T> extends ArrayAdapter implements SwipeItemMangerInterface, SwipeAdapterInterface {
+
+    private SwipeItemMangerImpl mItemManger = new SwipeItemMangerImpl(this);
+    {}
+    public ArraySwipeAdapter(Context context, int resource) {
+        super(context, resource);
+    }
+
+    public ArraySwipeAdapter(Context context, int resource, int textViewResourceId) {
+        super(context, resource, textViewResourceId);
+    }
+
+    public ArraySwipeAdapter(Context context, int resource, T[] objects) {
+        super(context, resource, objects);
+    }
+
+    public ArraySwipeAdapter(Context context, int resource, int textViewResourceId, T[] objects) {
+        super(context, resource, textViewResourceId, objects);
+    }
+
+    public ArraySwipeAdapter(Context context, int resource, List<T> objects) {
+        super(context, resource, objects);
+    }
+
+    public ArraySwipeAdapter(Context context, int resource, int textViewResourceId, List<T> objects) {
+        super(context, resource, textViewResourceId, objects);
+    }
+
+    @Override
+    public void notifyDatasetChanged() {
+        super.notifyDataSetChanged();
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        View v = super.getView(position, convertView, parent);
+        mItemManger.bind(v, position);
+        return v;
+    }
+
+    @Override
+    public void openItem(int position) {
+        mItemManger.openItem(position);
+    }
+
+    @Override
+    public void closeItem(int position) {
+        mItemManger.closeItem(position);
+    }
+
+    @Override
+    public void closeAllExcept(SwipeLayout layout) {
+        mItemManger.closeAllExcept(layout);
+    }
+
+    @Override
+    public void closeAllItems() {
+        mItemManger.closeAllItems();
+    }
+
+    @Override
+    public List<Integer> getOpenItems() {
+        return mItemManger.getOpenItems();
+    }
+
+    @Override
+    public List<SwipeLayout> getOpenLayouts() {
+        return mItemManger.getOpenLayouts();
+    }
+
+    @Override
+    public void removeShownLayouts(SwipeLayout layout) {
+        mItemManger.removeShownLayouts(layout);
+    }
+
+    @Override
+    public boolean isOpen(int position) {
+        return mItemManger.isOpen(position);
+    }
+
+    @Override
+    public Attributes.Mode getMode() {
+        return mItemManger.getMode();
+    }
+
+    @Override
+    public void setMode(Attributes.Mode mode) {
+        mItemManger.setMode(mode);
+    }
+}
Index: customfresco/src/main/java/com/scene/customfresco/FrescoImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/FrescoImageView.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/FrescoImageView.java	(revision )
@@ -0,0 +1,243 @@
+package com.scene.customfresco;
+
+import android.content.Context;
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.drawee.generic.GenericDraweeHierarchy;
+import com.facebook.drawee.generic.RoundingParams;
+import com.facebook.drawee.interfaces.DraweeController;
+import com.facebook.drawee.view.SimpleDraweeView;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imagepipeline.request.ImageRequestBuilder;
+import com.facebook.imagepipeline.request.Postprocessor;
+import com.scene.customfresco.custom.CustomProgressBar;
+
+
+/**
+ * Created by Linhh on 16/2/18.
+ */
+public class FrescoImageView extends SimpleDraweeView {
+
+    //    private final static String TAG = "FrescoThumbnailView";
+    public final static String HTTP_PERFIX = "http://";
+    public final static String HTTPS_PERFIX = "https://";
+    public final static String FILE_PERFIX = "file://";
+
+    private String mThumbnailUrl = null;
+    private int mDefaultResID = 0;
+
+    private ImageRequest mRequest;
+
+    private boolean mAnim = true;//默认开启动画
+    private boolean mShowProgress = false;//默认关闭显示进度
+
+    private Postprocessor mPostProcessor;
+
+    private DraweeController mController;
+
+    public FrescoImageView(Context context, GenericDraweeHierarchy hierarchy) {
+        super(context, hierarchy);
+    }
+
+    public FrescoImageView(Context context) {
+        super(context);
+    }
+
+    public FrescoImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public FrescoImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    private void setController(int resid) {
+        if (resid == 0) {
+            return;
+        }
+
+        if (mPostProcessor != null) {
+            mRequest = ImageRequestBuilder.newBuilderWithResourceId(resid)
+                    .setPostprocessor(mPostProcessor)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+
+        } else {
+            mRequest = ImageRequestBuilder.newBuilderWithResourceId(resid)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+        }
+
+        mController = Fresco.newDraweeControllerBuilder()
+                .setImageRequest(mRequest)
+                .setAutoPlayAnimations(mAnim)
+                .setOldController(this.getController())
+                .build();
+
+        this.setController(mController);
+    }
+
+    private void setController(Uri uri, Uri lowResUri) {
+
+        if (uri == null) {
+            return;
+        }
+
+        if (mPostProcessor != null) {
+            mRequest = ImageRequestBuilder.newBuilderWithSource(uri)
+                    .setPostprocessor(mPostProcessor)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+
+        } else {
+            mRequest = ImageRequestBuilder.newBuilderWithSource(uri)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+        }
+
+        ImageRequest lowResRequest = ImageRequest.fromUri(lowResUri);
+
+        if (lowResRequest == null) {
+            mController = Fresco.newDraweeControllerBuilder()
+                    .setImageRequest(mRequest)
+                    .setAutoPlayAnimations(mAnim)
+                    .setOldController(this.getController())
+                    .build();
+
+        } else {
+            mController = Fresco.newDraweeControllerBuilder()
+                    .setImageRequest(mRequest)
+                    .setLowResImageRequest(lowResRequest)
+                    .setAutoPlayAnimations(mAnim)
+                    .setOldController(this.getController())
+                    .build();
+        }
+        this.setController(mController);
+    }
+
+    public void setPostProcessor(Postprocessor postProcessor) {
+        this.mPostProcessor = postProcessor;
+    }
+
+    public Postprocessor getPostProcessor() {
+        return this.mPostProcessor;
+    }
+
+    public void loadView(String lowUrl, String url, int defaultResID) {
+        try {
+            if (url == null || url.length() <= 0) {
+                this.getHierarchy().setPlaceholderImage(defaultResID);
+                this.setController(defaultResID);
+                mThumbnailUrl = url;
+                return;
+            }
+            mThumbnailUrl = url;
+            mDefaultResID = defaultResID;
+
+            if (mThumbnailUrl.startsWith(HTTP_PERFIX) || mThumbnailUrl.startsWith(HTTPS_PERFIX)) {
+
+                Uri uri = Uri.parse(mThumbnailUrl);
+                this.getHierarchy().setPlaceholderImage(defaultResID);
+                if (mShowProgress) {
+                    this.getHierarchy().setProgressBarImage(new CustomProgressBar());
+                }
+                Uri lowUri = null;
+
+                if (!TextUtils.isEmpty(lowUrl)) {
+                    lowUri = Uri.parse(mThumbnailUrl);
+                }
+
+                setController(uri, lowUri);
+
+            } else {
+                this.getHierarchy().setPlaceholderImage(defaultResID);
+                this.setController(defaultResID);
+            }
+
+        } catch (OutOfMemoryError e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    public void loadView(String url, int defaultResID) {
+        this.loadView(null, url, defaultResID);
+    }
+
+    /**
+     * 获得当前使用的图片URL
+     *
+     * @return
+     */
+    public String getThumbnailUrl() {
+        return this.mThumbnailUrl;
+    }
+
+    /**
+     * 获得当前使用的默认占位图
+     *
+     * @return
+     */
+    public int getDefaultResID() {
+        return this.mDefaultResID;
+    }
+
+    public void loadLocalImage(String path, int defaultRes) {
+        this.getHierarchy().setPlaceholderImage(defaultRes);
+        if (null == path || path.length() == 0) {
+            this.setController(defaultRes);
+            return;
+        }
+        if (!path.startsWith(FILE_PERFIX)) {
+            path = FILE_PERFIX + path;
+        }
+        Uri uri = Uri.parse(path);
+        setController(uri, null);
+    }
+
+    public void setCornerRadius(float radius) {
+        RoundingParams roundingParams = RoundingParams.fromCornersRadius(radius);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setCornerRadius(float radius, int overlay_color) {
+        RoundingParams roundingParams = RoundingParams.fromCornersRadius(radius).
+                setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR).
+                setOverlayColor(overlay_color);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setCircle(int overlay_color) {
+        RoundingParams roundingParams = RoundingParams.asCircle().
+                setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR).
+                setOverlayColor(overlay_color);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setAnim(boolean b) {
+        mAnim = b;
+    }
+
+    public boolean isAnim() {
+        return mAnim;
+    }
+
+    public void asCircle() {
+        RoundingParams roundingParams = RoundingParams.asCircle();
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void asCircle(float borderWidth, int borderColor) {
+        RoundingParams roundingParams = RoundingParams.asCircle();
+        roundingParams.setBorder(borderColor, borderWidth);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setShowProgress(boolean mShown) {
+        mShowProgress = mShown;
+    }
+}
+
Index: app/src/main/res/values-w820dp/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values-w820dp/dimens.xml	(revision )
+++ app/src/main/res/values-w820dp/dimens.xml	(revision )
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
Index: timeline/src/androidTest/java/com/scene/timeline/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/androidTest/java/com/scene/timeline/ApplicationTest.java	(revision )
+++ timeline/src/androidTest/java/com/scene/timeline/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.scene.timeline;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(revision )
+++ app/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.scene.sceneandroiddemo">
+
+    <application
+        android:name=".BaseApplication"
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/AppTheme">
+        <activity android:name=".MainTabActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name=".ui.activity.LoadmoreActivity" />
+        <activity android:name=".ui.activity.SelectAndCropImageActivity" />
+        <activity android:name=".ui.activity.CustomRatingBarActivity" />
+        <activity android:name=".ui.activity.WebViewDemo"></activity>
+    </application>
+
+</manifest>
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/encodings.xml	(revision )
+++ .idea/encodings.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding" defaultCharsetForPropertiesFiles="UTF-8">
+    <file url="PROJECT" charset="UTF-8" />
+  </component>
+</project>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/assist/WakeLock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/WakeLock.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/WakeLock.java	(revision )
@@ -0,0 +1,85 @@
+package com.scene.common.common.assist;
+
+import android.content.Context;
+import android.os.Build;
+import android.os.PowerManager;
+
+import com.scene.common.android.log.Log;
+
+/**
+ * <!-- 亮屏 -->
+ * require <uses-permission android:name="android.permission.WAKE_LOCK"/>
+ *
+ * @author MaTianyu
+ * @date 2014-11-04
+ */
+public class WakeLock {
+    PowerManager          powerManager;
+    PowerManager.WakeLock wakeLock;
+
+    public WakeLock(Context context, String tag) {
+        ////获取电源的服务 声明电源管理器
+        powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        wakeLock = powerManager.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.FULL_WAKE_LOCK, tag);
+    }
+
+    /**
+     * Call requires API level 7
+     */
+    public boolean isScreenOn() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ECLAIR_MR1) {
+            Log.e("Log : ", "can not call isScreenOn if SDK_INT < 7 ");
+            return false;
+        } else {
+            return powerManager.isScreenOn();
+        }
+    }
+
+    public void turnScreenOn() {
+        //点亮亮屏
+        Log.i("Log : ", "PowerManager.WakeLock : wakeLock.isHeld: " + wakeLock.isHeld());
+        if (!wakeLock.isHeld()) {
+            Log.i("Log : ", "PowerManager.WakeLock : 点亮屏幕");
+            wakeLock.acquire();
+        }
+    }
+
+    public void turnScreenOff() {
+        //释放亮屏
+        Log.i("Log : ", "PowerManager.WakeLock : wakeLock.isHeld: " + wakeLock.isHeld());
+        if (wakeLock.isHeld()) {
+            Log.i("Log : ", "PowerManager.WakeLock : 灭掉屏幕");
+            try {
+                wakeLock.release();
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public void release() {
+        if (wakeLock != null && wakeLock.isHeld()) {
+            try {
+                wakeLock.release();
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public PowerManager.WakeLock getWakeLock() {
+        return wakeLock;
+    }
+
+    public void setWakeLock(PowerManager.WakeLock wakeLock) {
+        this.wakeLock = wakeLock;
+    }
+
+    public PowerManager getPowerManager() {
+        return powerManager;
+    }
+
+    public void setPowerManager(PowerManager powerManager) {
+        this.powerManager = powerManager;
+    }
+}
Index: chooseimagelib/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/.gitignore	(revision )
+++ chooseimagelib/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: app/src/main/res/layout/activity_loadmore.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_loadmore.xml	(revision )
+++ app/src/main/res/layout/activity_loadmore.xml	(revision )
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:LoadStateView="http://schemas.android.com/apk/res-auto"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/white"
+    android:orientation="vertical"
+    tools:context=".ui.activity.LoadmoreActivity">
+
+    <android.support.v7.widget.Toolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="?attr/actionBarSize"
+        android:background="?attr/colorPrimary"
+        android:navigationIcon="?android:attr/backupAgent"
+        app:navigationIcon="?attr/homeAsUpIndicator" />
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+        <Button
+            android:id="@+id/empty"
+            android:text="empty"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content" />
+        <Button
+            android:id="@+id/error"
+            android:text="error"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content" />
+    </LinearLayout>
+
+    <!--###########添加加载状态处理############-->
+    <com.scene.mylib.view.loadstateview.LoadStateView
+        android:id="@+id/load_state_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        LoadStateView:emptyBackgroundColor="#fbc02d"
+        LoadStateView:errorBackgroundColor="#42a5f5"
+        LoadStateView:loadingBackgroundColor="#FFFFFF">
+
+        <android.support.v4.widget.SwipeRefreshLayout
+            android:id="@+id/refreshLayout"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content">
+
+            <android.support.v7.widget.RecyclerView
+                android:id="@+id/recyclerView"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent" />
+        </android.support.v4.widget.SwipeRefreshLayout>
+    </com.scene.mylib.view.loadstateview.LoadStateView>
+
+
+</LinearLayout>
Index: ucrop/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/values/strings.xml	(revision )
+++ ucrop/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,10 @@
+<resources>
+
+    <string name="ucrop_label_original">Original</string>
+    <string name="ucrop_label_edit_photo">Edit Photo</string>
+
+    <string name="ucrop_menu_next">Next</string>
+
+    <string name="ucrop_error_input_data_is_absent">Both input and output Uri must be specified</string>
+
+</resources>
Index: chooseimagelib/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/proguard-rules.pro	(revision )
+++ chooseimagelib/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\Devolopment\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: customfresco/src/main/java/com/scene/customfresco/zoomable/ZoomableDraweeView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/zoomable/ZoomableDraweeView.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/zoomable/ZoomableDraweeView.java	(revision )
@@ -0,0 +1,248 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.scene.customfresco.zoomable;
+
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.PointF;
+import android.graphics.RectF;
+import android.graphics.drawable.Animatable;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+import com.facebook.common.internal.Preconditions;
+import com.facebook.drawee.controller.AbstractDraweeController;
+import com.facebook.drawee.controller.BaseControllerListener;
+import com.facebook.drawee.controller.ControllerListener;
+import com.facebook.drawee.interfaces.DraweeController;
+import com.facebook.drawee.view.GenericDraweeView;
+
+
+/**
+ * DraweeView that has zoomable capabilities.
+ * <p>
+ * Once the image loads, pinch-to-zoom and translation gestures are enabled.
+ *
+ */
+public class ZoomableDraweeView extends GenericDraweeView
+        implements ZoomableController.Listener {
+
+//  private static final Class<?> TAG = ZoomableDraweeView.class;
+
+  private static final float HUGE_IMAGE_SCALE_FACTOR_THRESHOLD = 1.1f;
+
+  private static final int TOUCH_TIME = 250;//触摸间隔时间
+
+  private final RectF mImageBounds = new RectF();
+  private final RectF mViewBounds = new RectF();
+
+  private final ControllerListener mControllerListener = new BaseControllerListener<Object>() {
+    @Override
+    public void onFinalImageSet(
+            String id,
+            Object imageInfo,
+            Animatable animatable) {
+      ZoomableDraweeView.this.onFinalImageSet();
+    }
+
+    @Override
+    public void onRelease(String id) {
+      ZoomableDraweeView.this.onRelease();
+    }
+  };
+
+  private DraweeController mHugeImageController;
+  private ZoomableController mZoomableController = DefaultZoomableController.newInstance();
+
+  public ZoomableDraweeView(Context context) {
+    super(context);
+    init();
+  }
+
+  public ZoomableDraweeView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+    init();
+  }
+
+  public ZoomableDraweeView(Context context, AttributeSet attrs, int defStyle) {
+    super(context, attrs, defStyle);
+    init();
+  }
+
+  private void init() {
+    mZoomableController.setListener(this);
+  }
+
+  public void setZoomableController(ZoomableController zoomableController) {
+    Preconditions.checkNotNull(zoomableController);
+    mZoomableController.setListener(null);
+    mZoomableController = zoomableController;
+    mZoomableController.setListener(this);
+  }
+
+  @Override
+  public void setController( DraweeController controller) {
+    setControllers(controller, null);
+  }
+
+  private void setControllersInternal(
+          DraweeController controller,
+          DraweeController hugeImageController) {
+    removeControllerListener(getController());
+    addControllerListener(controller);
+    mHugeImageController = hugeImageController;
+    super.setController(controller);
+  }
+
+  /**
+   * Sets the controllers for the normal and huge image.
+   *
+   * <p> IMPORTANT: in order to avoid a flicker when switching to the huge image, the huge image
+   * controller should have the normal-image-uri set as its low-res-uri.
+   *
+   * @param controller controller to be initially used
+   * @param hugeImageController controller to be used after the client starts zooming-in
+   */
+  public void setControllers(
+          DraweeController controller,
+          DraweeController hugeImageController) {
+    setControllersInternal(null, null);
+    mZoomableController.setEnabled(false);
+    setControllersInternal(controller, hugeImageController);
+  }
+
+  private void maybeSetHugeImageController() {
+    if (mHugeImageController != null &&
+            mZoomableController.getScaleFactor() > HUGE_IMAGE_SCALE_FACTOR_THRESHOLD) {
+      setControllersInternal(mHugeImageController, null);
+    }
+  }
+
+  private void removeControllerListener(DraweeController controller) {
+    if (controller instanceof AbstractDraweeController) {
+      ((AbstractDraweeController) controller)
+              .removeControllerListener(mControllerListener);
+    }
+  }
+
+  private void addControllerListener(DraweeController controller) {
+    if (controller instanceof AbstractDraweeController) {
+      ((AbstractDraweeController) controller)
+              .addControllerListener(mControllerListener);
+    }
+  }
+
+  @Override
+  protected void onDraw(Canvas canvas) {
+    int saveCount = canvas.save();
+    canvas.concat(mZoomableController.getTransform());
+    super.onDraw(canvas);
+    canvas.restoreToCount(saveCount);
+  }
+
+  public OnClickListener mOnClickListener;
+
+  public void setOnDraweeClickListener(OnClickListener l) {
+    mOnClickListener = l;
+  }
+
+  public long mCurrDownTime = 0;
+
+  @Override
+  public boolean onTouchEvent(MotionEvent event) {
+
+    if(event.getAction() == MotionEvent.ACTION_DOWN){
+      mCurrDownTime = event.getEventTime();
+    }
+
+    if(event.getAction() == MotionEvent.ACTION_UP){
+      if(event.getEventTime() - mCurrDownTime <= TOUCH_TIME){
+        //点击
+        if(mOnClickListener != null){
+          mOnClickListener.onClick(this);
+        }
+      }
+    }
+
+    if (mZoomableController.onTouchEvent(event)) {
+      if (mZoomableController.getScaleFactor() > 1.0f) {
+        getParent().requestDisallowInterceptTouchEvent(true);
+      }
+//      FLog.v(TAG, "onTouchEvent: view %x, handled by zoomable controller", this.hashCode());
+      return true;
+    }
+//    FLog.v(TAG, "onTouchEvent: view %x, handled by the super", this.hashCode());
+    return super.onTouchEvent(event);
+  }
+
+  public void clearZoom(){
+    if(mZoomableController != null && mZoomableController instanceof DefaultZoomableController){
+      PointF imagePoint = new PointF(getWidth() / 2, getHeight() / 2);
+      ((DefaultZoomableController)mZoomableController).zoomToImagePoint(1, imagePoint);
+    }
+  }
+
+  @Override
+  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+//    FLog.v(TAG, "onLayout: view %x", this.hashCode());
+    super.onLayout(changed, left, top, right, bottom);
+    updateZoomableControllerBounds();
+  }
+
+  private void onFinalImageSet() {
+//    FLog.v(TAG, "onFinalImageSet: view %x", this.hashCode());
+    if (!mZoomableController.isEnabled()) {
+      updateZoomableControllerBounds();
+      mZoomableController.setEnabled(true);
+    }
+  }
+
+  private void onRelease() {
+//    FLog.v(TAG, "onRelease: view %x", this.hashCode());
+    mZoomableController.setEnabled(false);
+  }
+
+  @Override
+  public void onTransformChanged(Matrix transform) {
+//    FLog.v(TAG, "onTransformChanged: view %x", this.hashCode());
+    maybeSetHugeImageController();
+    invalidate();
+  }
+
+  private void updateZoomableControllerBounds() {
+    getHierarchy().getActualImageBounds(mImageBounds);
+    mViewBounds.set(0, 0, getWidth(), getHeight());
+    mZoomableController.setImageBounds(mImageBounds);
+    mZoomableController.setViewBounds(mViewBounds);
+//    FLog.v(
+//            TAG,
+//            "updateZoomableControllerBounds: view %x, view bounds: %s, image bounds: %s",
+//            this.hashCode(),
+//            mViewBounds,
+//            mImageBounds);
+  }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/AppUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/AppUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/AppUtil.java	(revision )
@@ -0,0 +1,62 @@
+package com.scene.common.common.utils;
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+
+import java.util.List;
+
+/**
+ * @author MaTianyu
+ * @date 2014-12-10
+ */
+public class AppUtil {
+
+    /**
+     * 调用系统分享
+     */
+    public static void shareToOtherApp(Context context,String title,String content, String dialogTitle ) {
+        Intent intentItem = new Intent(Intent.ACTION_SEND);
+        intentItem.setType("text/plain");
+        intentItem.putExtra(Intent.EXTRA_SUBJECT, title);
+        intentItem.putExtra(Intent.EXTRA_TEXT, content);
+        intentItem.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(Intent.createChooser(intentItem, dialogTitle));
+    }
+
+    /**
+     * need < uses-permission android:name =“android.permission.GET_TASKS” />
+     * 判断是否前台运行
+     */
+    public static boolean isRunningForeground(Context context) {
+        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningTaskInfo> taskList = am.getRunningTasks(1);
+        if (taskList != null && !taskList.isEmpty()) {
+            ComponentName componentName = taskList.get(0).topActivity;
+            if (componentName != null && componentName.getPackageName().equals(context.getPackageName())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * 获取App包 信息版本号
+     * @param context
+     * @return
+     */
+    public PackageInfo getPackageInfo(Context context) {
+        PackageManager packageManager = context.getPackageManager();
+        PackageInfo packageInfo = null;
+        try {
+            packageInfo = packageManager.getPackageInfo(context.getPackageName(), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        return packageInfo;
+    }
+
+}
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/RecyclerSwipeAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/RecyclerSwipeAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/RecyclerSwipeAdapter.java	(revision )
@@ -0,0 +1,78 @@
+package com.scene.mylib.view.swipelayout.adapters;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.ViewGroup;
+
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.implments.SwipeItemMangerImpl;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeAdapterInterface;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeItemMangerInterface;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.List;
+
+public abstract class RecyclerSwipeAdapter<VH extends RecyclerView.ViewHolder> extends RecyclerView.Adapter<VH> implements SwipeItemMangerInterface, SwipeAdapterInterface {
+
+    public SwipeItemMangerImpl mItemManger = new SwipeItemMangerImpl(this);
+
+    @Override
+    public abstract VH onCreateViewHolder(ViewGroup parent, int viewType);
+
+    @Override
+    public abstract void onBindViewHolder(VH viewHolder, final int position);
+
+    @Override
+    public void notifyDatasetChanged() {
+        super.notifyDataSetChanged();
+    }
+
+    @Override
+    public void openItem(int position) {
+        mItemManger.openItem(position);
+    }
+
+    @Override
+    public void closeItem(int position) {
+        mItemManger.closeItem(position);
+    }
+
+    @Override
+    public void closeAllExcept(SwipeLayout layout) {
+        mItemManger.closeAllExcept(layout);
+    }
+
+    @Override
+    public void closeAllItems() {
+        mItemManger.closeAllItems();
+    }
+
+    @Override
+    public List<Integer> getOpenItems() {
+        return mItemManger.getOpenItems();
+    }
+
+    @Override
+    public List<SwipeLayout> getOpenLayouts() {
+        return mItemManger.getOpenLayouts();
+    }
+
+    @Override
+    public void removeShownLayouts(SwipeLayout layout) {
+        mItemManger.removeShownLayouts(layout);
+    }
+
+    @Override
+    public boolean isOpen(int position) {
+        return mItemManger.isOpen(position);
+    }
+
+    @Override
+    public Attributes.Mode getMode() {
+        return mItemManger.getMode();
+    }
+
+    @Override
+    public void setMode(Attributes.Mode mode) {
+        mItemManger.setMode(mode);
+    }
+}
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropUtil.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropUtil.java	(revision )
@@ -0,0 +1,254 @@
+package com.scene.chooseimagelib.simplecropimage;
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import android.app.Activity;
+import android.app.ProgressDialog;
+import android.graphics.*;
+import android.os.Handler;
+import android.view.Surface;
+
+import java.io.Closeable;
+
+/**
+ * Collection of utility functions used in this package.
+ */
+public class CropUtil {
+
+    private static final String TAG = "db.CropUtil";
+
+    private CropUtil() {
+
+    }
+
+    /*
+     * Compute the sample size as a function of minSideLength
+     * and maxNumOfPixels.
+     * minSideLength is used to specify that minimal width or height of a bitmap.
+     * maxNumOfPixels is used to specify the maximal size in pixels that are tolerable
+     * in terms of memory usage.
+     *
+     * The function returns a sample size based on the constraints.
+     * Both size and minSideLength can be passed in as IImage.UNCONSTRAINED,
+     * which indicates no care of the corresponding constraint.
+     * The functions prefers returning a sample size that
+     * generates a smaller bitmap, unless minSideLength = IImage.UNCONSTRAINED.
+     */
+
+
+    public static Bitmap transform(Matrix scaler,
+                                   Bitmap source,
+                                   int targetWidth,
+                                   int targetHeight,
+                                   boolean scaleUp) {
+
+        int deltaX = source.getWidth() - targetWidth;
+        int deltaY = source.getHeight() - targetHeight;
+        if (!scaleUp && (deltaX < 0 || deltaY < 0)) {
+            /*
+             * In this case the bitmap is smaller, at least in one dimension,
+             * than the target.  Transform it by placing as much of the image
+             * as possible into the target and leaving the top/bottom or
+             * left/right (or both) black.
+             */
+            Bitmap b2 = Bitmap.createBitmap(targetWidth, targetHeight,
+                    Bitmap.Config.ARGB_8888);
+            Canvas c = new Canvas(b2);
+
+            int deltaXHalf = Math.max(0, deltaX / 2);
+            int deltaYHalf = Math.max(0, deltaY / 2);
+            Rect src = new Rect(
+                    deltaXHalf,
+                    deltaYHalf,
+                    deltaXHalf + Math.min(targetWidth, source.getWidth()),
+                    deltaYHalf + Math.min(targetHeight, source.getHeight()));
+            int dstX = (targetWidth - src.width()) / 2;
+            int dstY = (targetHeight - src.height()) / 2;
+            Rect dst = new Rect(
+                    dstX,
+                    dstY,
+                    targetWidth - dstX,
+                    targetHeight - dstY);
+            c.drawBitmap(source, src, dst, null);
+            return b2;
+        }
+        float bitmapWidthF = source.getWidth();
+        float bitmapHeightF = source.getHeight();
+
+        float bitmapAspect = bitmapWidthF / bitmapHeightF;
+        float viewAspect = (float) targetWidth / targetHeight;
+
+        if (bitmapAspect > viewAspect) {
+            float scale = targetHeight / bitmapHeightF;
+            if (scale < .9F || scale > 1F) {
+                scaler.setScale(scale, scale);
+            } else {
+                scaler = null;
+            }
+        } else {
+            float scale = targetWidth / bitmapWidthF;
+            if (scale < .9F || scale > 1F) {
+                scaler.setScale(scale, scale);
+            } else {
+                scaler = null;
+            }
+        }
+
+        Bitmap b1;
+        if (scaler != null) {
+            // this is used for minithumb and crop, so we want to mFilter here.
+            b1 = Bitmap.createBitmap(source, 0, 0,
+                    source.getWidth(), source.getHeight(), scaler, true);
+        } else {
+            b1 = source;
+        }
+
+        int dx1 = Math.max(0, b1.getWidth() - targetWidth);
+        int dy1 = Math.max(0, b1.getHeight() - targetHeight);
+
+        Bitmap b2 = Bitmap.createBitmap(
+                b1,
+                dx1 / 2,
+                dy1 / 2,
+                targetWidth,
+                targetHeight);
+
+        if (b1 != source) {
+            b1.recycle();
+        }
+
+        return b2;
+    }
+
+    public static void closeSilently(Closeable c) {
+
+        if (c == null) return;
+        try {
+            c.close();
+        } catch (Throwable t) {
+            // do nothing
+        }
+    }
+
+    private static class BackgroundJob
+            extends MonitoredActivity.LifeCycleAdapter implements Runnable {
+
+        private final MonitoredActivity mActivity;
+        private final ProgressDialog    mDialog;
+        private final Runnable          mJob;
+        private final Handler           mHandler;
+        private final Runnable mCleanupRunner = new Runnable() {
+            public void run() {
+
+                mActivity.removeLifeCycleListener(BackgroundJob.this);
+                if (mDialog.getWindow() != null) mDialog.dismiss();
+            }
+        };
+
+        public BackgroundJob(MonitoredActivity activity, Runnable job,
+                             ProgressDialog dialog, Handler handler) {
+
+            mActivity = activity;
+            mDialog = dialog;
+            mJob = job;
+            mActivity.addLifeCycleListener(this);
+            mHandler = handler;
+        }
+
+        public void run() {
+
+            try {
+                mJob.run();
+            } finally {
+                mHandler.post(mCleanupRunner);
+            }
+        }
+
+
+        @Override
+        public void onActivityDestroyed(MonitoredActivity activity) {
+            // We get here only when the onDestroyed being called before
+            // the mCleanupRunner. So, run it now and remove it from the queue
+            mCleanupRunner.run();
+            mHandler.removeCallbacks(mCleanupRunner);
+        }
+
+        @Override
+        public void onActivityStopped(MonitoredActivity activity) {
+
+            mDialog.hide();
+        }
+
+        @Override
+        public void onActivityStarted(MonitoredActivity activity) {
+
+            mDialog.show();
+        }
+    }
+
+    public static void startBackgroundJob(MonitoredActivity activity,
+                                          String title, String message, Runnable job, Handler handler) {
+        // Make the progress dialog uncancelable, so that we can gurantee
+        // the thread will be done before the activity getting destroyed.
+        ProgressDialog dialog = ProgressDialog.show(
+                activity, title, message, true, false);
+        new Thread(new BackgroundJob(activity, job, dialog, handler)).start();
+    }
+
+
+    // Returns Options that set the puregeable flag for Bitmap decode.
+    public static BitmapFactory.Options createNativeAllocOptions() {
+
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        //options.inNativeAlloc = true;
+        return options;
+    }
+
+    // Thong added for rotate
+    public static Bitmap rotateImage(Bitmap src, float degree) {
+        // create new matrix
+        Matrix matrix = new Matrix();
+        // setup rotation degree
+        matrix.postRotate(degree);
+        Bitmap bmp = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);
+        return bmp;
+    }
+
+    public static int getOrientationInDegree(Activity activity) {
+
+        int rotation = activity.getWindowManager().getDefaultDisplay()
+                .getRotation();
+        int degrees = 0;
+
+        switch (rotation) {
+            case Surface.ROTATION_0:
+                degrees = 0;
+                break;
+            case Surface.ROTATION_90:
+                degrees = 90;
+                break;
+            case Surface.ROTATION_180:
+                degrees = 180;
+                break;
+            case Surface.ROTATION_270:
+                degrees = 270;
+                break;
+        }
+
+        return degrees;
+    }
+}
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/interfaces/SwipeItemMangerInterface.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/interfaces/SwipeItemMangerInterface.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/interfaces/SwipeItemMangerInterface.java	(revision )
@@ -0,0 +1,29 @@
+package com.scene.mylib.view.swipelayout.interfaces;
+
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.List;
+
+public interface SwipeItemMangerInterface {
+
+    void openItem(int position);
+
+    void closeItem(int position);
+
+    void closeAllExcept(SwipeLayout layout);
+    
+    void closeAllItems();
+
+    List<Integer> getOpenItems();
+
+    List<SwipeLayout> getOpenLayouts();
+
+    void removeShownLayouts(SwipeLayout layout);
+
+    boolean isOpen(int position);
+
+    Attributes.Mode getMode();
+
+    void setMode(Attributes.Mode mode);
+}
Index: common/src/main/java/com/scene/common/common/utils/HandlerUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/HandlerUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/HandlerUtil.java	(revision )
@@ -0,0 +1,24 @@
+package com.scene.common.common.utils;
+
+import android.os.Handler;
+import android.os.Looper;
+
+/**
+ * @author MaTianyu
+ * @date 2015-03-12
+ */
+public class HandlerUtil {
+    public static final Handler HANDLER = new Handler(Looper.getMainLooper());
+
+    public static void runOnUiThread(Runnable runnable){
+        HANDLER.post(runnable);
+    }
+
+    public static void runOnUiThreadDelay(Runnable runnable, long delayMillis){
+        HANDLER.postDelayed(runnable,delayMillis);
+    }
+
+    public static void removeRunable(Runnable runnable){
+        HANDLER.removeCallbacks(runnable);
+    }
+}
Index: common/src/main/java/com/scene/common/common/assist/TimeAverager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/TimeAverager.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/TimeAverager.java	(revision )
@@ -0,0 +1,65 @@
+package com.scene.common.common.assist;
+
+
+/**
+ * 时间均值计算器,只能用于单线程计时。
+ *
+ * @author MaTianyu
+ *         2013-12-12上午1:23:19
+ */
+public class TimeAverager {
+    /**
+     * 计时器
+     */
+    private TimeCounter tc = new TimeCounter();
+    /**
+     * 均值器
+     */
+    private Averager av = new Averager();
+
+    /**
+     * 一个计时开始
+     */
+    public long start() {
+        return tc.start();
+    }
+
+    /**
+     * 一个计时结束
+     */
+    public long end() {
+        long time = tc.duration();
+        av.add(time);
+        return time;
+    }
+
+    /**
+     * 一个计时结束,并且启动下次计时。
+     */
+    public long endAndRestart() {
+        long time = tc.durationRestart();
+        av.add(time);
+        return time;
+    }
+
+    /**
+     * 求全部计时均值
+     */
+    public Number average() {
+        return av.getAverage();
+    }
+
+    /**
+     * 打印全部时间值
+     */
+    public void print() {
+        av.print();
+    }
+
+    /**
+     * 清楚数据
+     */
+    public void clear() {
+        av.clear();
+    }
+}
Index: mylib/src/main/res/layout/layout_load_state_view_empty.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/layout_load_state_view_empty.xml	(revision )
+++ mylib/src/main/res/layout/layout_load_state_view_empty.xml	(revision )
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/emptyStateRelativeLayout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:id="@+id/emptyViewRelativeLayout"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:orientation="vertical"
+        tools:ignore="UselessParent">
+
+        <ImageView
+            android:id="@+id/emptyStateImageView"
+            android:layout_width="108dp"
+            android:layout_height="108dp"
+            android:layout_gravity="center_horizontal"
+            tools:background="#000000"
+            tools:ignore="ContentDescription" />
+
+        <TextView
+            android:id="@+id/emptyStateTitleTextView"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginLeft="16dp"
+            android:layout_marginRight="16dp"
+            android:layout_marginTop="20dp"
+            android:textSize="15sp"
+            android:textStyle="bold"
+            tools:text="空页面提示标题" />
+
+        <TextView
+            android:id="@+id/emptyStateContentTextView"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginBottom="16dp"
+            android:layout_marginLeft="56dp"
+            android:layout_marginRight="56dp"
+            android:layout_marginTop="10dp"
+            android:gravity="center"
+            android:lineSpacingExtra="5.5dp"
+            tools:text="空页面提示内容" />
+
+    </LinearLayout>
+
+</RelativeLayout>
\ No newline at end of file
Index: timeline/src/main/res/drawable/marker.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/main/res/drawable/marker.xml	(revision )
+++ timeline/src/main/res/drawable/marker.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="oval">
+
+    <solid android:color="@android:color/holo_green_dark"/>
+
+</shape>
\ No newline at end of file
Index: ucrop/src/main/java/com/yalantis/ucrop/view/GestureCropImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/view/GestureCropImageView.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/view/GestureCropImageView.java	(revision )
@@ -0,0 +1,152 @@
+package com.yalantis.ucrop.view;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.view.ScaleGestureDetector;
+
+import com.yalantis.ucrop.util.RotationGestureDetector;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ */
+public class GestureCropImageView extends CropImageView {
+
+    private static final int DOUBLE_TAP_ZOOM_DURATION = 200;
+
+    private ScaleGestureDetector mScaleDetector;
+    private RotationGestureDetector mRotateDetector;
+    private GestureDetector mGestureDetector;
+
+    private float mMidPntX, mMidPntY;
+
+    private boolean mIsRotateEnabled = true, mIsScaleEnabled = true;
+    private int mDoubleTapScaleSteps = 5;
+
+    public GestureCropImageView(Context context) {
+        super(context);
+    }
+
+    public GestureCropImageView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public GestureCropImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    public void setScaleEnabled(boolean scaleEnabled) {
+        mIsScaleEnabled = scaleEnabled;
+    }
+
+    public boolean isScaleEnabled() {
+        return mIsScaleEnabled;
+    }
+
+    public void setRotateEnabled(boolean rotateEnabled) {
+        mIsRotateEnabled = rotateEnabled;
+    }
+
+    public boolean isRotateEnabled() {
+        return mIsRotateEnabled;
+    }
+
+    public void setDoubleTapScaleSteps(int doubleTapScaleSteps) {
+        mDoubleTapScaleSteps = doubleTapScaleSteps;
+    }
+
+    public int getDoubleTapScaleSteps() {
+        return mDoubleTapScaleSteps;
+    }
+
+    /**
+     * If it's ACTION_DOWN event - user touches the screen and all current animation must be canceled.
+     * If it's ACTION_UP event - user removed all fingers from the screen and current image position must be corrected.
+     * If there are more than 2 fingers - update focal point coordinates.
+     * Pass the event to the gesture detectors if those are enabled.
+     */
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
+            cancelAllAnimations();
+        }
+
+        if (event.getPointerCount() > 1) {
+            mMidPntX = (event.getX(0) + event.getX(1)) / 2;
+            mMidPntY = (event.getY(0) + event.getY(1)) / 2;
+        }
+
+        mGestureDetector.onTouchEvent(event);
+
+        if (mIsScaleEnabled) {
+            mScaleDetector.onTouchEvent(event);
+        }
+
+        if (mIsRotateEnabled) {
+            mRotateDetector.onTouchEvent(event);
+        }
+
+        if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {
+            setImageToWrapCropBounds();
+        }
+        return true;
+    }
+
+    @Override
+    protected void init(Context context, AttributeSet attrs, int defStyle) {
+        super.init(context, attrs, defStyle);
+        setupGestureListeners();
+    }
+
+    /**
+     * This method calculates target scale value for double tap gesture.
+     * User is able to zoom the image from min scale value
+     * to the max scale value with {@link #mDoubleTapScaleSteps} double taps.
+     */
+    protected float getDoubleTapTargetScale() {
+        return getCurrentScale() * (float) Math.pow(getMaxScale() / getMinScale(), 1.0f / mDoubleTapScaleSteps);
+    }
+
+    private void setupGestureListeners() {
+        mGestureDetector = new GestureDetector(getContext(), new GestureListener(), null, true);
+        mScaleDetector = new ScaleGestureDetector(getContext(), new ScaleListener());
+        mRotateDetector = new RotationGestureDetector(new RotateListener());
+    }
+
+    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {
+
+        @Override
+        public boolean onScale(ScaleGestureDetector detector) {
+            postScale(detector.getScaleFactor(), mMidPntX, mMidPntY);
+            return true;
+        }
+    }
+
+    private class GestureListener extends GestureDetector.SimpleOnGestureListener {
+
+        @Override
+        public boolean onDoubleTap(MotionEvent e) {
+            zoomImageToPosition(getDoubleTapTargetScale(), e.getX(), e.getY(), DOUBLE_TAP_ZOOM_DURATION);
+            return super.onDoubleTap(e);
+        }
+
+        @Override
+        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+            postTranslate(-distanceX, -distanceY);
+            return true;
+        }
+
+    }
+
+    private class RotateListener extends RotationGestureDetector.SimpleOnRotationGestureListener {
+
+        @Override
+        public boolean onRotation(RotationGestureDetector rotationDetector) {
+            postRotate(rotationDetector.getAngle(), mMidPntX, mMidPntY);
+            return true;
+        }
+
+    }
+
+}
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/SimpleSwipeListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/SimpleSwipeListener.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/SimpleSwipeListener.java	(revision )
@@ -0,0 +1,28 @@
+package com.scene.mylib.view.swipelayout;
+
+public class SimpleSwipeListener implements SwipeLayout.SwipeListener {
+
+    @Override
+    public void onStartOpen(SwipeLayout layout) {
+    }
+
+    @Override
+    public void onOpen(SwipeLayout layout) {
+    }
+
+    @Override
+    public void onStartClose(SwipeLayout layout) {
+    }
+
+    @Override
+    public void onClose(SwipeLayout layout) {
+    }
+
+    @Override
+    public void onUpdate(SwipeLayout layout, int leftOffset, int topOffset) {
+    }
+
+    @Override
+    public void onHandRelease(SwipeLayout layout, float xvel, float yvel) {
+    }
+}
Index: common/src/main/java/com/scene/common/common/io/IOUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/IOUtils.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/IOUtils.java	(revision )
@@ -0,0 +1,2409 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io;
+
+import android.os.Build;
+import com.scene.common.common.io.stream.*;
+
+import java.io.*;
+import java.net.*;
+import java.nio.channels.Selector;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * General IO stream manipulation utilities.
+ * <p/>
+ * This class provides static utility methods for input/output operations.
+ * <ul>
+ * <li>closeQuietly - these methods close a stream ignoring nulls and exceptions
+ * <li>toXxx/read - these methods read data from a stream
+ * <li>write - these methods write data to a stream
+ * <li>copy - these methods copy all the data from one stream to another
+ * <li>contentEquals - these methods compare the content of two streams
+ * </ul>
+ * <p/>
+ * The byte-to-char methods and char-to-byte methods involve a conversion step.
+ * Two methods are provided in each case, one that uses the platform default
+ * encoding and the other which allows you to specify an encoding. You are
+ * encouraged to always specify an encoding because relying on the platform
+ * default can lead to unexpected results, for example when moving from
+ * development to production.
+ * <p/>
+ * All the methods in this class that read a stream are buffered internally.
+ * This means that there is no cause to use a <code>BufferedInputStream</code>
+ * or <code>BufferedReader</code>. The default buffer size of 4K has been shown
+ * to be efficient in tests.
+ * <p/>
+ * Wherever possible, the methods in this class do <em>not</em> flush or close
+ * the stream. This is to avoid making non-portable assumptions about the
+ * streams' origin and further use. Thus the caller is still responsible for
+ * closing streams after use.
+ * <p/>
+ * Origin of code: Excalibur.
+ *
+ * @version $Id: IOUtils.java 1326636 2012-04-16 14:54:53Z ggregory $
+ */
+public class IOUtils {
+    // NOTE: This class is focussed on InputStream, OutputStream, Reader and
+    // Writer. Each method should take at least one of these as a parameter,
+    // or return one of them.
+
+    private static final int    EOF                    = -1;
+    /**
+     * The Unix directory separator character.
+     */
+    public static final  char   DIR_SEPARATOR_UNIX     = '/';
+    /**
+     * The Windows directory separator character.
+     */
+    public static final  char   DIR_SEPARATOR_WINDOWS  = '\\';
+    /**
+     * The system directory separator character.
+     */
+    public static final  char   DIR_SEPARATOR          = File.separatorChar;
+    /**
+     * The Unix line separator string.
+     */
+    public static final  String LINE_SEPARATOR_UNIX    = "\n";
+    /**
+     * The Windows line separator string.
+     */
+    public static final  String LINE_SEPARATOR_WINDOWS = "\r\n";
+    /**
+     * The system line separator string.
+     */
+    public static final String LINE_SEPARATOR;
+
+    static {
+        // avoid security issues
+        StringBuilderWriter buf = new StringBuilderWriter(4);
+        PrintWriter out = new PrintWriter(buf);
+        out.println();
+        LINE_SEPARATOR = buf.toString();
+        out.close();
+    }
+
+    /**
+     * The default buffer size ({@value}) to use for
+     * {@link #copyLarge(InputStream, OutputStream)}
+     * and
+     * {@link #copyLarge(Reader, Writer)}
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
+
+    /**
+     * The default buffer size to use for the skip() methods.
+     */
+    private static final int SKIP_BUFFER_SIZE = 2048;
+
+    // Allocated in the relevant skip method if necessary.
+    /*
+     * N.B. no need to synchronize these because:
+     * - we don't care if the buffer is created multiple times (the data is ignored)
+     * - we always use the same size buffer, so if it it is recreated it will still be OK
+     * (if the buffer size were variable, we would need to synch. to ensure some other thread
+     * did not create a smaller one)
+     */
+    private static char[] SKIP_CHAR_BUFFER;
+    private static byte[] SKIP_BYTE_BUFFER;
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public IOUtils() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Closes a URLConnection.
+     *
+     * @param conn the connection to close.
+     * @since 2.4
+     */
+    public static void close(URLConnection conn) {
+        if (conn instanceof HttpURLConnection) {
+            ((HttpURLConnection) conn).disconnect();
+        }
+    }
+
+    /**
+     * Unconditionally close an <code>Reader</code>.
+     * <p/>
+     * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   char[] data = new char[1024];
+     *   Reader in = null;
+     *   try {
+     *       in = new FileReader("foo.txt");
+     *       in.read(data);
+     *       in.close(); //close errors are handled
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(in);
+     *   }
+     * </pre>
+     *
+     * @param input the Reader to close, may be null or already closed
+     */
+    public static void closeQuietly(Reader input) {
+        closeQuietly((Closeable) input);
+    }
+
+    /**
+     * Unconditionally close a <code>Writer</code>.
+     * <p/>
+     * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   Writer out = null;
+     *   try {
+     *       out = new StringWriter();
+     *       out.write("Hello World");
+     *       out.close(); //close errors are handled
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(out);
+     *   }
+     * </pre>
+     *
+     * @param output the Writer to close, may be null or already closed
+     */
+    public static void closeQuietly(Writer output) {
+        closeQuietly((Closeable) output);
+    }
+
+    /**
+     * Unconditionally close an <code>InputStream</code>.
+     * <p/>
+     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   byte[] data = new byte[1024];
+     *   InputStream in = null;
+     *   try {
+     *       in = new FileInputStream("foo.txt");
+     *       in.read(data);
+     *       in.close(); //close errors are handled
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(in);
+     *   }
+     * </pre>
+     *
+     * @param input the InputStream to close, may be null or already closed
+     */
+    public static void closeQuietly(InputStream input) {
+        closeQuietly((Closeable) input);
+    }
+
+    /**
+     * Unconditionally close an <code>OutputStream</code>.
+     * <p/>
+     * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     * byte[] data = "Hello, World".getBytes();
+     *
+     * OutputStream out = null;
+     * try {
+     *     out = new FileOutputStream("foo.txt");
+     *     out.write(data);
+     *     out.close(); //close errors are handled
+     * } catch (IOException e) {
+     *     // error handling
+     * } finally {
+     *     IOUtils.closeQuietly(out);
+     * }
+     * </pre>
+     *
+     * @param output the OutputStream to close, may be null or already closed
+     */
+    public static void closeQuietly(OutputStream output) {
+        closeQuietly((Closeable) output);
+    }
+
+    /**
+     * Unconditionally close a <code>Closeable</code>.
+     * <p/>
+     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   Closeable closeable = null;
+     *   try {
+     *       closeable = new FileReader("foo.txt");
+     *       // process closeable
+     *       closeable.close();
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(closeable);
+     *   }
+     * </pre>
+     *
+     * @param closeable the object to close, may be null or already closed
+     * @since 2.0
+     */
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException ioe) {
+            // ignore
+        }
+    }
+
+    /**
+     * Unconditionally close a <code>Socket</code>.
+     * <p/>
+     * Equivalent to {@link Socket#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   Socket socket = null;
+     *   try {
+     *       socket = new Socket("http://www.foo.com/", 80);
+     *       // process socket
+     *       socket.close();
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(socket);
+     *   }
+     * </pre>
+     *
+     * @param sock the Socket to close, may be null or already closed
+     * @since 2.0
+     */
+    public static void closeQuietly(Socket sock) {
+        if (sock != null) {
+            try {
+                sock.close();
+            } catch (IOException ioe) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Unconditionally close a <code>Selector</code>.
+     * <p/>
+     * Equivalent to {@link Selector#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   Selector selector = null;
+     *   try {
+     *       selector = Selector.open();
+     *       // process socket
+     *
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(selector);
+     *   }
+     * </pre>
+     *
+     * @param selector the Selector to close, may be null or already closed
+     * @since 2.2
+     */
+    public static void closeQuietly(Selector selector) {
+        if (selector != null) {
+            try {
+                selector.close();
+            } catch (IOException ioe) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Unconditionally close a <code>ServerSocket</code>.
+     * <p/>
+     * Equivalent to {@link ServerSocket#close()}, except any exceptions will be ignored.
+     * This is typically used in finally blocks.
+     * <p/>
+     * Example code:
+     * <pre>
+     *   ServerSocket socket = null;
+     *   try {
+     *       socket = new ServerSocket();
+     *       // process socket
+     *       socket.close();
+     *   } catch (Exception e) {
+     *       // error handling
+     *   } finally {
+     *       IOUtils.closeQuietly(socket);
+     *   }
+     * </pre>
+     *
+     * @param sock the ServerSocket to close, may be null or already closed
+     * @since 2.2
+     */
+    public static void closeQuietly(ServerSocket sock) {
+        if (sock != null) {
+            try {
+                sock.close();
+            } catch (IOException ioe) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Fetches entire contents of an <code>InputStream</code> and represent
+     * same data as result InputStream.
+     * <p/>
+     * This method is useful where,
+     * <ul>
+     * <li>Source InputStream is slow.</li>
+     * <li>It has network resources associated, so we cannot keep it open for
+     * long time.</li>
+     * <li>It has network timeout associated.</li>
+     * </ul>
+     * It can be used in favor of {@link #toByteArray(InputStream)}, since it
+     * avoids unnecessary allocation and copy of byte[].<br>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input Stream to be fully buffered.
+     * @return A fully buffered stream.
+     * @throws IOException if an I/O error occurs
+     * @since 2.0
+     */
+    public static InputStream toBufferedInputStream(InputStream input) throws IOException {
+        return com.scene.common.common.io.stream.ByteArrayOutputStream.toBufferedInputStream(input);
+    }
+
+    /**
+     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a toBufferedReader for the given
+     * reader.
+     *
+     * @param reader the reader to wrap or return
+     * @return the given reader or a new {@link BufferedReader} for the given reader
+     * @since 2.2
+     */
+    public static BufferedReader toBufferedReader(Reader reader) {
+        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
+    }
+
+    // read toByteArray
+    //-----------------------------------------------------------------------
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     */
+    public static byte[] toByteArray(InputStream input) throws IOException {
+        com.scene.common.common.io.stream.ByteArrayOutputStream output = new com.scene.common.common.io.stream.ByteArrayOutputStream();
+        copy(input, output);
+        return output.toByteArray();
+    }
+
+    /**
+     * Get contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * Use this method instead of <code>toByteArray(InputStream)</code>
+     * when <code>InputStream</code> size is known.
+     * <b>NOTE:</b> the method checks that the length can safely be cast to an int without truncation
+     * before using {@link com.scene.common.common.io.IOUtils#toByteArray(InputStream, int)} to read into the byte array.
+     * (Arrays can have no more than Integer.MAX_VALUE entries anyway)
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param size  the size of <code>InputStream</code>
+     * @return the requested byte array
+     * @throws IOException      if an I/O error occurs or <code>InputStream</code> size differ from parameter size
+     * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE
+     * @see com.scene.common.common.io.IOUtils#toByteArray(InputStream, int)
+     * @since 2.1
+     */
+    public static byte[] toByteArray(InputStream input, long size) throws IOException {
+
+        if (size > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("Size cannot be greater than Integer max value: " + size);
+        }
+
+        return toByteArray(input, (int) size);
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * Use this method instead of <code>toByteArray(InputStream)</code>
+     * when <code>InputStream</code> size is known
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @param size  the size of <code>InputStream</code>
+     * @return the requested byte array
+     * @throws IOException      if an I/O error occurs or <code>InputStream</code> size differ from parameter size
+     * @throws IllegalArgumentException if size is less than zero
+     * @since 2.1
+     */
+    public static byte[] toByteArray(InputStream input, int size) throws IOException {
+
+        if (size < 0) {
+            throw new IllegalArgumentException("Size must be equal or greater than zero: " + size);
+        }
+
+        if (size == 0) {
+            return new byte[0];
+        }
+
+        byte[] data = new byte[size];
+        int offset = 0;
+        int readed;
+
+        while (offset < size && (readed = input.read(data, offset, size - offset)) != EOF) {
+            offset += readed;
+        }
+
+        if (offset != size) {
+            throw new IOException("Unexpected readed size. current: " + offset + ", excepted: " + size);
+        }
+
+        return data;
+    }
+
+    /**
+     * Get the contents of a <code>Reader</code> as a <code>byte[]</code>
+     * using the default character encoding of the platform.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     */
+    public static byte[] toByteArray(Reader input) throws IOException {
+        return toByteArray(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Get the contents of a <code>Reader</code> as a <code>byte[]</code>
+     * using the specified character encoding.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input    the <code>Reader</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static byte[] toByteArray(Reader input, Charset encoding) throws IOException {
+        com.scene.common.common.io.stream.ByteArrayOutputStream output = new com.scene.common.common.io.stream.ByteArrayOutputStream();
+        copy(input, output, encoding);
+        return output.toByteArray();
+    }
+
+    /**
+     * Get the contents of a <code>Reader</code> as a <code>byte[]</code>
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input    the <code>Reader</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested byte array
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static byte[] toByteArray(Reader input, String encoding) throws IOException {
+        return toByteArray(input, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Get the contents of a <code>String</code> as a <code>byte[]</code>
+     * using the default character encoding of the platform.
+     * <p/>
+     * This is the same as {@link String#getBytes()}.
+     *
+     * @param input the <code>String</code> to convert
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs (never occurs)
+     * @deprecated Use {@link String#getBytes()}
+     */
+    @Deprecated
+    public static byte[] toByteArray(String input) throws IOException {
+        return input.getBytes();
+    }
+
+    /**
+     * Get the contents of a <code>URI</code> as a <code>byte[]</code>.
+     *
+     * @param uri the <code>URI</code> to read
+     * @return the requested byte array
+     * @throws NullPointerException if the uri is null
+     * @throws IOException  if an I/O exception occurs
+     * @since 2.4
+     */
+    public static byte[] toByteArray(URI uri) throws IOException {
+        return IOUtils.toByteArray(uri.toURL());
+    }
+
+    /**
+     * Get the contents of a <code>URL</code> as a <code>byte[]</code>.
+     *
+     * @param url the <code>URL</code> to read
+     * @return the requested byte array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O exception occurs
+     * @since 2.4
+     */
+    public static byte[] toByteArray(URL url) throws IOException {
+        URLConnection conn = url.openConnection();
+        try {
+            return IOUtils.toByteArray(conn);
+        } finally {
+            close(conn);
+        }
+    }
+
+    /**
+     * Get the contents of a <code>URLConnection</code> as a <code>byte[]</code>.
+     *
+     * @param urlConn the <code>URLConnection</code> to read
+     * @return the requested byte array
+     * @throws NullPointerException if the urlConn is null
+     * @throws IOException  if an I/O exception occurs
+     * @since 2.4
+     */
+    public static byte[] toByteArray(URLConnection urlConn) throws IOException {
+        InputStream inputStream = urlConn.getInputStream();
+        try {
+            return IOUtils.toByteArray(inputStream);
+        } finally {
+            inputStream.close();
+        }
+    }
+
+    // read char[]
+    //-----------------------------------------------------------------------
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a character array
+     * using the default character encoding of the platform.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param is the <code>InputStream</code> to read from
+     * @return the requested character array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static char[] toCharArray(InputStream is) throws IOException {
+        return toCharArray(is, Charset.defaultCharset());
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a character array
+     * using the specified character encoding.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param is       the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested character array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static char[] toCharArray(InputStream is, Charset encoding)
+            throws IOException {
+        CharArrayWriter output = new CharArrayWriter();
+        copy(is, output, encoding);
+        return output.toCharArray();
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a character array
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param is       the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested character array
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static char[] toCharArray(InputStream is, String encoding) throws IOException {
+        return toCharArray(is, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Get the contents of a <code>Reader</code> as a character array.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @return the requested character array
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static char[] toCharArray(Reader input) throws IOException {
+        CharArrayWriter sw = new CharArrayWriter();
+        copy(input, sw);
+        return sw.toCharArray();
+    }
+
+    // read toString
+    //-----------------------------------------------------------------------
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a String
+     * using the default character encoding of the platform.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input the <code>InputStream</code> to read from
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     */
+    public static String toString(InputStream input) throws IOException {
+        return toString(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a String
+     * using the specified character encoding.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * </p>
+     *
+     * @param input    the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static String toString(InputStream input, Charset encoding) throws IOException {
+        StringBuilderWriter sw = new StringBuilderWriter();
+        copy(input, sw, encoding);
+        return sw.toString();
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a String
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input    the <code>InputStream</code> to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     */
+    public static String toString(InputStream input, String encoding)
+            throws IOException {
+        return toString(input, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Get the contents of a <code>Reader</code> as a String.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     */
+    public static String toString(Reader input) throws IOException {
+        StringBuilderWriter sw = new StringBuilderWriter();
+        copy(input, sw);
+        return sw.toString();
+    }
+
+    /**
+     * Gets the contents at the given URI.
+     *
+     * @param uri The URI source.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.1
+     */
+    public static String toString(URI uri) throws IOException {
+        return toString(uri, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents at the given URI.
+     *
+     * @param uri      The URI source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.3.
+     */
+    public static String toString(URI uri, Charset encoding) throws IOException {
+        return toString(uri.toURL(), Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents at the given URI.
+     *
+     * @param uri      The URI source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException                          if an I/O exception occurs.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 2.1
+     */
+    public static String toString(URI uri, String encoding) throws IOException {
+        return toString(uri, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Gets the contents at the given URL.
+     *
+     * @param url The URL source.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.1
+     */
+    public static String toString(URL url) throws IOException {
+        return toString(url, Charset.defaultCharset());
+    }
+
+    /**
+     * Gets the contents at the given URL.
+     *
+     * @param url      The URL source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException if an I/O exception occurs.
+     * @since 2.3
+     */
+    public static String toString(URL url, Charset encoding) throws IOException {
+        InputStream inputStream = url.openStream();
+        try {
+            return toString(inputStream, encoding);
+        } finally {
+            inputStream.close();
+        }
+    }
+
+    /**
+     * Gets the contents at the given URL.
+     *
+     * @param url      The URL source.
+     * @param encoding The encoding name for the URL contents.
+     * @return The contents of the URL as a String.
+     * @throws IOException                          if an I/O exception occurs.
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 2.1
+     */
+    public static String toString(URL url, String encoding) throws IOException {
+        return toString(url, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Get the contents of a <code>byte[]</code> as a String
+     * using the default character encoding of the platform.
+     *
+     * @param input the byte array to read from
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs (never occurs)
+     * @deprecated Use {@link String#String(byte[])}
+     */
+    @Deprecated
+    public static String toString(byte[] input) throws IOException {
+        return new String(input);
+    }
+
+    /**
+     * Get the contents of a <code>byte[]</code> as a String
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param input    the byte array to read from
+     * @param encoding the encoding to use, null means platform default
+     * @return the requested String
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs (never occurs)
+     */
+    public static String toString(byte[] input, String encoding) throws IOException {
+        return new String(input, encoding);
+    }
+
+    // readLines
+    //-----------------------------------------------------------------------
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a list of Strings,
+     * one entry per line, using the default character encoding of the platform.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input the <code>InputStream</code> to read from, not null
+     * @return the list of Strings, never null
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static List<String> readLines(InputStream input) throws IOException {
+        return readLines(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a list of Strings,
+     * one entry per line, using the specified character encoding.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input    the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
+     * @return the list of Strings, never null
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static List<String> readLines(InputStream input, Charset encoding) throws IOException {
+        InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(encoding));
+        return readLines(reader);
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a list of Strings,
+     * one entry per line, using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     *
+     * @param input    the <code>InputStream</code> to read from, not null
+     * @param encoding the encoding to use, null means platform default
+     * @return the list of Strings, never null
+     * @throws NullPointerException                         if the input is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static List<String> readLines(InputStream input, String encoding) throws IOException {
+        return readLines(input, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Get the contents of a <code>Reader</code> as a list of Strings,
+     * one entry per line.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input the <code>Reader</code> to read from, not null
+     * @return the list of Strings, never null
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static List<String> readLines(Reader input) throws IOException {
+        BufferedReader reader = toBufferedReader(input);
+        List<String> list = new ArrayList<String>();
+        String line = reader.readLine();
+        while (line != null) {
+            list.add(line);
+            line = reader.readLine();
+        }
+        return list;
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Convert the specified CharSequence to an input stream, encoded as bytes
+     * using the default character encoding of the platform.
+     *
+     * @param input the CharSequence to convert
+     * @return an input stream
+     * @since 2.0
+     */
+    public static InputStream toInputStream(CharSequence input) {
+        return toInputStream(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Convert the specified CharSequence to an input stream, encoded as bytes
+     * using the specified character encoding.
+     *
+     * @param input    the CharSequence to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @since 2.3
+     */
+    public static InputStream toInputStream(CharSequence input, Charset encoding) {
+        return toInputStream(input.toString(), encoding);
+    }
+
+    /**
+     * Convert the specified CharSequence to an input stream, encoded as bytes
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param input    the CharSequence to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @throws IOException                          if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 2.0
+     */
+    public static InputStream toInputStream(CharSequence input, String encoding) throws IOException {
+        return toInputStream(input, Charsets.toCharset(encoding));
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Convert the specified string to an input stream, encoded as bytes
+     * using the default character encoding of the platform.
+     *
+     * @param input the string to convert
+     * @return an input stream
+     * @since 1.1
+     */
+    public static InputStream toInputStream(String input) {
+        return toInputStream(input, Charset.defaultCharset());
+    }
+
+    /**
+     * Convert the specified string to an input stream, encoded as bytes
+     * using the specified character encoding.
+     *
+     * @param input    the string to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @since 2.3
+     */
+    public static InputStream toInputStream(String input, Charset encoding) {
+        return new ByteArrayInputStream(StringCodingUtils.getBytes(input, Charsets.toCharset(encoding)));
+    }
+
+    /**
+     * Convert the specified string to an input stream, encoded as bytes
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param input    the string to convert
+     * @param encoding the encoding to use, null means platform default
+     * @return an input stream
+     * @throws IOException                          if the encoding is invalid
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static InputStream toInputStream(String input, String encoding) throws IOException {
+        byte[] bytes = StringCodingUtils.getBytes(input,Charsets.toCharset(encoding));
+        return new ByteArrayInputStream(bytes);
+    }
+
+    // write byte[]
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to an <code>OutputStream</code>.
+     *
+     * @param data   the byte array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(byte[] data, OutputStream output)
+            throws IOException {
+        if (data != null) {
+            output.write(data);
+        }
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
+     * using the default character encoding of the platform.
+     * <p/>
+     * This method uses {@link String#String(byte[])}.
+     *
+     * @param data   the byte array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(byte[] data, Writer output) throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
+     * using the specified character encoding.
+     * <p/>
+     * This method uses {@link String#String(byte[], String)}.
+     *
+     * @param data     the byte array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(byte[] data, Writer output, Charset encoding) throws IOException {
+        if (data != null) {
+            if(Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD){
+                output.write(new String(data, Charsets.toCharset(encoding).name()));
+            }else{
+                output.write(new String(data, Charsets.toCharset(encoding)));
+            }
+        }
+    }
+
+    /**
+     * Writes bytes from a <code>byte[]</code> to chars on a <code>Writer</code>
+     * using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method uses {@link String#String(byte[], String)}.
+     *
+     * @param data     the byte array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static void write(byte[] data, Writer output, String encoding) throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write char[]
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>char[]</code> to a <code>Writer</code>
+     * using the default character encoding of the platform.
+     *
+     * @param data   the char array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(char[] data, Writer output) throws IOException {
+        if (data != null) {
+            output.write(data);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to bytes on an
+     * <code>OutputStream</code>.
+     * <p/>
+     * This method uses {@link String#String(char[])} and
+     * {@link String#getBytes()}.
+     *
+     * @param data   the char array to write, do not modify during output,
+     *               null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(char[] data, OutputStream output)
+            throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * This method uses {@link String#String(char[])} and
+     * {@link String#getBytes(String)}.
+     *
+     * @param data     the char array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(char[] data, OutputStream output, Charset encoding) throws IOException {
+        if (data != null) {
+            output.write(StringCodingUtils.getBytes(new String(data), Charsets.toCharset(encoding)));
+        }
+    }
+
+    /**
+     * Writes chars from a <code>char[]</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method uses {@link String#String(char[])} and
+     * {@link String#getBytes(String)}.
+     *
+     * @param data     the char array to write, do not modify during output,
+     *                 null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static void write(char[] data, OutputStream output, String encoding)
+            throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write CharSequence
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to a <code>Writer</code>.
+     *
+     * @param data   the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.0
+     */
+    public static void write(CharSequence data, Writer output) throws IOException {
+        if (data != null) {
+            write(data.toString(), output);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform.
+     * <p/>
+     * This method uses {@link String#getBytes()}.
+     *
+     * @param data   the <code>CharSequence</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.0
+     */
+    public static void write(CharSequence data, OutputStream output)
+            throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>CharSequence</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(CharSequence data, OutputStream output, Charset encoding) throws IOException {
+        if (data != null) {
+            write(data.toString(), output, encoding);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>CharSequence</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>CharSequence</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 2.0
+     */
+    public static void write(CharSequence data, OutputStream output, String encoding) throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write String
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>String</code> to a <code>Writer</code>.
+     *
+     * @param data   the <code>String</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(String data, Writer output) throws IOException {
+        if (data != null) {
+            output.write(data);
+        }
+    }
+
+    /**
+     * Writes chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform.
+     * <p/>
+     * This method uses {@link String#getBytes()}.
+     *
+     * @param data   the <code>String</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void write(String data, OutputStream output)
+            throws IOException {
+        write(data, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>String</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void write(String data, OutputStream output, Charset encoding) throws IOException {
+        if (data != null) {
+            output.write(StringCodingUtils.getBytes(data, Charsets.toCharset(encoding)));
+        }
+    }
+
+    /**
+     * Writes chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>String</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static void write(String data, OutputStream output, String encoding)
+            throws IOException {
+        write(data, output, Charsets.toCharset(encoding));
+    }
+
+    // write StringBuffer
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes chars from a <code>StringBuffer</code> to a <code>Writer</code>.
+     *
+     * @param data   the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     * @deprecated replaced by write(CharSequence, Writer)
+     */
+    @Deprecated
+    public static void write(StringBuffer data, Writer output)
+            throws IOException {
+        if (data != null) {
+            output.write(data.toString());
+        }
+    }
+
+    /**
+     * Writes chars from a <code>StringBuffer</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform.
+     * <p/>
+     * This method uses {@link String#getBytes()}.
+     *
+     * @param data   the <code>StringBuffer</code> to write, null ignored
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     * @deprecated replaced by write(CharSequence, OutputStream)
+     */
+    @Deprecated
+    public static void write(StringBuffer data, OutputStream output)
+            throws IOException {
+        write(data, output, (String) null);
+    }
+
+    /**
+     * Writes chars from a <code>StringBuffer</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method uses {@link String#getBytes(String)}.
+     *
+     * @param data     the <code>StringBuffer</code> to write, null ignored
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     * @deprecated replaced by write(CharSequence, OutputStream, String)
+     */
+    @Deprecated
+    public static void write(StringBuffer data, OutputStream output, String encoding) throws IOException {
+        if (data != null) {
+            output.write(StringCodingUtils.getBytes(data.toString(), Charsets.toCharset(encoding)));
+        }
+    }
+
+    // writeLines
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * an <code>OutputStream</code> line by line, using the default character
+     * encoding of the platform and the specified line ending.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output     the <code>OutputStream</code> to write to, not null, not closed
+     * @throws NullPointerException if the output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void writeLines(Collection<?> lines, String lineEnding,
+                                  OutputStream output) throws IOException {
+        writeLines(lines, lineEnding, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * an <code>OutputStream</code> line by line, using the specified character
+     * encoding and the specified line ending.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output     the <code>OutputStream</code> to write to, not null, not closed
+     * @param encoding   the encoding to use, null means platform default
+     * @throws NullPointerException if the output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void writeLines(Collection<?> lines, String lineEnding, OutputStream output, Charset encoding)
+            throws IOException {
+        if (lines == null) {
+            return;
+        }
+        if (lineEnding == null) {
+            lineEnding = LINE_SEPARATOR;
+        }
+        Charset cs = Charsets.toCharset(encoding);
+        for (Object line : lines) {
+            if (line != null) {
+                output.write(StringCodingUtils.getBytes(line.toString(), cs));
+            }
+            output.write(StringCodingUtils.getBytes(lineEnding,cs));
+        }
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * an <code>OutputStream</code> line by line, using the specified character
+     * encoding and the specified line ending.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param output     the <code>OutputStream</code> to write to, not null, not closed
+     * @param encoding   the encoding to use, null means platform default
+     * @throws NullPointerException                         if the output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static void writeLines(Collection<?> lines, String lineEnding,
+                                  OutputStream output, String encoding) throws IOException {
+        writeLines(lines, lineEnding, output, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * a <code>Writer</code> line by line, using the specified line ending.
+     *
+     * @param lines      the lines to write, null entries produce blank lines
+     * @param lineEnding the line separator to use, null is system default
+     * @param writer     the <code>Writer</code> to write to, not null, not closed
+     * @throws NullPointerException if the input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void writeLines(Collection<?> lines, String lineEnding,
+                                  Writer writer) throws IOException {
+        if (lines == null) {
+            return;
+        }
+        if (lineEnding == null) {
+            lineEnding = LINE_SEPARATOR;
+        }
+        for (Object line : lines) {
+            if (line != null) {
+                writer.write(line.toString());
+            }
+            writer.write(lineEnding);
+        }
+    }
+
+    // copy from InputStream
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copy bytes from an <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     * Large streams (over 2GB) will return a bytes copied value of
+     * <code>-1</code> after the copy has completed since the correct
+     * number of bytes cannot be returned as an int. For large streams
+     * use the <code>copyLarge(InputStream, OutputStream)</code> method.
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @return the number of bytes copied, or -1 if &gt; Integer.MAX_VALUE
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static int copy(InputStream input, OutputStream output) throws IOException {
+        long count = copyLarge(input, output);
+        if (count > Integer.MAX_VALUE) {
+            return -1;
+        }
+        return (int) count;
+    }
+
+    /**
+     * Copy bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.3
+     */
+    public static long copyLarge(InputStream input, OutputStream output)
+            throws IOException {
+        return copyLarge(input, output, new byte[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copy bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p/>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @param buffer the buffer to use for the copy
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(InputStream input, OutputStream output, byte[] buffer)
+            throws IOException {
+        long count = 0;
+        int n = 0;
+        while (EOF != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    /**
+     * Copy some or all bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input bytes.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input       the <code>InputStream</code> to read from
+     * @param output      the <code>OutputStream</code> to write to
+     * @param inputOffset : number of bytes to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of bytes to copy. -ve means all
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(InputStream input, OutputStream output, long inputOffset, long length)
+            throws IOException {
+        return copyLarge(input, output, inputOffset, length, new byte[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copy some or all bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input bytes.
+     * <p/>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     *
+     * @param input       the <code>InputStream</code> to read from
+     * @param output      the <code>OutputStream</code> to write to
+     * @param inputOffset : number of bytes to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of bytes to copy. -ve means all
+     * @param buffer      the buffer to use for the copy
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(InputStream input, OutputStream output,
+                                 final long inputOffset, final long length, byte[] buffer) throws IOException {
+        if (inputOffset > 0) {
+            skipFully(input, inputOffset);
+        }
+        if (length == 0) {
+            return 0;
+        }
+        final int bufferLength = buffer.length;
+        int bytesToRead = bufferLength;
+        if (length > 0 && length < bufferLength) {
+            bytesToRead = (int) length;
+        }
+        int read;
+        long totalRead = 0;
+        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {
+            output.write(buffer, 0, read);
+            totalRead += read;
+            if (length > 0) { // only adjust length if not reading to the end
+                // Note the cast must work because buffer.length is an integer
+                bytesToRead = (int) Math.min(length - totalRead, bufferLength);
+            }
+        }
+        return totalRead;
+    }
+
+    /**
+     * Copy bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code> using the default character encoding of the platform.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     * This method uses {@link InputStreamReader}.
+     *
+     * @param input  the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void copy(InputStream input, Writer output)
+            throws IOException {
+        copy(input, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Copy bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code> using the specified character encoding.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     * This method uses {@link InputStreamReader}.
+     *
+     * @param input    the <code>InputStream</code> to read from
+     * @param output   the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void copy(InputStream input, Writer output, Charset encoding) throws IOException {
+        InputStreamReader in = new InputStreamReader(input, Charsets.toCharset(encoding));
+        copy(in, output);
+    }
+
+    /**
+     * Copy bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code> using the specified character encoding.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * This method uses {@link InputStreamReader}.
+     *
+     * @param input    the <code>InputStream</code> to read from
+     * @param output   the <code>Writer</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if the input or output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static void copy(InputStream input, Writer output, String encoding) throws IOException {
+        copy(input, output, Charsets.toCharset(encoding));
+    }
+
+    // copy from Reader
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copy chars from a <code>Reader</code> to a <code>Writer</code>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     * Large streams (over 2GB) will return a chars copied value of
+     * <code>-1</code> after the copy has completed since the correct
+     * number of chars cannot be returned as an int. For large streams
+     * use the <code>copyLarge(Reader, Writer)</code> method.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static int copy(Reader input, Writer output) throws IOException {
+        long count = copyLarge(input, output);
+        if (count > Integer.MAX_VALUE) {
+            return -1;
+        }
+        return (int) count;
+    }
+
+    /**
+     * Copy chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.3
+     */
+    public static long copyLarge(Reader input, Writer output) throws IOException {
+        return copyLarge(input, output, new char[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copy chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
+     * <p/>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @param buffer the buffer to be used for the copy
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(Reader input, Writer output, char[] buffer) throws IOException {
+        long count = 0;
+        int n = 0;
+        while (EOF != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    /**
+     * Copy some or all chars from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input chars.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input       the <code>Reader</code> to read from
+     * @param output      the <code>Writer</code> to write to
+     * @param inputOffset : number of chars to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of chars to copy. -ve means all
+     * @return the number of chars copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(Reader input, Writer output, final long inputOffset, final long length)
+            throws IOException {
+        return copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]);
+    }
+
+    /**
+     * Copy some or all chars from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>, optionally skipping input chars.
+     * <p/>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     *
+     * @param input       the <code>Reader</code> to read from
+     * @param output      the <code>Writer</code> to write to
+     * @param inputOffset : number of chars to skip from input before copying
+     *                    -ve values are ignored
+     * @param length      : number of chars to copy. -ve means all
+     * @param buffer      the buffer to be used for the copy
+     * @return the number of chars copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static long copyLarge(Reader input, Writer output, final long inputOffset, final long length, char[] buffer)
+            throws IOException {
+        if (inputOffset > 0) {
+            skipFully(input, inputOffset);
+        }
+        if (length == 0) {
+            return 0;
+        }
+        int bytesToRead = buffer.length;
+        if (length > 0 && length < buffer.length) {
+            bytesToRead = (int) length;
+        }
+        int read;
+        long totalRead = 0;
+        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {
+            output.write(buffer, 0, read);
+            totalRead += read;
+            if (length > 0) { // only adjust length if not reading to the end
+                // Note the cast must work because buffer.length is an integer
+                bytesToRead = (int) Math.min(length - totalRead, buffer.length);
+            }
+        }
+        return totalRead;
+    }
+
+    /**
+     * Copy chars from a <code>Reader</code> to bytes on an
+     * <code>OutputStream</code> using the default character encoding of the
+     * platform, and calling flush.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     * Due to the implementation of OutputStreamWriter, this method performs a
+     * flush.
+     * <p/>
+     * This method uses {@link OutputStreamWriter}.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static void copy(Reader input, OutputStream output)
+            throws IOException {
+        copy(input, output, Charset.defaultCharset());
+    }
+
+    /**
+     * Copy chars from a <code>Reader</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding, and
+     * calling flush.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * </p>
+     * <p>
+     * Due to the implementation of OutputStreamWriter, this method performs a
+     * flush.
+     * </p>
+     * <p>
+     * This method uses {@link OutputStreamWriter}.
+     * </p>
+     *
+     * @param input    the <code>Reader</code> to read from
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.3
+     */
+    public static void copy(Reader input, OutputStream output, Charset encoding) throws IOException {
+        OutputStreamWriter out = new OutputStreamWriter(output, Charsets.toCharset(encoding));
+        copy(input, out);
+        // XXX Unless anyone is planning on rewriting OutputStreamWriter,
+        // we have to flush here.
+        out.flush();
+    }
+
+    /**
+     * Copy chars from a <code>Reader</code> to bytes on an
+     * <code>OutputStream</code> using the specified character encoding, and
+     * calling flush.
+     * <p/>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p/>
+     * Character encoding names can be found at
+     * <a href="http://www.iana.org/assignments/character-sets">IANA</a>.
+     * <p/>
+     * Due to the implementation of OutputStreamWriter, this method performs a
+     * flush.
+     * <p/>
+     * This method uses {@link OutputStreamWriter}.
+     *
+     * @param input    the <code>Reader</code> to read from
+     * @param output   the <code>OutputStream</code> to write to
+     * @param encoding the encoding to use, null means platform default
+     * @throws NullPointerException                         if the input or output is null
+     * @throws IOException                          if an I/O error occurs
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static void copy(Reader input, OutputStream output, String encoding) throws IOException {
+        copy(input, output, Charsets.toCharset(encoding));
+    }
+
+    // content equals
+    //-----------------------------------------------------------------------
+
+    /**
+     * Compare the contents of two Streams to determine if they are equal or
+     * not.
+     * <p/>
+     * This method buffers the input internally using
+     * <code>BufferedInputStream</code> if they are not already buffered.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException  if an I/O error occurs
+     */
+    public static boolean contentEquals(InputStream input1, InputStream input2)
+            throws IOException {
+        if (!(input1 instanceof BufferedInputStream)) {
+            input1 = new BufferedInputStream(input1);
+        }
+        if (!(input2 instanceof BufferedInputStream)) {
+            input2 = new BufferedInputStream(input2);
+        }
+
+        int ch = input1.read();
+        while (EOF != ch) {
+            int ch2 = input2.read();
+            if (ch != ch2) {
+                return false;
+            }
+            ch = input1.read();
+        }
+
+        int ch2 = input2.read();
+        return ch2 == EOF;
+    }
+
+    /**
+     * Compare the contents of two Readers to determine if they are equal or
+     * not.
+     * <p/>
+     * This method buffers the input internally using
+     * <code>BufferedReader</code> if they are not already buffered.
+     *
+     * @param input1 the first reader
+     * @param input2 the second reader
+     * @return true if the content of the readers are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 1.1
+     */
+    public static boolean contentEquals(Reader input1, Reader input2)
+            throws IOException {
+
+        input1 = toBufferedReader(input1);
+        input2 = toBufferedReader(input2);
+
+        int ch = input1.read();
+        while (EOF != ch) {
+            int ch2 = input2.read();
+            if (ch != ch2) {
+                return false;
+            }
+            ch = input1.read();
+        }
+
+        int ch2 = input2.read();
+        return ch2 == EOF;
+    }
+
+    /**
+     * Compare the contents of two Readers to determine if they are equal or
+     * not, ignoring EOL characters.
+     * <p/>
+     * This method buffers the input internally using
+     * <code>BufferedReader</code> if they are not already buffered.
+     *
+     * @param input1 the first reader
+     * @param input2 the second reader
+     * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.2
+     */
+    public static boolean contentEqualsIgnoreEOL(Reader input1, Reader input2)
+            throws IOException {
+        BufferedReader br1 = toBufferedReader(input1);
+        BufferedReader br2 = toBufferedReader(input2);
+
+        String line1 = br1.readLine();
+        String line2 = br2.readLine();
+        while (line1 != null && line2 != null && line1.equals(line2)) {
+            line1 = br1.readLine();
+            line2 = br2.readLine();
+        }
+        return line1 == null ? line2 == null ? true : false : line1.equals(line2);
+    }
+
+    /**
+     * Skip bytes from an input byte stream.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link Reader}.
+     *
+     * @param input  byte stream to skip
+     * @param toSkip number of bytes to skip.
+     * @return number of bytes actually skipped.
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @see InputStream#skip(long)
+     * @since 2.0
+     */
+    public static long skip(InputStream input, long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);
+        }
+        /*
+         * N.B. no need to synchronize this because: - we don't care if the buffer is created multiple times (the data
+         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer
+         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)
+         */
+        if (SKIP_BYTE_BUFFER == null) {
+            SKIP_BYTE_BUFFER = new byte[SKIP_BUFFER_SIZE];
+        }
+        long remain = toSkip;
+        while (remain > 0) {
+            long n = input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));
+            if (n < 0) { // EOF
+                break;
+            }
+            remain -= n;
+        }
+        return toSkip - remain;
+    }
+
+    /**
+     * Skip characters from an input character stream.
+     * This implementation guarantees that it will read as many characters
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link Reader}.
+     *
+     * @param input  character stream to skip
+     * @param toSkip number of characters to skip.
+     * @return number of characters actually skipped.
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @see Reader#skip(long)
+     * @since 2.0
+     */
+    public static long skip(Reader input, long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Skip count must be non-negative, actual: " + toSkip);
+        }
+        /*
+         * N.B. no need to synchronize this because: - we don't care if the buffer is created multiple times (the data
+         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer
+         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)
+         */
+        if (SKIP_CHAR_BUFFER == null) {
+            SKIP_CHAR_BUFFER = new char[SKIP_BUFFER_SIZE];
+        }
+        long remain = toSkip;
+        while (remain > 0) {
+            long n = input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));
+            if (n < 0) { // EOF
+                break;
+            }
+            remain -= n;
+        }
+        return toSkip - remain;
+    }
+
+    /**
+     * Skip the requested number of bytes or fail if there are not enough left.
+     * <p/>
+     * This allows for the possibility that {@link InputStream#skip(long)} may
+     * not skip as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  stream to skip
+     * @param toSkip the number of bytes to skip
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @throws EOFException     if the number of bytes skipped was incorrect
+     * @see InputStream#skip(long)
+     * @since 2.0
+     */
+    public static void skipFully(InputStream input, long toSkip) throws IOException {
+        if (toSkip < 0) {
+            throw new IllegalArgumentException("Bytes to skip must not be negative: " + toSkip);
+        }
+        long skipped = skip(input, toSkip);
+        if (skipped != toSkip) {
+            throw new EOFException("Bytes to skip: " + toSkip + " actual: " + skipped);
+        }
+    }
+
+    /**
+     * Skip the requested number of characters or fail if there are not enough left.
+     * <p/>
+     * This allows for the possibility that {@link Reader#skip(long)} may
+     * not skip as many characters as requested (most likely because of reaching EOF).
+     *
+     * @param input  stream to skip
+     * @param toSkip the number of characters to skip
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if toSkip is negative
+     * @throws EOFException     if the number of characters skipped was incorrect
+     * @see Reader#skip(long)
+     * @since 2.0
+     */
+    public static void skipFully(Reader input, long toSkip) throws IOException {
+        long skipped = skip(input, toSkip);
+        if (skipped != toSkip) {
+            throw new EOFException("Chars to skip: " + toSkip + " actual: " + skipped);
+        }
+    }
+
+
+    /**
+     * Read characters from an input character stream.
+     * This implementation guarantees that it will read as many characters
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link Reader}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset inital offset into buffer
+     * @param length length to read, must be >= 0
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(Reader input, char[] buffer, int offset, int length) throws IOException {
+        if (length < 0) {
+            throw new IllegalArgumentException("Length must not be negative: " + length);
+        }
+        int remaining = length;
+        while (remaining > 0) {
+            int location = length - remaining;
+            int count = input.read(buffer, offset + location, remaining);
+            if (EOF == count) { // EOF
+                break;
+            }
+            remaining -= count;
+        }
+        return length - remaining;
+    }
+
+    /**
+     * Read characters from an input character stream.
+     * This implementation guarantees that it will read as many characters
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link Reader}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(Reader input, char[] buffer) throws IOException {
+        return read(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Read bytes from an input stream.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link InputStream}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset inital offset into buffer
+     * @param length length to read, must be >= 0
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(InputStream input, byte[] buffer, int offset, int length) throws IOException {
+        if (length < 0) {
+            throw new IllegalArgumentException("Length must not be negative: " + length);
+        }
+        int remaining = length;
+        while (remaining > 0) {
+            int location = length - remaining;
+            int count = input.read(buffer, offset + location, remaining);
+            if (EOF == count) { // EOF
+                break;
+            }
+            remaining -= count;
+        }
+        return length - remaining;
+    }
+
+    /**
+     * Read bytes from an input stream.
+     * This implementation guarantees that it will read as many bytes
+     * as possible before giving up; this may not always be the case for
+     * subclasses of {@link InputStream}.
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @return actual length read; may be less than requested if EOF was reached
+     * @throws IOException if a read error occurs
+     * @since 2.2
+     */
+    public static int read(InputStream input, byte[] buffer) throws IOException {
+        return read(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Read the requested number of characters or fail if there are not enough left.
+     * <p/>
+     * This allows for the possibility that {@link Reader#read(char[], int, int)} may
+     * not read as many characters as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset inital offset into buffer
+     * @param length length to read, must be >= 0
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException     if the number of characters read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(Reader input, char[] buffer, int offset, int length) throws IOException {
+        int actual = read(input, buffer, offset, length);
+        if (actual != length) {
+            throw new EOFException("Length to read: " + length + " actual: " + actual);
+        }
+    }
+
+    /**
+     * Read the requested number of characters or fail if there are not enough left.
+     * <p/>
+     * This allows for the possibility that {@link Reader#read(char[], int, int)} may
+     * not read as many characters as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException     if the number of characters read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(Reader input, char[] buffer) throws IOException {
+        readFully(input, buffer, 0, buffer.length);
+    }
+
+    /**
+     * Read the requested number of bytes or fail if there are not enough left.
+     * <p/>
+     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
+     * not read as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @param offset inital offset into buffer
+     * @param length length to read, must be >= 0
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException     if the number of bytes read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(InputStream input, byte[] buffer, int offset, int length) throws IOException {
+        int actual = read(input, buffer, offset, length);
+        if (actual != length) {
+            throw new EOFException("Length to read: " + length + " actual: " + actual);
+        }
+    }
+
+    /**
+     * Read the requested number of bytes or fail if there are not enough left.
+     * <p/>
+     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may
+     * not read as many bytes as requested (most likely because of reaching EOF).
+     *
+     * @param input  where to read input from
+     * @param buffer destination
+     * @throws IOException      if there is a problem reading the file
+     * @throws IllegalArgumentException if length is negative
+     * @throws EOFException     if the number of bytes read was incorrect
+     * @since 2.2
+     */
+    public static void readFully(InputStream input, byte[] buffer) throws IOException {
+        readFully(input, buffer, 0, buffer.length);
+    }
+}
Index: common/src/main/java/com/scene/common/common/io/stream/ClosedInputStream.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/stream/ClosedInputStream.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/stream/ClosedInputStream.java	(revision )
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io.stream;
+
+import java.io.InputStream;
+
+/**
+ * Closed input stream. This stream returns -1 to all attempts to read
+ * something from the stream.
+ * <p>
+ * Typically uses of this class include testing for corner cases in methods
+ * that accept input streams and acting as a sentinel value instead of a
+ * {@code null} input stream.
+ *
+ * @version $Id: ClosedInputStream.java 1307459 2012-03-30 15:11:44Z ggregory $
+ * @since 1.4
+ */
+public class ClosedInputStream extends InputStream {
+    
+    /**
+     * A singleton.
+     */
+    public static final ClosedInputStream CLOSED_INPUT_STREAM = new ClosedInputStream();
+
+    /**
+     * Returns -1 to indicate that the stream is closed.
+     *
+     * @return always -1
+     */
+    @Override
+    public int read() {
+        return -1;
+    }
+
+}
Index: mylib/src/androidTest/java/com/scene/mylib/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/androidTest/java/com/scene/mylib/ApplicationTest.java	(revision )
+++ mylib/src/androidTest/java/com/scene/mylib/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.scene.mylib;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/BitmapManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/BitmapManager.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/BitmapManager.java	(revision )
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.chooseimagelib.simplecropimage;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.util.Log;
+
+import java.io.FileDescriptor;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+/**
+ * This class provides several utilities to cancel bitmap decoding.
+ * <p/>
+ * The function decodeFileDescriptor() is used to decode a bitmap. During
+ * decoding if another thread wants to cancel it, it calls the function
+ * cancelThreadDecoding() specifying the Thread which is in decoding.
+ * <p/>
+ * cancelThreadDecoding() is sticky until allowThreadDecoding() is called.
+ * <p/>
+ * You can also cancel decoding for a set of threads using ThreadSet as
+ * the parameter for cancelThreadDecoding. To put a thread into a ThreadSet,
+ * use the add() method. A ThreadSet holds (weak) references to the threads,
+ * so you don't need to remove Thread from it if some thread dies.
+ */
+public class BitmapManager {
+
+    private static final String TAG = "BitmapManager";
+
+    private static enum State {CANCEL, ALLOW}
+
+    private static class ThreadStatus {
+
+        public State mState = State.ALLOW;
+        public BitmapFactory.Options mOptions;
+
+        @Override
+        public String toString() {
+
+            String s;
+            if (mState == State.CANCEL) {
+                s = "Cancel";
+            } else if (mState == State.ALLOW) {
+                s = "Allow";
+            } else {
+                s = "?";
+            }
+            s = "thread state = " + s + ", options = " + mOptions;
+            return s;
+        }
+    }
+
+    public static class ThreadSet implements Iterable<Thread> {
+
+        private final WeakHashMap<Thread, Object> mWeakCollection =
+                new WeakHashMap<Thread, Object>();
+
+        public void add(Thread t) {
+
+            mWeakCollection.put(t, null);
+        }
+
+        public void remove(Thread t) {
+
+            mWeakCollection.remove(t);
+        }
+
+        public Iterator<Thread> iterator() {
+
+            return mWeakCollection.keySet().iterator();
+        }
+    }
+
+    private final WeakHashMap<Thread, ThreadStatus> mThreadStatus =
+            new WeakHashMap<Thread, ThreadStatus>();
+
+    private static BitmapManager sManager = null;
+
+    private BitmapManager() {
+
+    }
+
+    /**
+     * Get thread status and create one if specified.
+     */
+    private synchronized ThreadStatus getOrCreateThreadStatus(Thread t) {
+
+        ThreadStatus status = mThreadStatus.get(t);
+        if (status == null) {
+            status = new ThreadStatus();
+            mThreadStatus.put(t, status);
+        }
+        return status;
+    }
+
+    /**
+     * The following three methods are used to keep track of
+     * BitmapFaction.Options used for decoding and cancelling.
+     */
+    private synchronized void setDecodingOptions(Thread t,
+                                                 BitmapFactory.Options options) {
+
+        getOrCreateThreadStatus(t).mOptions = options;
+    }
+
+    synchronized BitmapFactory.Options getDecodingOptions(Thread t) {
+
+        ThreadStatus status = mThreadStatus.get(t);
+        return status != null ? status.mOptions : null;
+    }
+
+    synchronized void removeDecodingOptions(Thread t) {
+
+        ThreadStatus status = mThreadStatus.get(t);
+        status.mOptions = null;
+    }
+
+    /**
+     * The following two methods are used to allow/cancel a set of threads
+     * for bitmap decoding.
+     */
+    public synchronized void allowThreadDecoding(ThreadSet threads) {
+
+        for (Thread t : threads) {
+            allowThreadDecoding(t);
+        }
+    }
+
+    public synchronized void cancelThreadDecoding(ThreadSet threads) {
+
+        for (Thread t : threads) {
+            cancelThreadDecoding(t);
+        }
+    }
+
+    /**
+     * The following three methods are used to keep track of which thread
+     * is being disabled for bitmap decoding.
+     */
+    public synchronized boolean canThreadDecoding(Thread t) {
+
+        ThreadStatus status = mThreadStatus.get(t);
+        if (status == null) {
+            // allow decoding by default
+            return true;
+        }
+
+        return (status.mState != State.CANCEL);
+    }
+
+    public synchronized void allowThreadDecoding(Thread t) {
+
+        getOrCreateThreadStatus(t).mState = State.ALLOW;
+    }
+
+    public synchronized void cancelThreadDecoding(Thread t) {
+
+        ThreadStatus status = getOrCreateThreadStatus(t);
+        status.mState = State.CANCEL;
+        if (status.mOptions != null) {
+            status.mOptions.requestCancelDecode();
+        }
+
+        // Wake up threads in waiting list
+        notifyAll();
+    }
+
+    /**
+     * A debugging routine.
+     */
+    public synchronized void dump() {
+
+        Iterator<Map.Entry<Thread, ThreadStatus>> i =
+                mThreadStatus.entrySet().iterator();
+
+        while (i.hasNext()) {
+            Map.Entry<Thread, ThreadStatus> entry = i.next();
+            Log.v(TAG, "[Dump] Thread " + entry.getKey() + " ("
+                    + entry.getKey().getId()
+                    + ")'s status is " + entry.getValue());
+        }
+    }
+
+    public static synchronized BitmapManager instance() {
+
+        if (sManager == null) {
+            sManager = new BitmapManager();
+        }
+        return sManager;
+    }
+
+    /**
+     * The real place to delegate bitmap decoding to BitmapFactory.
+     */
+    public Bitmap decodeFileDescriptor(FileDescriptor fd,
+                                       BitmapFactory.Options options) {
+
+        if (options.mCancel) {
+            return null;
+        }
+
+        Thread thread = Thread.currentThread();
+        if (!canThreadDecoding(thread)) {
+            // Log.d(TAG, "Thread " + thread + " is not allowed to decode.");
+            return null;
+        }
+
+        setDecodingOptions(thread, options);
+        Bitmap b = BitmapFactory.decodeFileDescriptor(fd, null, options);
+
+        removeDecodingOptions(thread);
+        return b;
+    }
+}
Index: customfresco/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/build.gradle	(revision )
+++ customfresco/build.gradle	(revision )
@@ -0,0 +1,28 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+
+    //图片处理库
+    compile 'com.facebook.fresco:fresco:0.9.0'
+}
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/interfaces/SwipeAdapterInterface.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/interfaces/SwipeAdapterInterface.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/interfaces/SwipeAdapterInterface.java	(revision )
@@ -0,0 +1,9 @@
+package com.scene.mylib.view.swipelayout.interfaces;
+
+public interface SwipeAdapterInterface {
+
+    int getSwipeLayoutResourceId(int position);
+
+    void notifyDatasetChanged();
+
+}
Index: common/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/proguard-rules.pro	(revision )
+++ common/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\Devolopment\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: mylib/src/main/res/values/ids.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/values/ids.xml	(revision )
+++ mylib/src/main/res/values/ids.xml	(revision )
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <item type="id" name="tag_position"></item>
+    <item type="id" name="id_tab_txt">888</item>
+</resources>
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/HeaderAndFooterRecyclerViewAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/HeaderAndFooterRecyclerViewAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/HeaderAndFooterRecyclerViewAdapter.java	(revision )
@@ -0,0 +1,210 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.StaggeredGridLayoutManager;
+import android.view.View;
+import android.view.ViewGroup;
+
+import java.util.ArrayList;
+
+/**
+ * Created by scene on 2015/10/9.
+ * <p/>
+ * RecyclerView.Adapter with Header and Footer
+ */
+public class HeaderAndFooterRecyclerViewAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
+
+    private static final int TYPE_HEADER_VIEW = Integer.MIN_VALUE;
+    private static final int TYPE_FOOTER_VIEW = Integer.MIN_VALUE + 1;
+
+    /**
+     * RecyclerView使用的，真正的Adapter
+     */
+    private RecyclerView.Adapter<RecyclerView.ViewHolder> mInnerAdapter;
+
+    private ArrayList<View> mHeaderViews = new ArrayList<>();
+    private ArrayList<View> mFooterViews = new ArrayList<>();
+
+    private RecyclerView.AdapterDataObserver mDataObserver = new RecyclerView.AdapterDataObserver() {
+
+        @Override
+        public void onChanged() {
+            super.onChanged();
+            notifyDataSetChanged();
+        }
+
+        @Override
+        public void onItemRangeChanged(int positionStart, int itemCount) {
+            super.onItemRangeChanged(positionStart, itemCount);
+            notifyItemRangeChanged(positionStart + getHeaderViewsCount(), itemCount);
+        }
+
+        @Override
+        public void onItemRangeInserted(int positionStart, int itemCount) {
+            super.onItemRangeInserted(positionStart, itemCount);
+            notifyItemRangeInserted(positionStart + getHeaderViewsCount(), itemCount);
+        }
+
+        @Override
+        public void onItemRangeRemoved(int positionStart, int itemCount) {
+            super.onItemRangeRemoved(positionStart, itemCount);
+            notifyItemRangeRemoved(positionStart + getHeaderViewsCount(), itemCount);
+        }
+
+        @Override
+        public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {
+            super.onItemRangeMoved(fromPosition, toPosition, itemCount);
+            int headerViewsCountCount = getHeaderViewsCount();
+            notifyItemRangeChanged(fromPosition + headerViewsCountCount, toPosition + headerViewsCountCount + itemCount);
+        }
+    };
+
+    public HeaderAndFooterRecyclerViewAdapter() {
+    }
+
+    public HeaderAndFooterRecyclerViewAdapter(RecyclerView.Adapter innerAdapter) {
+        setAdapter(innerAdapter);
+    }
+
+    /**
+     * 设置adapter
+     * @param adapter
+     */
+    public void setAdapter(RecyclerView.Adapter<RecyclerView.ViewHolder> adapter) {
+
+        if (adapter != null) {
+            if (!(adapter instanceof RecyclerView.Adapter))
+                throw new RuntimeException("your adapter must be a RecyclerView.Adapter");
+        }
+
+        if (mInnerAdapter != null) {
+            notifyItemRangeRemoved(getHeaderViewsCount(), mInnerAdapter.getItemCount());
+            mInnerAdapter.unregisterAdapterDataObserver(mDataObserver);
+        }
+
+        this.mInnerAdapter = adapter;
+        mInnerAdapter.registerAdapterDataObserver(mDataObserver);
+        notifyItemRangeInserted(getHeaderViewsCount(), mInnerAdapter.getItemCount());
+    }
+
+    public RecyclerView.Adapter getInnerAdapter() {
+        return mInnerAdapter;
+    }
+
+    public void addHeaderView(View header) {
+
+        if (header == null) {
+            throw new RuntimeException("header is null");
+        }
+
+        mHeaderViews.add(header);
+        this.notifyDataSetChanged();
+    }
+
+    public void addFooterView(View footer) {
+
+        if (footer == null) {
+            throw new RuntimeException("footer is null");
+        }
+
+        mFooterViews.add(footer);
+        this.notifyDataSetChanged();
+    }
+
+    /**
+     * 返回第一个FoView
+     * @return
+     */
+    public View getFooterView() {
+        return  getFooterViewsCount()>0 ? mFooterViews.get(0) : null;
+    }
+
+    /**
+     * 返回第一个HeaderView
+     * @return
+     */
+    public View getHeaderView() {
+        return  getHeaderViewsCount()>0 ? mHeaderViews.get(0) : null;
+    }
+
+    public void removeHeaderView(View view) {
+        mHeaderViews.remove(view);
+        this.notifyDataSetChanged();
+    }
+
+    public void removeFooterView(View view) {
+        mFooterViews.remove(view);
+        this.notifyDataSetChanged();
+    }
+
+    public int getHeaderViewsCount() {
+        return mHeaderViews.size();
+    }
+
+    public int getFooterViewsCount() {
+        return mFooterViews.size();
+    }
+
+    public boolean isHeader(int position) {
+        return getHeaderViewsCount() > 0 && position == 0;
+    }
+
+    public boolean isFooter(int position) {
+        int lastPosition = getItemCount() - 1;
+        return getFooterViewsCount() > 0 && position == lastPosition;
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        int headerViewsCountCount = getHeaderViewsCount();
+        if (viewType < TYPE_HEADER_VIEW + headerViewsCountCount) {
+            return new ViewHolder(mHeaderViews.get(viewType - TYPE_HEADER_VIEW));
+        } else if (viewType >= TYPE_FOOTER_VIEW && viewType < Integer.MAX_VALUE / 2) {
+            return new ViewHolder(mFooterViews.get(viewType - TYPE_FOOTER_VIEW));
+        } else {
+            return mInnerAdapter.onCreateViewHolder(parent, viewType - Integer.MAX_VALUE / 2);
+        }
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+        int headerViewsCountCount = getHeaderViewsCount();
+        if (position >= headerViewsCountCount && position < headerViewsCountCount + mInnerAdapter.getItemCount()) {
+            mInnerAdapter.onBindViewHolder(holder, position - headerViewsCountCount);
+        } else {
+            ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
+            if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams) {
+                ((StaggeredGridLayoutManager.LayoutParams) layoutParams).setFullSpan(true);
+            }
+        }
+    }
+
+    @Override
+    public int getItemCount() {
+        return getHeaderViewsCount() + getFooterViewsCount() + mInnerAdapter.getItemCount();
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        int innerCount = mInnerAdapter.getItemCount();
+        int headerViewsCountCount = getHeaderViewsCount();
+        if (position < headerViewsCountCount) {
+            return TYPE_HEADER_VIEW + position;
+        } else if (headerViewsCountCount <= position && position < headerViewsCountCount + innerCount) {
+
+            int innerItemViewType = mInnerAdapter.getItemViewType(position - headerViewsCountCount);
+            if(innerItemViewType >= Integer.MAX_VALUE / 2) {
+                throw new IllegalArgumentException("your adapter's return value of getViewTypeCount() must < Integer.MAX_VALUE / 2");
+            }
+            return innerItemViewType + Integer.MAX_VALUE / 2;
+        } else {
+            return TYPE_FOOTER_VIEW + position - headerViewsCountCount - innerCount;
+        }
+    }
+
+    public static class ViewHolder extends RecyclerView.ViewHolder {
+        public ViewHolder(View itemView) {
+            super(itemView);
+        }
+    }
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/viewholder/TimeLineViewHolder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/viewholder/TimeLineViewHolder.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/viewholder/TimeLineViewHolder.java	(revision )
@@ -0,0 +1,28 @@
+package com.scene.sceneandroiddemo.viewholder;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.widget.TextView;
+
+import com.scene.sceneandroiddemo.R;
+import com.scene.timeline.TimelineView;
+
+import butterknife.Bind;
+import butterknife.ButterKnife;
+
+/**
+ * Created by scene on 16/02/25.
+ */
+public class TimeLineViewHolder extends RecyclerView.ViewHolder {
+
+    @Bind(R.id.time_marker)
+    public TimelineView time_marker;
+    @Bind(R.id.tx_name)
+    public TextView name;
+
+    public TimeLineViewHolder(View itemView, int timeLineType) {
+        super(itemView);
+        ButterKnife.bind(this, itemView);
+        time_marker.initLine(timeLineType);
+    }
+}
Index: chooseimagelib/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/res/values/colors.xml	(revision )
+++ chooseimagelib/src/main/res/values/colors.xml	(revision )
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+</resources>
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/RecyclerViewUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/RecyclerViewUtils.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/RecyclerViewUtils.java	(revision )
@@ -0,0 +1,128 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+
+/**
+ * Created by scene on 2015/10/22.
+ * <p/>
+ * RecyclerView设置Header/Footer所用到的工具类
+ */
+public class RecyclerViewUtils  {
+
+    /**
+     * 设置HeaderView
+     *
+     * @param recyclerView
+     * @param view
+     */
+    public static void setHeaderView(RecyclerView recyclerView, View view) {
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+
+        if (outerAdapter == null || !(outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter)) {
+            return;
+        }
+
+        HeaderAndFooterRecyclerViewAdapter headerAndFooterAdapter = (HeaderAndFooterRecyclerViewAdapter) outerAdapter;
+        if (headerAndFooterAdapter.getHeaderViewsCount() == 0) {
+            headerAndFooterAdapter.addHeaderView(view);
+        }
+    }
+
+    /**
+     * 设置FooterView
+     *
+     * @param recyclerView
+     * @param view
+     */
+    public static void setFooterView(RecyclerView recyclerView, View view) {
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+
+        if (outerAdapter == null || !(outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter)) {
+            return;
+        }
+
+        HeaderAndFooterRecyclerViewAdapter headerAndFooterAdapter = (HeaderAndFooterRecyclerViewAdapter) outerAdapter;
+        if (headerAndFooterAdapter.getFooterViewsCount() == 0) {
+            headerAndFooterAdapter.addFooterView(view);
+        }
+    }
+
+    /**
+     * 移除FooterView
+     *
+     * @param recyclerView
+     */
+    public static void removeFooterView(RecyclerView recyclerView) {
+
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+
+        if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter) {
+
+            int footerViewCounter = ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getFooterViewsCount();
+            if (footerViewCounter > 0) {
+                View footerView = ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getFooterView();
+                ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).removeFooterView(footerView);
+            }
+        }
+    }
+
+    /**
+     * 移除HeaderView
+     *
+     * @param recyclerView
+     */
+    public static void removeHeaderView(RecyclerView recyclerView) {
+
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+
+        if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter) {
+
+            int headerViewCounter = ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getHeaderViewsCount();
+            if (headerViewCounter > 0) {
+                View headerView = ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getHeaderView();
+                ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).removeFooterView(headerView);
+            }
+        }
+    }
+
+    /**
+     * 请使用本方法替代RecyclerView.ViewHolder的getLayoutPosition()方法
+     *
+     * @param recyclerView
+     * @param holder
+     * @return
+     */
+    public static int getLayoutPosition(RecyclerView recyclerView, RecyclerView.ViewHolder holder) {
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+        if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter) {
+
+            int headerViewCounter = ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getHeaderViewsCount();
+            if (headerViewCounter > 0) {
+                return holder.getLayoutPosition() - headerViewCounter;
+            }
+        }
+
+        return holder.getLayoutPosition();
+    }
+
+    /**
+     * 请使用本方法替代RecyclerView.ViewHolder的getAdapterPosition()方法
+     *
+     * @param recyclerView
+     * @param holder
+     * @return
+     */
+    public static int getAdapterPosition(RecyclerView recyclerView, RecyclerView.ViewHolder holder) {
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+        if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter) {
+
+            int headerViewCounter = ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getHeaderViewsCount();
+            if (headerViewCounter > 0) {
+                return holder.getAdapterPosition() - headerViewCounter;
+            }
+        }
+
+        return holder.getAdapterPosition();
+    }
+}
\ No newline at end of file
Index: app/src/main/res/layout/fragment3.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/fragment3.xml	(revision )
+++ app/src/main/res/layout/fragment3.xml	(revision )
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:fresco="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <com.scene.customfresco.FrescoImageView
+        android:id="@+id/img"
+        android:layout_width="200dp"
+        android:layout_height="200dp"
+        fresco:actualImageScaleType="fitCenter"
+        fresco:roundingBorderColor="#ff0000"
+        fresco:roundingBorderWidth="3dp" />
+
+    <com.scene.customfresco.FrescoZoomImageView
+        android:id="@+id/img2"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+</LinearLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/assist/Averager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/Averager.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/Averager.java	(revision )
@@ -0,0 +1,71 @@
+package com.scene.common.common.assist;
+
+
+import com.scene.common.android.log.Log;
+
+import java.util.ArrayList;
+
+/**
+ * 用以统计平均数
+ *
+ * @author MaTianyu
+ *         2013-12-11下午3:31:03
+ */
+public class Averager {
+    private static final String            TAG     = "Averager";
+    private              ArrayList<Number> numList = new ArrayList<Number>();
+
+    /**
+     * 添加一个数字
+     *
+     * @param num
+     */
+    public synchronized void add(Number num) {
+        numList.add(num);
+    }
+
+    /**
+     * 清除全部
+     */
+    public void clear() {
+        numList.clear();
+    }
+
+    /**
+     * 返回参与均值计算的数字个数
+     *
+     * @return
+     */
+    public Number size() {
+        return numList.size();
+    }
+
+    /**
+     * 获取平均数
+     *
+     * @return
+     */
+    public Number getAverage() {
+        if (numList.size() == 0) {
+            return 0;
+        } else {
+            Float sum = 0f;
+            for (int i = 0, size = numList.size(); i < size; i++) {
+                sum = sum.floatValue() + numList.get(i).floatValue();
+            }
+            return sum / numList.size();
+        }
+    }
+
+    /**
+     * 打印数字列
+     *
+     * @return
+     */
+    public String print() {
+        String str = "PrintList(" + size() + "): " + numList;
+        Log.i(TAG, str);
+        return str;
+    }
+
+}
Index: mylib/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/values/strings.xml	(revision )
+++ mylib/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,6 @@
+<resources>
+    <!--footer-->
+    <string name="list_footer_loading">正在加载中…</string>
+    <string name="list_footer_network_error">点击重新加载</string>
+    <string name="list_footer_end">已经到底了</string>
+</resources>
Index: ucrop/src/main/res/layout/ucrop_layout_rotate_wheel.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/layout/ucrop_layout_rotate_wheel.xml	(revision )
+++ ucrop/src/main/res/layout/ucrop_layout_rotate_wheel.xml	(revision )
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:visibility="gone"
+                tools:showIn="@layout/ucrop_activity_photobox"
+                tools:visibility="visible">
+
+    <TextView
+        android:id="@+id/text_view_rotate"
+        android:layout_width="100dp"
+        android:layout_height="wrap_content"
+        android:layout_centerHorizontal="true"
+        android:layout_marginTop="10dp"
+        android:gravity="center"
+        android:textColor="@android:color/black"
+        android:textSize="13sp"
+        tools:text="100°"/>
+
+    <com.yalantis.ucrop.view.widget.HorizontalProgressWheelView
+        android:id="@+id/rotate_scroll_wheel"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_toRightOf="@+id/wrapper_reset_rotate"
+        android:layout_toEndOf="@+id/wrapper_reset_rotate"
+        android:layout_toLeftOf="@+id/wrapper_rotate_by_angle"
+        android:layout_toStartOf="@+id/wrapper_rotate_by_angle"
+        android:layout_below="@+id/text_view_rotate"/>
+
+    <FrameLayout
+        android:id="@+id/wrapper_reset_rotate"
+        style="@style/ucrop_WrapperRotateButton"
+        android:layout_centerVertical="true">
+
+        <ImageView
+            style="@style/ucrop_ImageViewWidgetIcon"
+            android:src="@drawable/ucrop_ic_reset"/>
+
+    </FrameLayout>
+
+    <FrameLayout
+        android:id="@+id/wrapper_rotate_by_angle"
+        style="@style/ucrop_WrapperRotateButton"
+        android:layout_alignParentEnd="true"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true">
+
+        <ImageView
+            style="@style/ucrop_ImageViewWidgetIcon"
+            android:src="@drawable/ucrop_ic_angle"/>
+
+    </FrameLayout>
+
+</RelativeLayout>
\ No newline at end of file
Index: app/src/main/res/layout/item_time_line.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/item_time_line.xml	(revision )
+++ app/src/main/res/layout/item_time_line.xml	(revision )
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="horizontal">
+
+    <com.scene.timeline.TimelineView
+        android:id="@+id/time_marker"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:paddingBottom="30dp"
+        android:paddingLeft="10dp"
+        android:paddingRight="10dp"
+        android:paddingTop="30dp"
+        app:line="@color/colorPrimary"
+        app:line_size="2dp"
+        app:marker_size="25dp" />
+
+    <android.support.v7.widget.CardView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_vertical">
+
+        <TextView
+            android:id="@+id/tx_name"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:layout_gravity="center_vertical"
+            android:textColor="@android:color/tertiary_text_dark"
+            android:layout_marginLeft="20dp"
+            android:text="Random" />
+    </android.support.v7.widget.CardView>
+
+</LinearLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/BitmapUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/BitmapUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/BitmapUtil.java	(revision )
@@ -0,0 +1,242 @@
+package com.scene.common.common.utils;
+
+import android.content.Intent;
+import android.graphics.*;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Build;
+import android.provider.MediaStore;
+import com.scene.common.android.log.Log;
+import com.scene.common.common.assist.Base64;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+
+public class BitmapUtil {
+
+    private static final String TAG = BitmapUtil.class.getSimpleName();
+
+    /**
+     * convert Bitmap to byte array
+     */
+    public static byte[] bitmapToByte(Bitmap b) {
+        ByteArrayOutputStream o = new ByteArrayOutputStream();
+        b.compress(Bitmap.CompressFormat.PNG, 100, o);
+        return o.toByteArray();
+    }
+
+    /**
+     * convert byte array to Bitmap
+     */
+    public static Bitmap byteToBitmap(byte[] b) {
+        return (b == null || b.length == 0) ? null : BitmapFactory.decodeByteArray(b, 0, b.length);
+    }
+
+    /**
+     * 把bitmap转换成Base64编码String
+     */
+    public static String bitmapToString(Bitmap bitmap) {
+        return Base64.encodeToString(bitmapToByte(bitmap), Base64.DEFAULT);
+    }
+
+    /**
+     * convert Drawable to Bitmap
+     */
+    public static Bitmap drawableToBitmap(Drawable drawable) {
+        return drawable == null ? null : ((BitmapDrawable) drawable).getBitmap();
+    }
+
+    /**
+     * convert Bitmap to Drawable
+     */
+    public static Drawable bitmapToDrawable(Bitmap bitmap) {
+        return bitmap == null ? null : new BitmapDrawable(bitmap);
+    }
+
+    /**
+     * scale image
+     */
+    public static Bitmap scaleImageTo(Bitmap org, int newWidth, int newHeight) {
+        return scaleImage(org, (float) newWidth / org.getWidth(), (float) newHeight / org.getHeight());
+    }
+
+    /**
+     * scale image
+     */
+    public static Bitmap scaleImage(Bitmap org, float scaleWidth, float scaleHeight) {
+        if (org == null) {
+            return null;
+        }
+        Matrix matrix = new Matrix();
+        matrix.postScale(scaleWidth, scaleHeight);
+        return Bitmap.createBitmap(org, 0, 0, org.getWidth(), org.getHeight(), matrix, true);
+    }
+
+    public static Bitmap toRoundCorner(Bitmap bitmap) {
+        int height = bitmap.getHeight();
+        int width = bitmap.getHeight();
+        Bitmap output = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+
+        Canvas canvas = new Canvas(output);
+
+        final Paint paint = new Paint();
+        final Rect rect = new Rect(0, 0, width, height);
+
+        paint.setAntiAlias(true);
+        canvas.drawARGB(0, 0, 0, 0);
+        //paint.setColor(0xff424242);
+        paint.setColor(Color.TRANSPARENT);
+        canvas.drawCircle(width / 2, height / 2, width / 2, paint);
+        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
+        canvas.drawBitmap(bitmap, rect, rect, paint);
+        return output;
+    }
+
+    public static Bitmap createBitmapThumbnail(Bitmap bitMap, boolean needRecycle, int newHeight, int newWidth) {
+        int width = bitMap.getWidth();
+        int height = bitMap.getHeight();
+        // 计算缩放比例
+        float scaleWidth = ((float) newWidth) / width;
+        float scaleHeight = ((float) newHeight) / height;
+        // 取得想要缩放的matrix参数
+        Matrix matrix = new Matrix();
+        matrix.postScale(scaleWidth, scaleHeight);
+        // 得到新的图片
+        Bitmap newBitMap = Bitmap.createBitmap(bitMap, 0, 0, width, height, matrix, true);
+        if (needRecycle)
+            bitMap.recycle();
+        return newBitMap;
+    }
+
+    public static boolean saveBitmap(Bitmap bitmap, File file) {
+        if (bitmap == null)
+            return false;
+        FileOutputStream fos = null;
+        try {
+            fos = new FileOutputStream(file);
+            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);
+            fos.flush();
+            return true;
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return false;
+    }
+
+    public static boolean saveBitmap(Bitmap bitmap, String absPath) {
+        return saveBitmap(bitmap, new File(absPath));
+    }
+
+    public static Intent buildImageGetIntent(Uri saveTo, int outputX, int outputY, boolean returnData) {
+        return buildImageGetIntent(saveTo, 1, 1, outputX, outputY, returnData);
+    }
+
+    public static Intent buildImageGetIntent(Uri saveTo, int aspectX, int aspectY,
+                                             int outputX, int outputY, boolean returnData) {
+        Log.i(TAG, "Build.VERSION.SDK_INT : " + Build.VERSION.SDK_INT);
+        Intent intent = new Intent();
+        if (Build.VERSION.SDK_INT < 19) {
+            intent.setAction(Intent.ACTION_GET_CONTENT);
+        } else {
+            intent.setAction(Intent.ACTION_OPEN_DOCUMENT);
+            intent.addCategory(Intent.CATEGORY_OPENABLE);
+        }
+        intent.setType("image/*");
+        intent.putExtra("output", saveTo);
+        intent.putExtra("aspectX", aspectX);
+        intent.putExtra("aspectY", aspectY);
+        intent.putExtra("outputX", outputX);
+        intent.putExtra("outputY", outputY);
+        intent.putExtra("scale", true);
+        intent.putExtra("return-data", returnData);
+        intent.putExtra("outputFormat", Bitmap.CompressFormat.PNG.toString());
+        return intent;
+    }
+
+    public static Intent buildImageCropIntent(Uri uriFrom, Uri uriTo, int outputX, int outputY, boolean returnData) {
+        return buildImageCropIntent(uriFrom, uriTo, 1, 1, outputX, outputY, returnData);
+    }
+
+    public static Intent buildImageCropIntent(Uri uriFrom, Uri uriTo, int aspectX, int aspectY,
+                                              int outputX, int outputY, boolean returnData) {
+        Intent intent = new Intent("com.android.camera.action.CROP");
+        intent.setDataAndType(uriFrom, "image/*");
+        intent.putExtra("crop", "true");
+        intent.putExtra("output", uriTo);
+        intent.putExtra("aspectX", aspectX);
+        intent.putExtra("aspectY", aspectY);
+        intent.putExtra("outputX", outputX);
+        intent.putExtra("outputY", outputY);
+        intent.putExtra("scale", true);
+        intent.putExtra("return-data", returnData);
+        intent.putExtra("outputFormat", Bitmap.CompressFormat.PNG.toString());
+        return intent;
+    }
+
+    public static Intent buildImageCaptureIntent(Uri uri) {
+        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
+        intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
+        return intent;
+    }
+
+    public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
+        int h = options.outHeight;
+        int w = options.outWidth;
+        int inSampleSize = 0;
+        if (h > reqHeight || w > reqWidth) {
+            float ratioW = (float) w / reqWidth;
+            float ratioH = (float) h / reqHeight;
+            inSampleSize = (int) Math.min(ratioH, ratioW);
+        }
+        inSampleSize = Math.max(1, inSampleSize);
+        return inSampleSize;
+    }
+
+    public static Bitmap getSmallBitmap(String filePath, int reqWidth, int reqHeight) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inJustDecodeBounds = true;
+        BitmapFactory.decodeFile(filePath, options);
+        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
+        options.inJustDecodeBounds = false;
+        return BitmapFactory.decodeFile(filePath, options);
+    }
+
+    public byte[] compressBitmapToBytes(String filePath, int reqWidth, int reqHeight, int quality) {
+        Bitmap bitmap = getSmallBitmap(filePath, reqWidth, reqHeight);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos);
+        byte[] bytes = baos.toByteArray();
+        bitmap.recycle();
+        Log.i(TAG, "Bitmap compressed success, size: " + bytes.length);
+        return bytes;
+    }
+
+    public byte[] compressBitmapSmallTo(String filePath, int reqWidth, int reqHeight, int maxLenth) {
+        int quality = 100;
+        byte[] bytes = compressBitmapToBytes(filePath, reqWidth, reqHeight, quality);
+        while (bytes.length > maxLenth && quality > 0) {
+            quality = quality / 2;
+            bytes = compressBitmapToBytes(filePath, reqWidth, reqHeight, quality);
+        }
+        return bytes;
+    }
+
+    public byte[] compressBitmapQuikly(String filePath) {
+        return compressBitmapToBytes(filePath, 480, 800, 50);
+    }
+
+    public byte[] compressBitmapQuiklySmallTo(String filePath, int maxLenth) {
+        return compressBitmapSmallTo(filePath, 480, 800, maxLenth);
+    }
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/util/FastBitmapDrawable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/util/FastBitmapDrawable.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/util/FastBitmapDrawable.java	(revision )
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.yalantis.ucrop.util;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+
+public class FastBitmapDrawable extends Drawable {
+
+    private final Paint mPaint = new Paint(Paint.FILTER_BITMAP_FLAG);
+
+    private Bitmap mBitmap;
+    private int mAlpha;
+    private int mWidth, mHeight;
+
+    public FastBitmapDrawable(Bitmap b) {
+        mAlpha = 255;
+        setBitmap(b);
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        if (mBitmap != null && !mBitmap.isRecycled()) {
+            final Rect r = getBounds();
+            canvas.drawBitmap(mBitmap, null, r, mPaint);
+        }
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mPaint.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+    public void setFilterBitmap(boolean filterBitmap) {
+        mPaint.setFilterBitmap(filterBitmap);
+    }
+
+    public int getAlpha() {
+        return mAlpha;
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mAlpha = alpha;
+        mPaint.setAlpha(alpha);
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return mWidth;
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return mHeight;
+    }
+
+    @Override
+    public int getMinimumWidth() {
+        return mWidth;
+    }
+
+    @Override
+    public int getMinimumHeight() {
+        return mHeight;
+    }
+
+    public Bitmap getBitmap() {
+        return mBitmap;
+    }
+
+    public void setBitmap(Bitmap b) {
+        mBitmap = b;
+        if (b != null) {
+            mWidth = mBitmap.getWidth();
+            mHeight = mBitmap.getHeight();
+        } else {
+            mWidth = mHeight = 0;
+        }
+    }
+
+}
Index: timeline/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/.gitignore	(revision )
+++ timeline/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: .idea/.name
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/.name	(revision )
+++ .idea/.name	(revision )
@@ -0,0 +1,1 @@
+SceneAndroidDemo
\ No newline at end of file
Index: easypermissions/src/main/java/pub/devrel/easypermissions/EasyPermissions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/src/main/java/pub/devrel/easypermissions/EasyPermissions.java	(revision )
+++ easypermissions/src/main/java/pub/devrel/easypermissions/EasyPermissions.java	(revision )
@@ -0,0 +1,206 @@
+/*
+ * Copyright Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package pub.devrel.easypermissions;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.pm.PackageManager;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
+import android.support.v7.app.AlertDialog;
+import android.util.Log;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Utility to request and check System permissions for apps targeting Android M (API >= 23).
+ * 以下权限需要运行时申请
+ * 身体传感器
+ * 日历
+ * 摄像头
+ * 通讯录
+ * 地理位置
+ * 麦克风
+ * 电话
+ * 短信
+ * 存储空间
+ */
+public class EasyPermissions {
+
+    private static final String TAG = "EasyPermissions";
+
+    public interface PermissionCallbacks extends ActivityCompat.OnRequestPermissionsResultCallback {
+
+        void onPermissionsGranted(List<String> perms);
+
+        void onPermissionsDenied(List<String> perms);
+
+    }
+
+    /**
+     * Check if the calling context has a set of permissions.
+     *
+     * @param context the calling context.
+     * @param perms   one ore more permissions, such as {@code android.Manifest.permission.CAMERA}.
+     * @return true if all permissions are already granted, false if at least one permission
+     * is not yet granted.
+     */
+    public static boolean hasPermissions(Context context, String... perms) {
+        for (String perm : perms) {
+            boolean hasPerm = (ContextCompat.checkSelfPermission(context, perm) == PackageManager.PERMISSION_GRANTED);
+            if (!hasPerm) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+
+    /**
+     * Request a set of permissions, showing rationale if the system requests it.
+     *
+     * @param activity    Activity requesting permissions. Should implement
+     *                    {@link android.support.v4.app.ActivityCompat.OnRequestPermissionsResultCallback}
+     * @param rationale   a message explaining why the application needs this set of permissions, will
+     *                    be displayed if the user rejects the request the first time.
+     * @param requestCode request code to track this request, must be < 256.
+     * @param perms       a set of permissions to be requested.
+     */
+    public static void requestPermissions(final Activity activity, String rationale,
+                                          final int requestCode, final String... perms) {
+        // Check if all permissions were already granted.
+        if (hasPermissions(activity.getApplicationContext(), perms)) {
+            return;
+        }
+
+        boolean shouldShowRationale = false;
+        for (String perm : perms) {
+            shouldShowRationale = shouldShowRationale ||
+                    ActivityCompat.shouldShowRequestPermissionRationale(activity, perm);
+        }
+
+        if (shouldShowRationale) {
+            AlertDialog dialog = new AlertDialog.Builder(activity)
+                    .setMessage(rationale)
+                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            executePermissionsRequest(activity, perms, requestCode);
+                        }
+                    })
+                    .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            // Do nothing, user does not want to request
+                        }
+                    }).create();
+            dialog.show();
+        } else {
+            executePermissionsRequest(activity, perms, requestCode);
+        }
+    }
+
+    /**
+     * Handle the result of a permission request, should be called from the calling Activity's
+     * {@link android.support.v4.app.ActivityCompat.OnRequestPermissionsResultCallback#onRequestPermissionsResult(int, String[], int[])}
+     * method.
+     * <p/>
+     * If any permissions were granted or denied, the Activity will receive the appropriate
+     * callbacks through {@link PermissionCallbacks} and methods annotated with
+     * {@link AfterPermissionGranted} will be run if appropriate.
+     *
+     * @param requestCode  requestCode argument to permission result callback.
+     * @param permissions  permissions argument to permission result callback.
+     * @param grantResults grantResults argument to permission result callback.
+     * @param activity     the calling Activity.
+     * @throws IllegalArgumentException if the calling Activity does not implement
+     *                                  {@link PermissionCallbacks}.
+     */
+    public static void onRequestPermissionsResult(int requestCode, String[] permissions,
+                                                  int[] grantResults, Activity activity) {
+
+        // Make sure Activity implements callbacks
+        if (!(activity instanceof PermissionCallbacks)) {
+            throw new IllegalArgumentException("Activity must implement PermissionCallbacks.");
+        }
+        PermissionCallbacks callbacks = (PermissionCallbacks) activity;
+
+        // Make a collection of granted and denied permissions from the request.
+        ArrayList<String> granted = new ArrayList<>();
+        ArrayList<String> denied = new ArrayList<>();
+        for (int i = 0; i < permissions.length; i++) {
+            String perm = permissions[i];
+            if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {
+                granted.add(perm);
+            } else {
+                denied.add(perm);
+            }
+        }
+
+        // Report granted permissions, if any.
+        if (!granted.isEmpty()) {
+            // Notify callbacks
+            callbacks.onPermissionsGranted(granted);
+        }
+
+        // Report denied permissions, if any.
+        if (!denied.isEmpty()) {
+            callbacks.onPermissionsDenied(denied);
+        }
+
+        // If 100% successful, call annotated methods
+        if (!granted.isEmpty() && denied.isEmpty()) {
+            runAnnotatedMethods(activity, requestCode);
+        }
+    }
+
+    private static void executePermissionsRequest(Activity activity, String[] perms, int requestCode) {
+        if (!(activity instanceof PermissionCallbacks)) {
+            throw new IllegalArgumentException("Activity must implement PermissionCallbacks.");
+        }
+
+        ActivityCompat.requestPermissions(activity, perms, requestCode);
+    }
+
+    private static void runAnnotatedMethods(Activity activity, int requestCode) {
+        Class clazz = activity.getClass();
+        for (Method method : clazz.getMethods()) {
+            if (method.isAnnotationPresent(AfterPermissionGranted.class)) {
+                // Check for annotated methods with matching request code.
+                AfterPermissionGranted ann = method.getAnnotation(AfterPermissionGranted.class);
+                if (ann.value() == requestCode) {
+                    // Method must be void so that we can invoke it
+                    if (method.getParameterTypes().length > 0) {
+                        throw new RuntimeException("Cannot execute non-void method " + method.getName());
+                    }
+
+                    try {
+                        method.invoke(activity);
+                    } catch (IllegalAccessException e) {
+                        Log.e(TAG, "runDefaultMethod:IllegalAccessException", e);
+                    } catch (InvocationTargetException e) {
+                        Log.e(TAG, "runDefaultMethod:InvocationTargetException", e);
+                    }
+                }
+            }
+        }
+    }
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/adapter/MainAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/adapter/MainAdapter.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/adapter/MainAdapter.java	(revision )
@@ -0,0 +1,60 @@
+package com.scene.sceneandroiddemo.adapter;
+
+import android.content.Context;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.scene.mylib.view.recyclerview.OnRecyclerViewItemClickListener;
+import com.scene.sceneandroiddemo.R;
+import com.scene.sceneandroiddemo.entity.TypeInfo;
+import com.scene.sceneandroiddemo.viewholder.MainViewHoder;
+
+import java.util.List;
+
+/**
+ * Created by scene on 16/01/26.
+ */
+public class MainAdapter extends RecyclerView.Adapter {
+    private LayoutInflater mLayoutInflater;
+
+    private Context mContext;
+    private List<TypeInfo> dataList;
+
+    private OnRecyclerViewItemClickListener listener;
+
+    public MainAdapter(Context mContext, List<TypeInfo> dataList) {
+        this.mContext = mContext;
+        this.dataList = dataList;
+        mLayoutInflater = LayoutInflater.from(mContext);
+    }
+
+    public void setListener(OnRecyclerViewItemClickListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        return new MainViewHoder(mLayoutInflater.inflate(R.layout.main_item, parent, false));
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, final int position) {
+        MainViewHoder viewHoder = (MainViewHoder) holder;
+        viewHoder.type.setText(dataList.get(position).getType());
+        viewHoder.itemView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (listener != null) {
+                    listener.onRecyclerViewItemClick(position);
+                }
+            }
+        });
+    }
+
+    @Override
+    public int getItemCount() {
+        return dataList != null ? dataList.size() : 0;
+    }
+}
Index: timeline/src/test/java/com/scene/timeline/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/test/java/com/scene/timeline/ExampleUnitTest.java	(revision )
+++ timeline/src/test/java/com/scene/timeline/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.scene.timeline;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: common/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/AndroidManifest.xml	(revision )
+++ common/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.scene.common">
+
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
Index: mylib/src/test/java/com/scene/mylib/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/test/java/com/scene/mylib/ExampleUnitTest.java	(revision )
+++ mylib/src/test/java/com/scene/mylib/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.scene.mylib;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: ucrop/src/main/java/com/yalantis/ucrop/util/BitmapLoadUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/util/BitmapLoadUtils.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/util/BitmapLoadUtils.java	(revision )
@@ -0,0 +1,126 @@
+package com.yalantis.ucrop.util;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
+import android.media.ExifInterface;
+import android.net.Uri;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import java.io.Closeable;
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ */
+public class BitmapLoadUtils {
+
+    private static final String TAG = "BitmapLoadUtils";
+
+    @Nullable
+    public static Bitmap decode(@NonNull Context context, @Nullable Uri uri,
+                                int requiredWidth, int requiredHeight) throws Exception {
+        if (uri == null) {
+            return null;
+        }
+
+        final ParcelFileDescriptor parcelFileDescriptor = context.getContentResolver().openFileDescriptor(uri, "r");
+        FileDescriptor fileDescriptor;
+        if (parcelFileDescriptor != null) {
+            fileDescriptor = parcelFileDescriptor.getFileDescriptor();
+        } else {
+            return null;
+        }
+
+        final BitmapFactory.Options options = new BitmapFactory.Options();
+
+        options.inJustDecodeBounds = true;
+        BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);
+        options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight);
+        options.inJustDecodeBounds = false;
+
+        Bitmap decodeSampledBitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            close(parcelFileDescriptor);
+        }
+
+        ExifInterface exif = getExif(uri);
+        if (exif != null) {
+            int exifOrientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
+            // TODO Should not rotate bitmap but initially apply needed angle to the matrix
+            return rotateBitmap(decodeSampledBitmap, exifToDegrees(exifOrientation));
+        } else {
+            return decodeSampledBitmap;
+        }
+    }
+
+    public static Bitmap rotateBitmap(@Nullable Bitmap bitmap, int degrees) {
+        if (bitmap != null && degrees != 0) {
+            Matrix rotateMatrix = new Matrix();
+            rotateMatrix.setRotate(degrees, bitmap.getWidth() / (float) 2, bitmap.getHeight() / (float) 2);
+
+            Bitmap converted = Bitmap.createBitmap(bitmap, 0, 0,
+                    bitmap.getWidth(), bitmap.getHeight(), rotateMatrix, true);
+            if (bitmap != converted) {
+                bitmap.recycle();
+                bitmap = converted;
+            }
+        }
+        return bitmap;
+    }
+
+    public static int calculateInSampleSize(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {
+        // Raw height and width of image
+        final int height = options.outHeight;
+        final int width = options.outWidth;
+        int inSampleSize = 1;
+
+        if (height > reqHeight || width > reqWidth) {
+            // Calculate the largest inSampleSize value that is a power of 2 and keeps both
+            // height and width lower or equal to the requested height and width.
+            while ((height / inSampleSize) > reqHeight || (width / inSampleSize) > reqWidth) {
+                inSampleSize *= 2;
+            }
+        }
+        return inSampleSize;
+    }
+
+    @Nullable
+    private static ExifInterface getExif(@NonNull Uri imageUri) {
+        try {
+            return new ExifInterface(imageUri.getPath());
+        } catch (IOException e) {
+            Log.w(TAG, "getExif: ", e);
+        }
+        return null;
+    }
+
+    private static int exifToDegrees(int exifOrientation) {
+        if (exifOrientation == ExifInterface.ORIENTATION_ROTATE_90) {
+            return 90;
+        } else if (exifOrientation == ExifInterface.ORIENTATION_ROTATE_180) {
+            return 180;
+        } else if (exifOrientation == ExifInterface.ORIENTATION_ROTATE_270) {
+            return 270;
+        }
+        return 0;
+    }
+
+    @SuppressWarnings("ConstantConditions")
+    public static void close(@Nullable Closeable c) {
+        if (c != null && c instanceof Closeable) { // java.lang.IncompatibleClassChangeError: interface not implemented
+            try {
+                c.close();
+            } catch (IOException e) {
+                // silence
+            }
+        }
+    }
+
+}
Index: common/src/main/java/com/scene/common/common/utils/MemoryUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/MemoryUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/MemoryUtil.java	(revision )
@@ -0,0 +1,112 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.os.Build;
+import android.text.format.Formatter;
+import com.scene.common.android.log.Log;
+
+/**
+ * Get memory info.
+ *
+ * @author MaTianyu
+ * @date 2015-04-19
+ */
+public class MemoryUtil {
+    private static final String TAG = MemoryUtil.class.getSimpleName();
+    private static final String MEM_INFO_PATH = "/proc/meminfo";
+
+    /**
+     * Print memory info. such as:
+     *
+     * MemTotal:        1864292 kB
+     * MemFree:          779064 kB
+     * Buffers:            4540 kB
+     * Cached:           185656 kB
+     * SwapCached:        13160 kB
+     * Active:           435588 kB
+     * Inactive:         269312 kB
+     * Active(anon):     386188 kB
+     * Inactive(anon):   132576 kB
+     * Active(file):      49400 kB
+     * Inactive(file):   136736 kB
+     * Unevictable:        2420 kB
+     * Mlocked:               0 kB
+     * HighTotal:       1437692 kB
+     * HighFree:         520212 kB
+     * LowTotal:         426600 kB
+     * LowFree:          258852 kB
+     * SwapTotal:        511996 kB
+     * SwapFree:         171876 kB
+     * Dirty:               412 kB
+     * Writeback:             0 kB
+     * AnonPages:        511924 kB
+     * Mapped:           152368 kB
+     * Shmem:              1636 kB
+     * Slab:             109224 kB
+     * SReclaimable:      75932 kB
+     * SUnreclaim:        33292 kB
+     * KernelStack:       13056 kB
+     * PageTables:        28032 kB
+     * NFS_Unstable:          0 kB
+     * Bounce:                0 kB
+     * WritebackTmp:          0 kB
+     * CommitLimit:     1444140 kB
+     * Committed_AS:   25977748 kB
+     * VmallocTotal:     458752 kB
+     * VmallocUsed:      123448 kB
+     * VmallocChunk:     205828 kB
+     */
+    public static String printMemInfo() {
+        String info = FileUtil.getFileOutputString(MEM_INFO_PATH);
+        if (Log.isPrint) {
+            Log.i(TAG, "_______  内存信息:   \n" + info);
+        }
+        return info;
+    }
+
+    /**
+     * Get memory info of device.
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static ActivityManager.MemoryInfo getMemoryInfo(Context context) {
+        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
+        am.getMemoryInfo(mi);
+        return mi;
+    }
+
+    /**
+     * Print Memory info.
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static ActivityManager.MemoryInfo printMemoryInfo(Context context) {
+        ActivityManager.MemoryInfo mi = getMemoryInfo(context);
+        if (Log.isPrint) {
+            StringBuilder sb = new StringBuilder();
+            sb.append("_______  Memory :   ");
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+                sb.append("\ntotalMem        :").append(mi.totalMem);
+            }
+            sb.append("\navailMem        :").append(mi.availMem);
+            sb.append("\nlowMemory       :").append(mi.lowMemory);
+            sb.append("\nthreshold       :").append(mi.threshold);
+            Log.i(TAG, sb.toString());
+        }
+        return mi;
+    }
+
+    /**
+     * Get available memory info.
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static String getAvailMemory(Context context) {// 获取android当前可用内存大小
+        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
+        am.getMemoryInfo(mi);
+        // mi.availMem; 当前系统的可用内存
+        return Formatter.formatFileSize(context, mi.availMem);// 将获取的内存大小规格化
+    }
+
+}
Index: customfresco/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/.gitignore	(revision )
+++ customfresco/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: ucrop/src/main/res/drawable/ucrop_ic_selector_aspect_ratio.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/drawable/ucrop_ic_selector_aspect_ratio.xml	(revision )
+++ ucrop/src/main/res/drawable/ucrop_ic_selector_aspect_ratio.xml	(revision )
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/ucrop_ic_crop_active" android:state_selected="true"/>
+    <item android:drawable="@drawable/ucrop_ic_crop"/>
+</selector>
Index: ucrop/src/main/java/com/yalantis/ucrop/util/RotationGestureDetector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/util/RotationGestureDetector.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/util/RotationGestureDetector.java	(revision )
@@ -0,0 +1,111 @@
+package com.yalantis.ucrop.util;
+
+import android.support.annotation.NonNull;
+import android.view.MotionEvent;
+
+public class RotationGestureDetector {
+
+    private static final int INVALID_POINTER_INDEX = -1;
+
+    private float fX, fY, sX, sY;
+
+    private int mPointerIndex1, mPointerIndex2;
+    private float mAngle;
+    private boolean mIsFirstTouch;
+
+    private OnRotationGestureListener mListener;
+
+    public RotationGestureDetector(OnRotationGestureListener listener) {
+        mListener = listener;
+        mPointerIndex1 = INVALID_POINTER_INDEX;
+        mPointerIndex2 = INVALID_POINTER_INDEX;
+    }
+
+    public float getAngle() {
+        return mAngle;
+    }
+
+    public boolean onTouchEvent(@NonNull MotionEvent event) {
+        switch (event.getActionMasked()) {
+            case MotionEvent.ACTION_DOWN:
+                sX = event.getX();
+                sY = event.getY();
+                mPointerIndex1 = event.findPointerIndex(event.getPointerId(0));
+                mAngle = 0;
+                mIsFirstTouch = true;
+                break;
+            case MotionEvent.ACTION_POINTER_DOWN:
+                fX = event.getX();
+                fY = event.getY();
+                mPointerIndex2 = event.findPointerIndex(event.getPointerId(event.getActionIndex()));
+                mAngle = 0;
+                mIsFirstTouch = true;
+                break;
+            case MotionEvent.ACTION_MOVE:
+                if (mPointerIndex1 != INVALID_POINTER_INDEX && mPointerIndex2 != INVALID_POINTER_INDEX && event.getPointerCount() > mPointerIndex2) {
+                    float nfX, nfY, nsX, nsY;
+
+                    nsX = event.getX(mPointerIndex1);
+                    nsY = event.getY(mPointerIndex1);
+                    nfX = event.getX(mPointerIndex2);
+                    nfY = event.getY(mPointerIndex2);
+
+                    if (mIsFirstTouch) {
+                        mAngle = 0;
+                        mIsFirstTouch = false;
+                    } else {
+                        calculateAngleBetweenLines(fX, fY, sX, sY, nfX, nfY, nsX, nsY);
+                    }
+
+                    if (mListener != null) {
+                        mListener.onRotation(this);
+                    }
+                    fX = nfX;
+                    fY = nfY;
+                    sX = nsX;
+                    sY = nsY;
+                }
+                break;
+            case MotionEvent.ACTION_UP:
+                mPointerIndex1 = INVALID_POINTER_INDEX;
+                break;
+            case MotionEvent.ACTION_POINTER_UP:
+                mPointerIndex2 = INVALID_POINTER_INDEX;
+                break;
+        }
+        return true;
+    }
+
+    private float calculateAngleBetweenLines(float fx1, float fy1, float fx2, float fy2,
+                                             float sx1, float sy1, float sx2, float sy2) {
+        return calculateAngleDelta(
+                (float) Math.toDegrees((float) Math.atan2((fy1 - fy2), (fx1 - fx2))),
+                (float) Math.toDegrees((float) Math.atan2((sy1 - sy2), (sx1 - sx2))));
+    }
+
+    private float calculateAngleDelta(float angleFrom, float angleTo) {
+        mAngle = angleTo % 360.0f - angleFrom % 360.0f;
+
+        if (mAngle < -180.0f) {
+            mAngle += 360.0f;
+        } else if (mAngle > 180.0f) {
+            mAngle -= 360.0f;
+        }
+
+        return mAngle;
+    }
+
+    public static class SimpleOnRotationGestureListener implements OnRotationGestureListener {
+
+        @Override
+        public boolean onRotation(RotationGestureDetector rotationDetector) {
+            return false;
+        }
+    }
+
+    public interface OnRotationGestureListener {
+
+        boolean onRotation(RotationGestureDetector rotationDetector);
+    }
+
+}
\ No newline at end of file
Index: ucrop/src/main/res/drawable/ucrop_ic_selector_rotate.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/drawable/ucrop_ic_selector_rotate.xml	(revision )
+++ ucrop/src/main/res/drawable/ucrop_ic_selector_rotate.xml	(revision )
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/ucrop_ic_rotate_active" android:state_selected="true"/>
+    <item android:drawable="@drawable/ucrop_ic_rotate"/>
+</selector>
Index: common/src/main/java/com/scene/common/common/assist/Base64.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/Base64.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/Base64.java	(revision )
@@ -0,0 +1,741 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.common.common.assist;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Utilities for encoding and decoding the Base64 representation of
+ * binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
+ * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ */
+public class Base64 {
+    /**
+     * Default values for encoder/decoder flags.
+     */
+    public static final int DEFAULT = 0;
+
+    /**
+     * Encoder flag bit to omit the padding '=' characters at the end
+     * of the output (if any).
+     */
+    public static final int NO_PADDING = 1;
+
+    /**
+     * Encoder flag bit to omit all line terminators (i.e., the output
+     * will be on one long line).
+     */
+    public static final int NO_WRAP = 2;
+
+    /**
+     * Encoder flag bit to indicate lines should be terminated with a
+     * CRLF pair instead of just an LF.  Has no effect if {@code
+     * NO_WRAP} is specified as well.
+     */
+    public static final int CRLF = 4;
+
+    /**
+     * Encoder/decoder flag bit to indicate using the "URL and
+     * filename safe" variant of Base64 (see RFC 3548 section 4) where
+     * {@code -} and {@code _} are used in place of {@code +} and
+     * {@code /}.
+     */
+    public static final int URL_SAFE = 8;
+
+    /**
+     * Flag to pass to {@link android.util.Base64OutputStream} to indicate that it
+     * should not close the output stream it is wrapping when it
+     * itself is closed.
+     */
+    public static final int NO_CLOSE = 16;
+
+    //  --------------------------------------------------------
+    //  shared code
+    //  --------------------------------------------------------
+
+    /* package */ static abstract class Coder {
+        public byte[] output;
+        public int op;
+
+        /**
+         * Encode/decode another block of input data.  this.output is
+         * provided by the caller, and must be big enough to hold all
+         * the coded data.  On exit, this.opwill be set to the length
+         * of the coded data.
+         *
+         * @param finish true if this is the final call to process for
+         *        this object.  Will finalize the coder state and
+         *        include any final bytes in the output.
+         *
+         * @return true if the input so far is good; false if some
+         *         error has been detected in the input stream..
+         */
+        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
+
+        /**
+         * @return the maximum number of bytes a call to process()
+         * could produce for the given number of input bytes.  This may
+         * be an overestimate.
+         */
+        public abstract int maxOutputSize(int len);
+    }
+
+    //  --------------------------------------------------------
+    //  decoding
+    //  --------------------------------------------------------
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param str    the input String to decode, which is converted to
+     *               bytes using the default charset
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(String str, int flags) {
+        return decode(str.getBytes(), flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input the input array to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int flags) {
+        return decode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input  the data to decode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int offset, int len, int flags) {
+        // Allocate space for the most data the input could represent.
+        // (It could contain less if it contains whitespace, etc.)
+        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+
+        if (!decoder.process(input, offset, len, true)) {
+            throw new IllegalArgumentException("bad base-64");
+        }
+
+        // Maybe we got lucky and allocated exactly enough output space.
+        if (decoder.op == decoder.output.length) {
+            return decoder.output;
+        }
+
+        // Need to shorten the array, so allocate a new one of the
+        // right size and copy.
+        byte[] temp = new byte[decoder.op];
+        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
+        return temp;
+    }
+
+    /* package */ static class Decoder extends Coder {
+        /**
+         * Lookup table for turning bytes into their position in the
+         * Base64 alphabet.
+         */
+        private static final int DECODE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Decode lookup table for the "web safe" variant (RFC 3548
+         * sec. 4) where - and _ replace + and /.
+         */
+        private static final int DECODE_WEBSAFE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /** Non-data values in the DECODE arrays. */
+        private static final int SKIP = -1;
+        private static final int EQUALS = -2;
+
+        /**
+         * States 0-3 are reading through the next input tuple.
+         * State 4 is having read one '=' and expecting exactly
+         * one more.
+         * State 5 is expecting no more data or padding characters
+         * in the input.
+         * State 6 is the error state; an error has been detected
+         * in the input and no future input can "fix" it.
+         */
+        private int state;   // state number (0 to 6)
+        private int value;
+
+        final private int[] alphabet;
+
+        public Decoder(int flags, byte[] output) {
+            this.output = output;
+
+            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
+            state = 0;
+            value = 0;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could decode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 3/4 + 10;
+        }
+
+        /**
+         * Decode another block of input data.
+         *
+         * @return true if the state machine is still healthy.  false if
+         *         bad base-64 data has been detected in the input stream.
+         */
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            if (this.state == 6) return false;
+
+            int p = offset;
+            len += offset;
+
+            // Using local variables makes the decoder about 12%
+            // faster than if we manipulate the member variables in
+            // the loop.  (Even alphabet makes a measurable
+            // difference, which is somewhat surprising to me since
+            // the member variable is final.)
+            int state = this.state;
+            int value = this.value;
+            int op = 0;
+            final byte[] output = this.output;
+            final int[] alphabet = this.alphabet;
+
+            while (p < len) {
+                // Try the fast path:  we're starting a new tuple and the
+                // next four bytes of the input stream are all data
+                // bytes.  This corresponds to going through states
+                // 0-1-2-3-0.  We expect to use this method for most of
+                // the data.
+                //
+                // If any of the next four bytes of input are non-data
+                // (whitespace, etc.), value will end up negative.  (All
+                // the non-data values in decode are small negative
+                // numbers, so shifting any of them up and or'ing them
+                // together will result in a value with its top bit set.)
+                //
+                // You can remove this whole block and the output should
+                // be the same, just slower.
+                if (state == 0) {
+                    while (p+4 <= len &&
+                           (value = ((alphabet[input[p] & 0xff] << 18) |
+                                     (alphabet[input[p+1] & 0xff] << 12) |
+                                     (alphabet[input[p+2] & 0xff] << 6) |
+                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        p += 4;
+                    }
+                    if (p >= len) break;
+                }
+
+                // The fast path isn't available -- either we've read a
+                // partial tuple, or the next four input bytes aren't all
+                // data, or whatever.  Fall back to the slower state
+                // machine implementation.
+
+                int d = alphabet[input[p++] & 0xff];
+
+                switch (state) {
+                case 0:
+                    if (d >= 0) {
+                        value = d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 1:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 2:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect exactly one more padding character.
+                        output[op++] = (byte) (value >> 4);
+                        state = 4;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 3:
+                    if (d >= 0) {
+                        // Emit the output triple and return to state 0.
+                        value = (value << 6) | d;
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        state = 0;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect no further data or padding characters.
+                        output[op+1] = (byte) (value >> 2);
+                        output[op] = (byte) (value >> 10);
+                        op += 2;
+                        state = 5;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 4:
+                    if (d == EQUALS) {
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 5:
+                    if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+                }
+            }
+
+            if (!finish) {
+                // We're out of input, but a future call could provide
+                // more.
+                this.state = state;
+                this.value = value;
+                this.op = op;
+                return true;
+            }
+
+            // Done reading input.  Now figure out where we are left in
+            // the state machine and finish up.
+
+            switch (state) {
+            case 0:
+                // Output length is a multiple of three.  Fine.
+                break;
+            case 1:
+                // Read one extra input byte, which isn't enough to
+                // make another output byte.  Illegal.
+                this.state = 6;
+                return false;
+            case 2:
+                // Read two extra input bytes, enough to emit 1 more
+                // output byte.  Fine.
+                output[op++] = (byte) (value >> 4);
+                break;
+            case 3:
+                // Read three extra input bytes, enough to emit 2 more
+                // output bytes.  Fine.
+                output[op++] = (byte) (value >> 10);
+                output[op++] = (byte) (value >> 2);
+                break;
+            case 4:
+                // Read one padding '=' when we expected 2.  Illegal.
+                this.state = 6;
+                return false;
+            case 5:
+                // Read all the padding '='s we expected and no more.
+                // Fine.
+                break;
+            }
+
+            this.state = state;
+            this.op = op;
+            return true;
+        }
+    }
+
+    //  --------------------------------------------------------
+    //  encoding
+    //  --------------------------------------------------------
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int flags) {
+        try {
+            return new String(encode(input, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int offset, int len, int flags) {
+        try {
+            return new String(encode(input, offset, len, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int flags) {
+        return encode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int offset, int len, int flags) {
+        Encoder encoder = new Encoder(flags, null);
+
+        // Compute the exact length of the array we will produce.
+        int output_len = len / 3 * 4;
+
+        // Account for the tail of the data and the padding bytes, if any.
+        if (encoder.do_padding) {
+            if (len % 3 > 0) {
+                output_len += 4;
+            }
+        } else {
+            switch (len % 3) {
+                case 0: break;
+                case 1: output_len += 2; break;
+                case 2: output_len += 3; break;
+            }
+        }
+
+        // Account for the newlines, if any.
+        if (encoder.do_newline && len > 0) {
+            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                (encoder.do_cr ? 2 : 1);
+        }
+
+        encoder.output = new byte[output_len];
+        encoder.process(input, offset, len, true);
+
+        assert encoder.op == output_len;
+
+        return encoder.output;
+    }
+
+    /* package */ static class Encoder extends Coder {
+        /**
+         * Emit a new line every this many output tuples.  Corresponds to
+         * a 76-character line length (the maximum allowable according to
+         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         */
+        public static final int LINE_GROUPS = 19;
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+        };
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE_WEBSAFE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+        };
+
+        final private byte[] tail;
+        /* package */ int tailLen;
+        private int count;
+
+        final public boolean do_padding;
+        final public boolean do_newline;
+        final public boolean do_cr;
+        final private byte[] alphabet;
+
+        public Encoder(int flags, byte[] output) {
+            this.output = output;
+
+            do_padding = (flags & NO_PADDING) == 0;
+            do_newline = (flags & NO_WRAP) == 0;
+            do_cr = (flags & CRLF) != 0;
+            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
+
+            tail = new byte[2];
+            tailLen = 0;
+
+            count = do_newline ? LINE_GROUPS : -1;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could encode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 8/5 + 10;
+        }
+
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            // Using local variables makes the encoder about 9% faster.
+            final byte[] alphabet = this.alphabet;
+            final byte[] output = this.output;
+            int op = 0;
+            int count = this.count;
+
+            int p = offset;
+            len += offset;
+            int v = -1;
+
+            // First we need to concatenate the tail of the previous call
+            // with any input bytes available now and see if we can empty
+            // the tail.
+
+            switch (tailLen) {
+                case 0:
+                    // There was no tail.
+                    break;
+
+                case 1:
+                    if (p+2 <= len) {
+                        // A 1-byte tail with at least 2 bytes of
+                        // input available now.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((input[p++] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    };
+                    break;
+
+                case 2:
+                    if (p+1 <= len) {
+                        // A 2-byte tail with at least 1 byte of input.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((tail[1] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+            }
+
+            if (v != -1) {
+                output[op++] = alphabet[(v >> 18) & 0x3f];
+                output[op++] = alphabet[(v >> 12) & 0x3f];
+                output[op++] = alphabet[(v >> 6) & 0x3f];
+                output[op++] = alphabet[v & 0x3f];
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            // At this point either there is no tail, or there are fewer
+            // than 3 bytes of input available.
+
+            // The main loop, turning 3 input bytes into 4 output bytes on
+            // each iteration.
+            while (p+3 <= len) {
+                v = ((input[p] & 0xff) << 16) |
+                    ((input[p+1] & 0xff) << 8) |
+                    (input[p+2] & 0xff);
+                output[op] = alphabet[(v >> 18) & 0x3f];
+                output[op+1] = alphabet[(v >> 12) & 0x3f];
+                output[op+2] = alphabet[(v >> 6) & 0x3f];
+                output[op+3] = alphabet[v & 0x3f];
+                p += 3;
+                op += 4;
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            if (finish) {
+                // Finish up the tail of the input.  Note that we need to
+                // consume any bytes in tail before any bytes
+                // remaining in input; there should be at most two bytes
+                // total.
+
+                if (p-tailLen == len-1) {
+                    int t = 0;
+                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (p-tailLen == len-2) {
+                    int t = 0;
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
+                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 12) & 0x3f];
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                }
+
+                assert tailLen == 0;
+                assert p == len;
+            } else {
+                // Save the leftovers in tail to be consumed on the next
+                // call to encodeInternal.
+
+                if (p == len-1) {
+                    tail[tailLen++] = input[p];
+                } else if (p == len-2) {
+                    tail[tailLen++] = input[p];
+                    tail[tailLen++] = input[p+1];
+                }
+            }
+
+            this.op = op;
+            this.count = count;
+
+            return true;
+        }
+    }
+
+    private Base64() { }   // don't instantiate
+}
Index: mylib/src/main/res/drawable/psts_background_tab.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/drawable/psts_background_tab.xml	(revision )
+++ mylib/src/main/res/drawable/psts_background_tab.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android" android:exitFadeDuration="@android:integer/config_shortAnimTime">
+
+    <item android:drawable="@color/background_tab_pressed" android:state_pressed="true" />
+    <item android:drawable="@color/background_tab_pressed" android:state_focused="true" />
+    <item android:drawable="@android:color/transparent" />
+
+</selector>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/receiver/ScreenReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/receiver/ScreenReceiver.java	(revision )
+++ common/src/main/java/com/scene/common/common/receiver/ScreenReceiver.java	(revision )
@@ -0,0 +1,61 @@
+package com.scene.common.common.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import com.scene.common.android.log.Log;
+
+public class ScreenReceiver extends BroadcastReceiver {
+    private String TAG = "ScreenActionReceiver";
+    private ScreenListener screenListener;
+
+    public ScreenReceiver() {
+
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        if (action.equals(Intent.ACTION_SCREEN_ON)) {
+            Log.d(TAG, "屏幕解锁广播...");
+            if (screenListener != null) {
+                screenListener.screenOn();
+            }
+        } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+            Log.d(TAG, "屏幕加锁广播...");
+            if (screenListener != null) {
+                screenListener.screenOff();
+            }
+        }
+    }
+
+    public void registerScreenReceiver(Context context, ScreenListener screenListener) {
+        try {
+            this.screenListener = screenListener;
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            filter.addAction(Intent.ACTION_SCREEN_ON);
+            Log.d(TAG, "注册屏幕解锁、加锁广播接收者...");
+            context.registerReceiver(this, filter);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void unRegisterScreenReceiver(Context context) {
+        try {
+            context.unregisterReceiver(this);
+            Log.d(TAG, "注销屏幕解锁、加锁广播接收者...");
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static interface ScreenListener {
+        public void screenOn();
+
+        public void screenOff();
+    }
+
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/BaseSwipeAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/BaseSwipeAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/BaseSwipeAdapter.java	(revision )
@@ -0,0 +1,111 @@
+package com.scene.mylib.view.swipelayout.adapters;
+
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+
+
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.implments.SwipeItemMangerImpl;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeAdapterInterface;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeItemMangerInterface;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.List;
+
+public abstract class BaseSwipeAdapter extends BaseAdapter implements SwipeItemMangerInterface, SwipeAdapterInterface {
+
+    protected SwipeItemMangerImpl mItemManger = new SwipeItemMangerImpl(this);
+
+    /**
+     * return the resource id, int the view item.
+     * @param position
+     * @return
+     */
+    public abstract int getSwipeLayoutResourceId(int position);
+
+    /**
+     * generate a new view item.
+     * Never bind SwipeListener or fill values here, every item has a chance to fill value or bind
+     * listeners in fillValues.
+     * to fill it in {@code fillValues} method.
+     * @param position
+     * @param parent
+     * @return
+     */
+    public abstract View generateView(int position, ViewGroup parent);
+
+    /**
+     * fill values or bind listeners to the view.
+     * @param position
+     * @param convertView
+     */
+    public abstract void fillValues(int position, View convertView);
+
+    @Override
+    public void notifyDatasetChanged() {
+        super.notifyDataSetChanged();
+    }
+
+
+    @Override
+    public final View getView(int position, View convertView, ViewGroup parent) {
+        View v = convertView;
+        if(v == null){
+            v = generateView(position, parent);
+        }
+        mItemManger.bind(v, position);
+        fillValues(position, v);
+        return v;
+    }
+
+    @Override
+    public void openItem(int position) {
+        mItemManger.openItem(position);
+    }
+
+    @Override
+    public void closeItem(int position) {
+        mItemManger.closeItem(position);
+    }
+
+    @Override
+    public void closeAllExcept(SwipeLayout layout) {
+        mItemManger.closeAllExcept(layout);
+    }
+
+    @Override
+    public void closeAllItems() {
+        mItemManger.closeAllItems();
+    }
+
+    @Override
+    public List<Integer> getOpenItems() {
+        return mItemManger.getOpenItems();
+    }
+
+    @Override
+    public List<SwipeLayout> getOpenLayouts() {
+        return mItemManger.getOpenLayouts();
+    }
+
+    @Override
+    public void removeShownLayouts(SwipeLayout layout) {
+        mItemManger.removeShownLayouts(layout);
+    }
+
+    @Override
+    public boolean isOpen(int position) {
+        return mItemManger.isOpen(position);
+    }
+
+    @Override
+    public Attributes.Mode getMode() {
+        return mItemManger.getMode();
+    }
+
+    @Override
+    public void setMode(Attributes.Mode mode) {
+        mItemManger.setMode(mode);
+    }
+}
Index: common/src/main/java/com/scene/common/common/io/Charsets.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/Charsets.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/Charsets.java	(revision )
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io;
+
+import java.nio.charset.Charset;
+
+/**
+ * Charsets
+ */
+public class Charsets {
+    public static Charset toCharset(Charset charset) {
+        return charset == null ? Charset.defaultCharset() : charset;
+    }
+    public static Charset toCharset(String charset) {
+        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);
+    }
+    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+    public static final Charset US_ASCII = Charset.forName("US-ASCII");
+    public static final Charset UTF_16 = Charset.forName("UTF-16");
+    public static final Charset UTF_16BE = Charset.forName("UTF-16BE");
+    public static final Charset UTF_16LE = Charset.forName("UTF-16LE");
+    public static final Charset UTF_8 = Charset.forName("UTF-8");
+}
Index: ucrop/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/values/colors.xml	(revision )
+++ ucrop/src/main/res/values/colors.xml	(revision )
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <!--uCrop Activity-->
+    <color name="ucrop_color_toolbar">#FF6E40</color>
+    <color name="ucrop_color_statusbar">#CC5833</color>
+    <color name="ucrop_color_title">#fff</color>
+    <color name="ucrop_color_widget_active">#FF6E40</color>
+    <color name="ucrop_color_widget_background">#fff</color>
+    <color name="ucrop_color_progress_wheel_line">#808080</color>
+
+    <!--Crop View-->
+    <color name="ucrop_color_default_crop_grid">#ffffff</color>
+    <color name="ucrop_color_default_crop_frame">#ffffff</color>
+    <color name="ucrop_color_default_overlay">#a0000000</color>
+
+</resources>
\ No newline at end of file
Index: easypermissions/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/src/main/AndroidManifest.xml	(revision )
+++ easypermissions/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,10 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.example.easypermissions">
+
+    <application
+        android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
Index: common/src/main/java/com/scene/common/common/utils/SdCardUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/SdCardUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/SdCardUtil.java	(revision )
@@ -0,0 +1,212 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.os.Environment;
+import android.os.StatFs;
+import com.scene.common.android.log.Log;
+
+import java.io.*;
+import java.util.ArrayList;
+
+/**
+ * Get SD card info.
+ *
+ * @author MaTianyu
+ * @date 2015-04-19
+ */
+public class SdCardUtil {
+    private static final String TAG = SdCardUtil.class.getSimpleName();
+
+    /**
+     * is sd card available.
+     * @return true if available
+     */
+    public boolean isSdCardAvailable() {
+        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
+    }
+
+    /**
+     * Get {@link StatFs}.
+     */
+    public static StatFs getStatFs(String path) {
+        return new StatFs(path);
+    }
+
+    /**
+     * Get phone data path.
+     */
+    public static String getDataPath() {
+        return Environment.getDataDirectory().getPath();
+
+    }
+
+    /**
+     * Get SD card path.
+     */
+    public static String getNormalSDCardPath() {
+        return Environment.getExternalStorageDirectory().getPath();
+    }
+
+    /**
+     * Get SD card path by CMD.
+     */
+    public static String getSDCardPath() {
+        String cmd = "cat /proc/mounts";
+        String sdcard = null;
+        Runtime run = Runtime.getRuntime();// 返回与当前 Java 应用程序相关的运行时对象
+        BufferedReader bufferedReader = null;
+        try {
+            Process p = run.exec(cmd);// 启动另一个进程来执行命令
+            bufferedReader = new BufferedReader(new InputStreamReader(new BufferedInputStream(p.getInputStream())));
+            String lineStr;
+            while ((lineStr = bufferedReader.readLine()) != null) {
+                Log.i(TAG, "proc/mounts:   " + lineStr);
+                if (lineStr.contains("sdcard")
+                    && lineStr.contains(".android_secure")) {
+                    String[] strArray = lineStr.split(" ");
+                    if (strArray.length >= 5) {
+                        sdcard = strArray[1].replace("/.android_secure", "");
+                        Log.i(TAG, "find sd card path:   " + sdcard);
+                        return sdcard;
+                    }
+                }
+                if (p.waitFor() != 0 && p.exitValue() == 1) {
+                    // p.exitValue()==0表示正常结束，1：非正常结束
+                    Log.e(TAG, cmd + " 命令执行失败");
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                if (bufferedReader != null) {
+                    bufferedReader.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        sdcard = Environment.getExternalStorageDirectory().getPath();
+        Log.i(TAG, "not find sd card path return default:   " + sdcard);
+        return sdcard;
+    }
+
+    /**
+     * Get SD card path list.
+     */
+    public static ArrayList<String> getSDCardPathEx() {
+        ArrayList<String> list = new ArrayList<String>();
+        try {
+            Runtime runtime = Runtime.getRuntime();
+            Process proc = runtime.exec("mount");
+            InputStream is = proc.getInputStream();
+            InputStreamReader isr = new InputStreamReader(is);
+            String line;
+            BufferedReader br = new BufferedReader(isr);
+            while ((line = br.readLine()) != null) {
+                Log.i(TAG, "mount:  " + line);
+                if (line.contains("secure")) {
+                    continue;
+                }
+                if (line.contains("asec")) {
+                    continue;
+                }
+
+                if (line.contains("fat")) {
+                    String columns[] = line.split(" ");
+                    if (columns.length > 1) {
+                        list.add("*" + columns[1]);
+                    }
+                } else if (line.contains("fuse")) {
+                    String columns[] = line.split(" ");
+                    if (columns.length > 1) {
+                        list.add(columns[1]);
+                    }
+                }
+            }
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return list;
+    }
+
+    /**
+     * Get available size of SD card.
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public static long getAvailableSize(String path) {
+        try {
+            File base = new File(path);
+            StatFs stat = new StatFs(base.getPath());
+            return stat.getBlockSizeLong() * stat.getAvailableBlocksLong();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return 0;
+    }
+
+    /**
+     * Get SD card info detail.
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public static SDCardInfo getSDCardInfo() {
+        SDCardInfo sd = new SDCardInfo();
+        String state = Environment.getExternalStorageState();
+        if (Environment.MEDIA_MOUNTED.equals(state)) {
+            sd.isExist = true;
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+                File sdcardDir = Environment.getExternalStorageDirectory();
+                StatFs sf = new StatFs(sdcardDir.getPath());
+
+                sd.totalBlocks = sf.getBlockCountLong();
+                sd.blockByteSize = sf.getBlockSizeLong();
+
+                sd.availableBlocks = sf.getAvailableBlocksLong();
+                sd.availableBytes = sf.getAvailableBytes();
+
+                sd.freeBlocks = sf.getFreeBlocksLong();
+                sd.freeBytes = sf.getFreeBytes();
+
+                sd.totalBytes = sf.getTotalBytes();
+            }
+        }
+        if (Log.isPrint) {
+            Log.i(TAG, sd.toString());
+        }
+        return sd;
+    }
+
+
+    /**
+     * see more {@link StatFs}
+     */
+    public static class SDCardInfo {
+        public boolean isExist;
+        public long totalBlocks;
+        public long freeBlocks;
+        public long availableBlocks;
+
+        public long blockByteSize;
+
+        public long totalBytes;
+        public long freeBytes;
+        public long availableBytes;
+
+        @Override
+        public String toString() {
+            return "SDCardInfo{" +
+                   "isExist=" + isExist +
+                   ", totalBlocks=" + totalBlocks +
+                   ", freeBlocks=" + freeBlocks +
+                   ", availableBlocks=" + availableBlocks +
+                   ", blockByteSize=" + blockByteSize +
+                   ", totalBytes=" + totalBytes +
+                   ", freeBytes=" + freeBytes +
+                   ", availableBytes=" + availableBytes +
+                   '}';
+        }
+    }
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/view/widget/AspectRatioTextView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/view/widget/AspectRatioTextView.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/view/widget/AspectRatioTextView.java	(revision )
@@ -0,0 +1,112 @@
+package com.yalantis.ucrop.view.widget;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.widget.TextView;
+
+import com.yalantis.ucrop.R;
+import com.yalantis.ucrop.view.CropImageView;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ */
+public class AspectRatioTextView extends TextView {
+
+    private final Rect mCanvasClipBounds = new Rect();
+    private Paint mDotPaint;
+    private int mDotSize;
+    private float mAspectRatio;
+
+    private String mAspectRatioTitle;
+    private float mAspectRatioX, mAspectRatioY;
+
+    public AspectRatioTextView(Context context) {
+        this(context, null);
+    }
+
+    public AspectRatioTextView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public AspectRatioTextView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ucrop_AspectRatioTextView);
+        init(a);
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public AspectRatioTextView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ucrop_AspectRatioTextView);
+        init(a);
+    }
+
+    public float getAspectRatio(boolean toggleRatio) {
+        if (toggleRatio) {
+            toggleAspectRatio();
+            setTitle();
+        }
+        return mAspectRatio;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (isSelected()) {
+            canvas.getClipBounds(mCanvasClipBounds);
+            canvas.drawCircle((mCanvasClipBounds.right - mCanvasClipBounds.left) / 2.0f, mCanvasClipBounds.bottom - mDotSize,
+                    mDotSize / 2, mDotPaint);
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    private void init(@NonNull TypedArray a) {
+        setGravity(Gravity.CENTER_HORIZONTAL);
+
+        mAspectRatioTitle = a.getString(R.styleable.ucrop_AspectRatioTextView_ucrop_artv_ratio_title);
+        mAspectRatioX = a.getFloat(R.styleable.ucrop_AspectRatioTextView_ucrop_artv_ratio_x, CropImageView.SOURCE_IMAGE_ASPECT_RATIO);
+        mAspectRatioY = a.getFloat(R.styleable.ucrop_AspectRatioTextView_ucrop_artv_ratio_y, CropImageView.SOURCE_IMAGE_ASPECT_RATIO);
+
+        if (mAspectRatioX == CropImageView.SOURCE_IMAGE_ASPECT_RATIO || mAspectRatioY == CropImageView.SOURCE_IMAGE_ASPECT_RATIO) {
+            mAspectRatio = CropImageView.SOURCE_IMAGE_ASPECT_RATIO;
+        } else {
+            mAspectRatio = mAspectRatioX / mAspectRatioY;
+        }
+
+        mDotSize = getContext().getResources().getDimensionPixelSize(R.dimen.ucrop_size_dot_scale_text_view);
+        mDotPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mDotPaint.setStyle(Paint.Style.FILL);
+        mDotPaint.setColor(getResources().getColor(R.color.ucrop_color_widget_active));
+
+        setTitle();
+    }
+
+    private void toggleAspectRatio() {
+        if (mAspectRatio != CropImageView.SOURCE_IMAGE_ASPECT_RATIO) {
+            float tempRatioW = mAspectRatioX;
+            mAspectRatioX = mAspectRatioY;
+            mAspectRatioY = tempRatioW;
+
+            mAspectRatio = mAspectRatioX / mAspectRatioY;
+        }
+    }
+
+    private void setTitle() {
+        if (!TextUtils.isEmpty(mAspectRatioTitle)) {
+            setText(mAspectRatioTitle);
+        } else {
+            setText(String.format("%d:%d", (int) mAspectRatioX, (int) mAspectRatioY));
+        }
+    }
+
+}
Index: common/src/androidTest/java/com/scene/common/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/androidTest/java/com/scene/common/ApplicationTest.java	(revision )
+++ common/src/androidTest/java/com/scene/common/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.scene.common;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(revision )
+++ .idea/vcs.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/HexUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/HexUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/HexUtil.java	(revision )
@@ -0,0 +1,165 @@
+package com.scene.common.common.utils;
+
+/**
+ * reference apache commons <a
+ * href="http://commons.apache.org/codec/">http://commons.apache.org/codec/</a>
+ *
+ * @author Aub
+ *
+ */
+public class HexUtil {
+
+    /**
+     * 用于建立十六进制字符的输出的小写字符数组
+     */
+    private static final char[] DIGITS_LOWER = { '0', '1', '2', '3', '4', '5',
+            '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+    /**
+     * 用于建立十六进制字符的输出的大写字符数组
+     */
+    private static final char[] DIGITS_UPPER = { '0', '1', '2', '3', '4', '5',
+            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+
+    /**
+     * 将字节数组转换为十六进制字符数组
+     *
+     * @param data
+     *            byte[]
+     * @return 十六进制char[]
+     */
+    public static char[] encodeHex(byte[] data) {
+        return encodeHex(data, true);
+    }
+
+    /**
+     * 将字节数组转换为十六进制字符数组
+     *
+     * @param data
+     *            byte[]
+     * @param toLowerCase
+     *            <code>true</code> 传换成小写格式 ， <code>false</code> 传换成大写格式
+     * @return 十六进制char[]
+     */
+    public static char[] encodeHex(byte[] data, boolean toLowerCase) {
+        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
+    }
+
+    /**
+     * 将字节数组转换为十六进制字符数组
+     *
+     * @param data
+     *            byte[]
+     * @param toDigits
+     *            用于控制输出的char[]
+     * @return 十六进制char[]
+     */
+    protected static char[] encodeHex(byte[] data, char[] toDigits) {
+        int l = data.length;
+        char[] out = new char[l << 1];
+        // two characters form the hex value.
+        for (int i = 0, j = 0; i < l; i++) {
+            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];
+            out[j++] = toDigits[0x0F & data[i]];
+        }
+        return out;
+    }
+
+    /**
+     * 将字节数组转换为十六进制字符串
+     *
+     * @param data
+     *            byte[]
+     * @return 十六进制String
+     */
+    public static String encodeHexStr(byte[] data) {
+        return encodeHexStr(data, true);
+    }
+
+    /**
+     * 将字节数组转换为十六进制字符串
+     *
+     * @param data
+     *            byte[]
+     * @param toLowerCase
+     *            <code>true</code> 传换成小写格式 ， <code>false</code> 传换成大写格式
+     * @return 十六进制String
+     */
+    public static String encodeHexStr(byte[] data, boolean toLowerCase) {
+        return encodeHexStr(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
+    }
+
+    /**
+     * 将字节数组转换为十六进制字符串
+     *
+     * @param data
+     *            byte[]
+     * @param toDigits
+     *            用于控制输出的char[]
+     * @return 十六进制String
+     */
+    protected static String encodeHexStr(byte[] data, char[] toDigits) {
+        return new String(encodeHex(data, toDigits));
+    }
+
+    /**
+     * 将十六进制字符数组转换为字节数组
+     *
+     * @param data
+     *            十六进制char[]
+     * @return byte[]
+     * @throws RuntimeException
+     *             如果源十六进制字符数组是一个奇怪的长度，将抛出运行时异常
+     */
+    public static byte[] decodeHex(char[] data) {
+
+        int len = data.length;
+
+        if ((len & 0x01) != 0) {
+            throw new RuntimeException("Odd number of characters.");
+        }
+
+        byte[] out = new byte[len >> 1];
+
+        // two characters form the hex value.
+        for (int i = 0, j = 0; j < len; i++) {
+            int f = toDigit(data[j], j) << 4;
+            j++;
+            f = f | toDigit(data[j], j);
+            j++;
+            out[i] = (byte) (f & 0xFF);
+        }
+
+        return out;
+    }
+
+    /**
+     * 将十六进制字符转换成一个整数
+     *
+     * @param ch
+     *            十六进制char
+     * @param index
+     *            十六进制字符在字符数组中的位置
+     * @return 一个整数
+     * @throws RuntimeException
+     *             当ch不是一个合法的十六进制字符时，抛出运行时异常
+     */
+    protected static int toDigit(char ch, int index) {
+        int digit = Character.digit(ch, 16);
+        if (digit == -1) {
+            throw new RuntimeException("Illegal hexadecimal character " + ch
+                    + " at index " + index);
+        }
+        return digit;
+    }
+
+    public static void main(String[] args) {
+        String srcStr = "待转换字符串";
+        String encodeStr = encodeHexStr(srcStr.getBytes());
+        String decodeStr = new String(decodeHex(encodeStr.toCharArray()));
+        System.out.println("转换前：" + srcStr);
+        System.out.println("转换后：" + encodeStr);
+        System.out.println("还原后：" + decodeStr);
+    }
+
+}
Index: chooseimagelib/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/res/values/strings.xml	(revision )
+++ chooseimagelib/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,8 @@
+<resources>
+    <string name="cancel">取消</string>
+    <string name="save">保存</string>
+    <string name="saving_image">图片保存中...</string>
+    <string name="preparing_card">准备SD卡</string>
+    <string name="no_storage_card">SD卡没找到</string>
+    <string name="not_enough_space">SD卡空间不足</string>
+</resources>
Index: common/src/main/java/com/scene/common/common/utils/AndroidUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/AndroidUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/AndroidUtil.java	(revision )
@@ -0,0 +1,97 @@
+package com.scene.common.common.utils;
+
+import android.content.Context;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Build;
+import android.os.SystemClock;
+import com.scene.common.android.log.Log;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+/**
+ * 手机信息 & MAC地址 & 开机时间
+ *
+ * @author MaTianyu
+ * @date 2014-09-25
+ */
+public class AndroidUtil {
+    private static final String TAG = AndroidUtil.class.getSimpleName();
+
+    /**
+     * 获取 MAC 地址
+     * <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
+     */
+    public static String getMacAddress(Context context) {
+        //wifi mac地址
+        WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        WifiInfo info = wifi.getConnectionInfo();
+        String mac = info.getMacAddress();
+        if (Log.isPrint) {
+            Log.i(TAG, " MAC：" + mac);
+        }
+        return mac;
+    }
+
+    /**
+     * 获取 开机时间
+     */
+    public static String getBootTimeString() {
+        long ut = SystemClock.elapsedRealtime() / 1000;
+        int h = (int) ((ut / 3600));
+        int m = (int) ((ut / 60) % 60);
+        if (Log.isPrint) {
+            Log.i(TAG, h + ":" + m);
+        }
+        return h + ":" + m;
+    }
+
+    public static String printSystemInfo() {
+        Date date = new Date(System.currentTimeMillis());
+        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+        String time = dateFormat.format(date);
+        StringBuilder sb = new StringBuilder();
+        sb.append("_______  系统信息  ").append(time).append(" ______________");
+        sb.append("\nID                 :").append(Build.ID);
+        sb.append("\nBRAND              :").append(Build.BRAND);
+        sb.append("\nMODEL              :").append(Build.MODEL);
+        sb.append("\nRELEASE            :").append(Build.VERSION.RELEASE);
+        sb.append("\nSDK                :").append(Build.VERSION.SDK);
+
+        sb.append("\n_______ OTHER _______");
+        sb.append("\nBOARD              :").append(Build.BOARD);
+        sb.append("\nPRODUCT            :").append(Build.PRODUCT);
+        sb.append("\nDEVICE             :").append(Build.DEVICE);
+        sb.append("\nFINGERPRINT        :").append(Build.FINGERPRINT);
+        sb.append("\nHOST               :").append(Build.HOST);
+        sb.append("\nTAGS               :").append(Build.TAGS);
+        sb.append("\nTYPE               :").append(Build.TYPE);
+        sb.append("\nTIME               :").append(Build.TIME);
+        sb.append("\nINCREMENTAL        :").append(Build.VERSION.INCREMENTAL);
+
+        sb.append("\n_______ CUPCAKE-3 _______");
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.CUPCAKE) {
+            sb.append("\nDISPLAY            :").append(Build.DISPLAY);
+        }
+
+        sb.append("\n_______ DONUT-4 _______");
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT) {
+            sb.append("\nSDK_INT            :").append(Build.VERSION.SDK_INT);
+            sb.append("\nMANUFACTURER       :").append(Build.MANUFACTURER);
+            sb.append("\nBOOTLOADER         :").append(Build.BOOTLOADER);
+            sb.append("\nCPU_ABI            :").append(Build.CPU_ABI);
+            sb.append("\nCPU_ABI2           :").append(Build.CPU_ABI2);
+            sb.append("\nHARDWARE           :").append(Build.HARDWARE);
+            sb.append("\nUNKNOWN            :").append(Build.UNKNOWN);
+            sb.append("\nCODENAME           :").append(Build.VERSION.CODENAME);
+        }
+
+        sb.append("\n_______ GINGERBREAD-9 _______");
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            sb.append("\nSERIAL             :").append(Build.SERIAL);
+        }
+        Log.i(TAG, sb.toString());
+        return sb.toString();
+    }
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/view/widget/HorizontalProgressWheelView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/view/widget/HorizontalProgressWheelView.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/view/widget/HorizontalProgressWheelView.java	(revision )
@@ -0,0 +1,141 @@
+package com.yalantis.ucrop.view.widget;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+import android.view.View;
+
+import com.yalantis.ucrop.R;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ */
+public class HorizontalProgressWheelView extends View {
+
+    private final Rect mCanvasClipBounds = new Rect();
+
+    private ScrollingListener mScrollingListener;
+    private float mLastTouchedPosition;
+
+    private Paint mProgressLinePaint;
+    private int mProgressLineWidth, mProgressLineHeight;
+    private int mProgressLineMargin;
+
+    private boolean mScrollStarted;
+    private float mTotalScrollDistance;
+
+    public HorizontalProgressWheelView(Context context) {
+        this(context, null);
+    }
+
+    public HorizontalProgressWheelView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public HorizontalProgressWheelView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init();
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public HorizontalProgressWheelView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+    }
+
+    public void setScrollingListener(ScrollingListener scrollingListener) {
+        mScrollingListener = scrollingListener;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                mLastTouchedPosition = event.getX();
+                break;
+            case MotionEvent.ACTION_UP:
+                if (mScrollingListener != null) {
+                    mScrollStarted = false;
+                    mScrollingListener.onScrollEnd();
+                }
+                break;
+            case MotionEvent.ACTION_MOVE:
+                float distance = event.getX() - mLastTouchedPosition;
+                if (distance != 0) {
+                    if (!mScrollStarted) {
+                        mScrollStarted = true;
+                        if (mScrollingListener != null) {
+                            mScrollingListener.onScrollStart();
+                        }
+                    }
+                    onScrollEvent(event, distance);
+                }
+                break;
+        }
+        return true;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        canvas.getClipBounds(mCanvasClipBounds);
+
+        int linesCount = mCanvasClipBounds.width() / (mProgressLineWidth + mProgressLineMargin);
+        float deltaX = (mTotalScrollDistance) % (float) (mProgressLineMargin + mProgressLineWidth);
+
+        mProgressLinePaint.setColor(getResources().getColor(R.color.ucrop_color_progress_wheel_line));
+        for (int i = 0; i < linesCount; i++) {
+            if (i < (linesCount / 4)) {
+                mProgressLinePaint.setAlpha((int) (255 * (i / (float) (linesCount / 4))));
+            } else if (i > (linesCount * 3 / 4)) {
+                mProgressLinePaint.setAlpha((int) (255 * ((linesCount - i) / (float) (linesCount / 4))));
+            } else {
+                mProgressLinePaint.setAlpha(255);
+            }
+            canvas.drawLine(
+                    -deltaX + mCanvasClipBounds.left + i * (mProgressLineWidth + mProgressLineMargin),
+                    mCanvasClipBounds.centerY() - mProgressLineHeight / 4.0f,
+                    -deltaX + mCanvasClipBounds.left + i * (mProgressLineWidth + mProgressLineMargin),
+                    mCanvasClipBounds.centerY() + mProgressLineHeight / 4.0f, mProgressLinePaint);
+        }
+
+        mProgressLinePaint.setColor(getResources().getColor(R.color.ucrop_color_widget_active));
+        canvas.drawLine(mCanvasClipBounds.centerX(), mCanvasClipBounds.centerY() - mProgressLineHeight / 2.0f, mCanvasClipBounds.centerX(), mCanvasClipBounds.centerY() + mProgressLineHeight / 2.0f, mProgressLinePaint);
+
+    }
+
+    private void onScrollEvent(MotionEvent event, float distance) {
+        mTotalScrollDistance -= distance;
+        postInvalidate();
+        mLastTouchedPosition = event.getX();
+        if (mScrollingListener != null) {
+            mScrollingListener.onScroll(-distance, mTotalScrollDistance);
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    private void init() {
+
+        mProgressLineWidth = getContext().getResources().getDimensionPixelSize(R.dimen.ucrop_width_horizontal_wheel_progress_line);
+        mProgressLineHeight = getContext().getResources().getDimensionPixelSize(R.dimen.ucrop_height_horizontal_wheel_progress_line);
+        mProgressLineMargin = getContext().getResources().getDimensionPixelSize(R.dimen.ucrop_margin_horizontal_wheel_progress_line);
+
+        mProgressLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mProgressLinePaint.setStyle(Paint.Style.STROKE);
+        mProgressLinePaint.setStrokeWidth(mProgressLineWidth);
+    }
+
+    public interface ScrollingListener {
+
+        void onScrollStart();
+
+        void onScroll(float delta, float totalDistance);
+
+        void onScrollEnd();
+    }
+
+}
Index: app/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/styles.xml	(revision )
+++ app/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,36 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="AppTheme.Base"></style>
+
+    <style name="AppTheme.Base" parent="Theme.AppCompat">
+        <item name="windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+        <!-- Actionbar color -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <!--Status bar color-->
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <!--Window color-->
+        <item name="android:windowBackground">@color/white</item>
+    </style>
+
+    <!--tab的配置属性-->
+    <style name="CustomTabPageIndicator.Text" parent="android:TextAppearance.Medium">
+        <item name="android:typeface">monospace</item>
+    </style>
+    <style name="pagertab_icon_style">
+        <item name="android:background">@drawable/tab_bg_normal</item>
+        <item name="tabBackground">@drawable/tab_bg_normal</item>
+        <item name="android:textSize">11sp</item>
+        <item name="android:textColor">@drawable/tab_color_select</item>
+        <item name="android:textAppearance">@style/CustomTabPageIndicator.Text</item>
+        <item name="tabViewIndicatorColor">@android:color/transparent</item>
+        <item name="tabViewUnderlineColor">#1A000000</item>
+        <item name="tabViewDividerColor">#00000000</item>
+        <item name="tabViewShouldExpand">false</item>
+        <item name="tabViewPaddingLeftRight">8dp</item>
+        <item name="tabViewPaddingTopBottom">6dp</item>
+        <item name="tabViewTextSelectColor">@color/home_bar_text_push</item>
+    </style>
+
+</resources>
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradle.properties	(revision )
+++ gradle.properties	(revision )
@@ -0,0 +1,17 @@
+## Project-wide Gradle settings.
+#
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+#
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+#
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+#Thu Jan 28 15:05:42 CST 2016
+systemProp.http.proxyHost=mirrors.opencas.org
+systemProp.http.proxyPort=80
Index: ucrop/src/main/res/drawable/ucrop_shadow_upside.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/drawable/ucrop_shadow_upside.xml	(revision )
+++ ucrop/src/main/res/drawable/ucrop_shadow_upside.xml	(revision )
@@ -0,0 +1,7 @@
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+       android:shape="rectangle">
+    <gradient
+        android:angle="270"
+        android:endColor="#14232323"
+        android:startColor="@android:color/transparent"/>
+</shape>
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/tab/APSTSViewPager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/tab/APSTSViewPager.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/tab/APSTSViewPager.java	(revision )
@@ -0,0 +1,42 @@
+package com.scene.mylib.view.tab;
+
+import android.content.Context;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+/**
+ * Created by scene on 2015/8/10.
+ */
+public class APSTSViewPager extends ViewPager {
+    private boolean mNoFocus = false; //if true, keep View don't move
+
+    public APSTSViewPager(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public APSTSViewPager(Context context) {
+        this(context, null);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent arg0) {
+        /* return false;//super.onTouchEvent(arg0); */
+        if (mNoFocus)
+            return false;
+        else
+            return super.onTouchEvent(arg0);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent arg0) {
+        if (mNoFocus)
+            return false;
+        else
+            return super.onInterceptTouchEvent(arg0);
+    }
+
+    public void setNoFocus(boolean b) {
+        mNoFocus = b;
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/data/cipher/Decrypt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/data/cipher/Decrypt.java	(revision )
+++ common/src/main/java/com/scene/common/common/data/cipher/Decrypt.java	(revision )
@@ -0,0 +1,9 @@
+package com.scene.common.common.data.cipher;
+
+/**
+ * @author MaTianyu
+ * @date 14-7-31
+ */
+public interface Decrypt {
+    public byte[] decrypt(byte[] res);
+}
Index: common/src/main/java/com/scene/common/android/async/AsyncExecutor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/android/async/AsyncExecutor.java	(revision )
+++ common/src/main/java/com/scene/common/android/async/AsyncExecutor.java	(revision )
@@ -0,0 +1,126 @@
+package com.scene.common.android.async;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import com.scene.common.android.log.Log;
+
+import java.util.concurrent.*;
+
+/**
+ * 异步执行
+ *
+ * @author scene
+ */
+public class AsyncExecutor {
+    private static final String TAG = AsyncExecutor.class.getSimpleName();
+    private static ExecutorService threadPool;
+    public static Handler handler = new Handler(Looper.getMainLooper());
+
+    public AsyncExecutor() {
+        this(null);
+    }
+
+    public AsyncExecutor(ExecutorService threadPool) {
+        if (AsyncExecutor.threadPool != null) {
+            shutdownNow();
+        }
+        if (threadPool == null) {
+            AsyncExecutor.threadPool = Executors.newCachedThreadPool();
+        } else {
+            AsyncExecutor.threadPool = threadPool;
+        }
+    }
+
+    public static synchronized void shutdownNow() {
+        if (threadPool != null && !threadPool.isShutdown()) threadPool.shutdownNow();
+        threadPool = null;
+    }
+
+    /**
+     * 将任务投入线程池执行
+     *
+     * @param worker
+     * @return
+     */
+    public <T> FutureTask<T> execute(final Worker<T> worker) {
+        Callable<T> call = new Callable<T>() {
+            @Override
+            public T call() throws Exception {
+                return postResult(worker, worker.doInBackground());
+            }
+        };
+        FutureTask<T> task = new FutureTask<T>(call) {
+            @Override
+            protected void done() {
+                try {
+                    get();
+                } catch (InterruptedException e) {
+                    Log.e(TAG, e);
+                    worker.abort();
+                    postCancel(worker);
+                    e.printStackTrace();
+                } catch (ExecutionException e) {
+                    Log.e(TAG, e.getMessage());
+                    e.printStackTrace();
+                    throw new RuntimeException("An error occured while executing doInBackground()", e.getCause());
+                } catch (CancellationException e) {
+                    worker.abort();
+                    postCancel(worker);
+                    Log.e(TAG, e);
+                    e.printStackTrace();
+                }
+            }
+        };
+        threadPool.execute(task);
+        return task;
+    }
+
+    /**
+     * 将子线程结果传递到UI线程
+     *
+     * @param worker
+     * @param result
+     * @return
+     */
+    private <T> T postResult(final Worker<T> worker, final T result) {
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                worker.onPostExecute(result);
+            }
+        });
+        return result;
+    }
+
+    /**
+     * 将子线程结果传递到UI线程
+     *
+     * @param worker
+     * @return
+     */
+    private void postCancel(final Worker worker) {
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                worker.onCanceled();
+            }
+        });
+    }
+
+    public <T> FutureTask<T> execute(Callable<T> call) {
+        FutureTask<T> task = new FutureTask<T>(call);
+        threadPool.execute(task);
+        return task;
+    }
+
+    public static abstract class Worker<T> {
+        protected abstract T doInBackground();
+
+        protected void onPostExecute(T data) {}
+
+        protected void onCanceled() {}
+
+        protected void abort() {}
+    }
+}
Index: app/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/.gitignore	(revision )
+++ app/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: common/src/main/java/com/scene/common/common/utils/DialogUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/DialogUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/DialogUtil.java	(revision )
@@ -0,0 +1,73 @@
+package com.scene.common.common.utils;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.text.Html;
+import android.view.View;
+
+public class DialogUtil {
+
+    public static AlertDialog.Builder dialogBuilder(Context context, String title, String msg) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        if (msg != null) {
+            builder.setMessage(msg);
+        }
+        if (title != null) {
+            builder.setTitle(title);
+        }
+        return builder;
+    }
+
+    public static AlertDialog.Builder dialogBuilder(Context context, String title, String msg, int i) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        if (msg != null) {
+            builder.setMessage(Html.fromHtml(msg));
+        }
+        if (title != null) {
+            builder.setTitle(title);
+        }
+        return builder;
+    }
+
+
+    public static AlertDialog.Builder dialogBuilder(Context context, int title, View view) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        if (view != null) {
+            builder.setView(view);
+        }
+        if (title > 0) {
+            builder.setTitle(title);
+        }
+        return builder;
+    }
+
+    public static AlertDialog.Builder dialogBuilder(Context context, int titleResId, int msgResId) {
+        String title = titleResId > 0 ? context.getResources().getString(titleResId) : null;
+        String msg = msgResId > 0 ? context.getResources().getString(msgResId) : null;
+        return dialogBuilder(context, title, msg);
+    }
+
+    public static Dialog showTips(Context context, String title, String des) {
+        return showTips(context, title, des, null, null);
+    }
+
+    public static Dialog showTips(Context context, int title, int des) {
+        return showTips(context, context.getString(title), context.getString(des));
+    }
+
+    public static Dialog showTips(Context context, int title, int des, int btn, DialogInterface.OnDismissListener dismissListener) {
+        return showTips(context, context.getString(title), context.getString(des), context.getString(btn), dismissListener);
+    }
+
+    public static Dialog showTips(Context context, String title, String des, String btn, DialogInterface.OnDismissListener dismissListener) {
+        AlertDialog.Builder builder = dialogBuilder(context, title, des);
+        builder.setCancelable(true);
+        builder.setPositiveButton(btn, null);
+        Dialog dialog = builder.show();
+        dialog.setCanceledOnTouchOutside(true);
+        dialog.setOnDismissListener(dismissListener);
+        return dialog;
+    }
+}
Index: easypermissions/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/src/main/res/values/strings.xml	(revision )
+++ easypermissions/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">EasyPermissions</string>
+</resources>
Index: app/src/main/res/layout/activity_select_and_crop_image.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_select_and_crop_image.xml	(revision )
+++ app/src/main/res/layout/activity_select_and_crop_image.xml	(revision )
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    tools:context=".ui.activity.SelectAndCropImageActivity">
+
+    <android.support.v7.widget.Toolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="?attr/actionBarSize"
+        android:background="?attr/colorPrimary"
+        android:navigationIcon="?android:attr/backupAgent"
+        app:navigationIcon="?attr/homeAsUpIndicator"/>
+
+    <ScrollView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+
+            <Button
+                android:id="@+id/galley"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="相册"/>
+
+            <Button
+                android:id="@+id/camera"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="相机"/>
+
+            <Button
+                android:id="@+id/galleyCrop"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="相册裁剪"/>
+
+            <Button
+                android:id="@+id/cameraCrop"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="相机裁剪"/>
+
+            <ImageView
+                android:id="@+id/img"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:padding="10dp"/>
+        </LinearLayout>
+    </ScrollView>
+
+
+</LinearLayout>
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision )
+++ app/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,6 @@
+<resources>
+    <string name="app_name">SceneAndroidDemo</string>
+
+    <string name="camera_permission">需要相机权限</string>
+    <string name="storage_permission">需要存储空间权限</string>
+</resources>
Index: app/src/test/java/com/scene/sceneandroiddemo/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/test/java/com/scene/sceneandroiddemo/ExampleUnitTest.java	(revision )
+++ app/src/test/java/com/scene/sceneandroiddemo/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.scene.sceneandroiddemo;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/receiver/SmsReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/receiver/SmsReceiver.java	(revision )
+++ common/src/main/java/com/scene/common/common/receiver/SmsReceiver.java	(revision )
@@ -0,0 +1,144 @@
+package com.scene.common.common.receiver;
+
+import android.content.*;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import com.scene.common.android.log.Log;
+
+import java.util.List;
+
+/**
+ * Call requires API level 4
+ * <uses-permission android:name="android.permission.RECEIVE_SMS"/>
+ * <p/>
+ * action: android.provider.Telephony.SMS_RECEIVED
+ *
+ * @author MaTianyu
+ * @date 14-7-23
+ */
+public class SmsReceiver extends BroadcastReceiver {
+    private static final String TAG = SmsReceiver.class.getSimpleName();
+    private SmsListener smsListener;
+
+    public SmsReceiver() {
+
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        try {
+            if (Log.isPrint) {
+                Log.i(TAG, "收到广播：" + intent.getAction());
+                Bundle bundle = intent.getExtras();
+                for (String key : bundle.keySet()) {
+                    Log.i(TAG, key + " : " + bundle.get(key));
+                }
+            }
+            Object[] pdus = (Object[]) intent.getExtras().get("pdus");
+            String fromAddress = null;
+            String serviceCenterAddress = null;
+            if (pdus != null) {
+                String msgBody = "";
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT) {
+                    for (Object obj : pdus) {
+                        SmsMessage sms = SmsMessage.createFromPdu((byte[]) obj);
+                        msgBody += sms.getMessageBody();
+                        fromAddress = sms.getOriginatingAddress();
+                        serviceCenterAddress = sms.getServiceCenterAddress();
+
+                        if (smsListener != null) {
+                            smsListener.onMessage(sms);
+                        }
+                        //Log.i(TAG, "getDisplayMessageBody：" + sms.getDisplayMessageBody());
+                        //Log.i(TAG, "getDisplayOriginatingAddress：" + sms.getDisplayOriginatingAddress());
+                        //Log.i(TAG, "getEmailBody：" + sms.getEmailBody());
+                        //Log.i(TAG, "getEmailFrom：" + sms.getEmailFrom());
+                        //Log.i(TAG, "getMessageBody：" + sms.getMessageBody());
+                        //Log.i(TAG, "getOriginatingAddress：" + sms.getOriginatingAddress());
+                        //Log.i(TAG, "getPseudoSubject：" + sms.getPseudoSubject());
+                        //Log.i(TAG, "getServiceCenterAddress：" + sms.getServiceCenterAddress());
+                        //Log.i(TAG, "getIndexOnIcc：" + sms.getIndexOnIcc());
+                        //Log.i(TAG, "getMessageClass：" + sms.getMessageClass());
+                        //Log.i(TAG, "getUserData：" + new String(sms.getUserData()));
+                    }
+                }
+                if (smsListener != null) {
+                    smsListener.onMessage(msgBody, fromAddress, serviceCenterAddress);
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void registerSmsReceiver(Context context, SmsListener smsListener) {
+        try {
+            this.smsListener = smsListener;
+            IntentFilter filter = new IntentFilter();
+            filter.addAction("android.provider.Telephony.SMS_RECEIVED");
+            filter.setPriority(Integer.MAX_VALUE);
+            context.registerReceiver(this, filter);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void unRegisterSmsReceiver(Context context) {
+        try {
+            context.unregisterReceiver(this);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static abstract class SmsListener {
+        public abstract void onMessage(String msg, String fromAddress, String serviceCenterAddress);
+
+        public void onMessage(SmsMessage msg) {}
+    }
+
+    /**
+     * Call requires API level 4
+     * <uses-permission android:name="android.permission.SEND_SMS"/>
+     *
+     * @param phone
+     * @param msg
+     */
+    public static void sendMsgToPhone(String phone, String msg) {
+        Log.i(TAG, "发送手机：" + phone + " ,内容： " + msg);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT) {
+            SmsManager manager = SmsManager.getDefault();
+            List<String> texts = manager.divideMessage(msg);
+            for (String txt : texts) {
+                manager.sendTextMessage(phone, null, txt, null, null);
+            }
+        }else{
+            Log.e(TAG, "发送失败，系统版本低于DONUT，" + phone + " ,内容： " + msg);
+        }
+
+    }
+
+    /**
+     * Call requires API level 4
+     * <uses-permission android:name="android.permission.WRITE_SMS"/>
+     *
+     * @param context
+     * @param phone
+     * @param msg
+     */
+    public static void saveMsgToSystem(Context context, String phone, String msg) {
+        ContentValues values = new ContentValues();
+        values.put("date", System.currentTimeMillis());
+        //阅读状态 
+        values.put("read", 0);
+        //1为收 2为发  
+        values.put("type", 2);
+        values.put("address", phone);
+        values.put("body", msg);
+        context.getContentResolver().insert(Uri.parse("content://sms/inbox"), values);
+    }
+
+}
Index: settings.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- settings.gradle	(revision )
+++ settings.gradle	(revision )
@@ -0,0 +1,1 @@
+include ':app', ':mylib', ':chooseimagelib', ':ucrop', ':easypermissions', ':customfresco', ':timeline', ':common'
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/assist/SilentInstaller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/SilentInstaller.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/SilentInstaller.java	(revision )
@@ -0,0 +1,559 @@
+package com.scene.common.common.assist;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+import com.scene.common.common.utils.ShellUtil;
+
+import java.io.File;
+
+/**
+ * modify form Trinea
+ *
+ * @author trinea
+ * @date 2014-12-10
+ */
+public class SilentInstaller {
+    /**
+     * Installation return code<br/>
+     * install success.
+     */
+    public static final int INSTALL_SUCCEEDED             = 1;
+    /**
+     * Installation return code<br/>
+     * the package is already installed.
+     */
+    public static final int INSTALL_FAILED_ALREADY_EXISTS = -1;
+
+    /**
+     * Installation return code<br/>
+     * the package archive file is invalid.
+     */
+    public static final int INSTALL_FAILED_INVALID_APK = -2;
+
+    /**
+     * Installation return code<br/>
+     * the URI passed in is invalid.
+     */
+    public static final int INSTALL_FAILED_INVALID_URI = -3;
+
+    /**
+     * Installation return code<br/>
+     * the package manager service found that the device didn't have enough storage space to install the app.
+     */
+    public static final int INSTALL_FAILED_INSUFFICIENT_STORAGE = -4;
+
+    /**
+     * Installation return code<br/>
+     * a package is already installed with the same name.
+     */
+    public static final int INSTALL_FAILED_DUPLICATE_PACKAGE = -5;
+
+    /**
+     * Installation return code<br/>
+     * the requested shared user does not exist.
+     */
+    public static final int INSTALL_FAILED_NO_SHARED_USER = -6;
+
+    /**
+     * Installation return code<br/>
+     * a previously installed package of the same name has a different signature than the new package (and the old
+     * package's data was not removed).
+     */
+    public static final int INSTALL_FAILED_UPDATE_INCOMPATIBLE = -7;
+
+    /**
+     * Installation return code<br/>
+     * the new package is requested a shared user which is already installed on the device and does not have matching
+     * signature.
+     */
+    public static final int INSTALL_FAILED_SHARED_USER_INCOMPATIBLE = -8;
+
+    /**
+     * Installation return code<br/>
+     * the new package uses a shared library that is not available.
+     */
+    public static final int INSTALL_FAILED_MISSING_SHARED_LIBRARY = -9;
+
+    /**
+     * Installation return code<br/>
+     * the new package uses a shared library that is not available.
+     */
+    public static final int INSTALL_FAILED_REPLACE_COULDNT_DELETE = -10;
+
+    /**
+     * Installation return code<br/>
+     * the new package failed while optimizing and validating its dex files, either because there was not enough storage
+     * or the validation failed.
+     */
+    public static final int INSTALL_FAILED_DEXOPT = -11;
+
+    /**
+     * Installation return code<br/>
+     * the new package failed because the current SDK version is older than that required by the package.
+     */
+    public static final int INSTALL_FAILED_OLDER_SDK = -12;
+
+    /**
+     * Installation return code<br/>
+     * the new package failed because it contains a content provider with the same authority as a provider already
+     * installed in the system.
+     */
+    public static final int INSTALL_FAILED_CONFLICTING_PROVIDER = -13;
+
+    /**
+     * Installation return code<br/>
+     * the new package failed because the current SDK version is newer than that required by the package.
+     */
+    public static final int INSTALL_FAILED_NEWER_SDK = -14;
+
+    /**
+     * Installation return code<br/>
+     * the new package failed because it has specified that it is a test-only package and the caller has not supplied
+     * the {@link #INSTALL_ALLOW_TEST} flag.
+     */
+    public static final int INSTALL_FAILED_TEST_ONLY = -15;
+
+    /**
+     * Installation return code<br/>
+     * the package being installed contains native code, but none that is compatible with the the device's CPU_ABI.
+     */
+    public static final int INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -16;
+
+    /**
+     * Installation return code<br/>
+     * the new package uses a feature that is not available.
+     */
+    public static final int INSTALL_FAILED_MISSING_FEATURE = -17;
+
+    /**
+     * Installation return code<br/>
+     * a secure container mount point couldn't be accessed on external media.
+     */
+    public static final int INSTALL_FAILED_CONTAINER_ERROR = -18;
+
+    /**
+     * Installation return code<br/>
+     * the new package couldn't be installed in the specified install location.
+     */
+    public static final int INSTALL_FAILED_INVALID_INSTALL_LOCATION = -19;
+
+    /**
+     * Installation return code<br/>
+     * the new package couldn't be installed in the specified install location because the media is not available.
+     */
+    public static final int INSTALL_FAILED_MEDIA_UNAVAILABLE = -20;
+
+    /**
+     * Installation return code<br/>
+     * the new package couldn't be installed because the verification timed out.
+     */
+    public static final int INSTALL_FAILED_VERIFICATION_TIMEOUT = -21;
+
+    /**
+     * Installation return code<br/>
+     * the new package couldn't be installed because the verification did not succeed.
+     */
+    public static final int INSTALL_FAILED_VERIFICATION_FAILURE = -22;
+
+    /**
+     * Installation return code<br/>
+     * the package changed from what the calling program expected.
+     */
+    public static final int INSTALL_FAILED_PACKAGE_CHANGED = -23;
+
+    /**
+     * Installation return code<br/>
+     * the new package is assigned a different UID than it previously held.
+     */
+    public static final int INSTALL_FAILED_UID_CHANGED = -24;
+
+    /**
+     * Installation return code<br/>
+     * if the parser was given a path that is not a file, or does not end with the expected '.apk' extension.
+     */
+    public static final int INSTALL_PARSE_FAILED_NOT_APK = -100;
+
+    /**
+     * Installation return code<br/>
+     * if the parser was unable to retrieve the AndroidManifest.xml file.
+     */
+    public static final int INSTALL_PARSE_FAILED_BAD_MANIFEST = -101;
+
+    /**
+     * Installation return code<br/>
+     * if the parser encountered an unexpected exception.
+     */
+    public static final int INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION = -102;
+
+    /**
+     * Installation return code<br/>
+     * if the parser did not find any certificates in the .apk.
+     */
+    public static final int INSTALL_PARSE_FAILED_NO_CERTIFICATES = -103;
+
+    /**
+     * Installation return code<br/>
+     * if the parser found inconsistent certificates on the files in the .apk.
+     */
+    public static final int INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES = -104;
+
+    /**
+     * Installation return code<br/>
+     * if the parser encountered a CertificateEncodingException in one of the files in the .apk.
+     */
+    public static final int INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING = -105;
+
+    /**
+     * Installation return code<br/>
+     * if the parser encountered a bad or missing package name in the manifest.
+     */
+    public static final int INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME = -106;
+
+    /**
+     * Installation return code<br/>
+     * if the parser encountered a bad shared user id name in the manifest.
+     */
+    public static final int INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID = -107;
+
+    /**
+     * Installation return code<br/>
+     * if the parser encountered some structural problem in the manifest.
+     */
+    public static final int INSTALL_PARSE_FAILED_MANIFEST_MALFORMED = -108;
+
+    /**
+     * Installation return code<br/>
+     * if the parser did not find any actionable tags (instrumentation or application) in the manifest.
+     */
+    public static final int INSTALL_PARSE_FAILED_MANIFEST_EMPTY = -109;
+
+    /**
+     * Installation return code<br/>
+     * if the system failed to install the package because of system issues.
+     */
+    public static final int INSTALL_FAILED_INTERNAL_ERROR = -110;
+    /**
+     * Installation return code<br/>
+     * other reason
+     */
+    public static final int INSTALL_FAILED_OTHER          = -1000000;
+
+    /**
+     * Uninstall return code<br/>
+     * uninstall success.
+     */
+    public static final int DELETE_SUCCEEDED = 1;
+
+    /**
+     * Uninstall return code<br/>
+     * uninstall fail if the system failed to delete the package for an unspecified reason.
+     */
+    public static final int DELETE_FAILED_INTERNAL_ERROR = -1;
+
+    /**
+     * Uninstall return code<br/>
+     * uninstall fail if the system failed to delete the package because it is the active DevicePolicy manager.
+     */
+    public static final int DELETE_FAILED_DEVICE_POLICY_MANAGER = -2;
+
+    /**
+     * Uninstall return code<br/>
+     * uninstall fail if pcakge name is invalid
+     */
+    public static final int DELETE_FAILED_INVALID_PACKAGE = -3;
+
+    /**
+     * Uninstall return code<br/>
+     * uninstall fail if permission denied
+     */
+    public static final int DELETE_FAILED_PERMISSION_DENIED = -4;
+
+    private static final String TAG = SilentInstaller.class.getSimpleName();
+
+    /**
+     * App installation location flags of android system
+     */
+    public static final int APP_INSTALL_AUTO     = 0;
+    public static final int APP_INSTALL_INTERNAL = 1;
+    public static final int APP_INSTALL_EXTERNAL = 2;
+
+    /**
+     * uninstall package and clear data of app silent by root
+     *
+     * @param context
+     * @param packageName package name of app
+     * @return
+     * @see #uninstallSilent(Context, String, boolean)
+     */
+    public int uninstallSilent(Context context, String packageName) {
+        return uninstallSilent(context, packageName, false);
+    }
+
+    /**
+     * uninstall package silent by root
+     * <ul>
+     * <strong>Attentions:</strong>
+     * <li>Don't call this on the ui thread, it may costs some times.</li>
+     * <li>You should add <strong>android.permission.DELETE_PACKAGES</strong> in manifest, so no need to request root
+     * permission, if you are system app.</li>
+     * </ul>
+     *
+     * @param context     file path of package
+     * @param packageName package name of app
+     * @param isKeepData  whether keep the data and cache directories around after package removal
+     * @return <ul>
+     * <li>{@link #DELETE_SUCCEEDED} means uninstall success</li>
+     * <li>{@link #DELETE_FAILED_INTERNAL_ERROR} means internal error</li>
+     * <li>{@link #DELETE_FAILED_INVALID_PACKAGE} means package name error</li>
+     * <li>{@link #DELETE_FAILED_PERMISSION_DENIED} means permission denied</li>
+     */
+    public int uninstallSilent(Context context, String packageName, boolean isKeepData) {
+        if (packageName == null || packageName.length() == 0) {
+            return DELETE_FAILED_INVALID_PACKAGE;
+        }
+
+        /**
+         * if context is system app, don't need root permission, but should add <uses-permission
+         * android:name="android.permission.DELETE_PACKAGES" /> in mainfest
+         **/
+        StringBuilder command = new StringBuilder().append("LD_LIBRARY_PATH=/vendor/lib:/system/lib pm uninstall")
+                .append(isKeepData ? " -k " : " ").append(packageName.replace(" ", "\\ "));
+        ShellUtil.CommandResult commandResult = ShellUtil.execCommand(command.toString(), !isSystemApplication(context), true);
+        if (commandResult.responseMsg != null
+                && (commandResult.responseMsg.contains("Success") || commandResult.responseMsg.contains("success"))) {
+            return DELETE_SUCCEEDED;
+        }
+        Log.e(TAG,
+                new StringBuilder().append("uninstallSilent successMsg:").append(commandResult.responseMsg)
+                        .append(", ErrorMsg:").append(commandResult.errorMsg).toString());
+        if (commandResult.errorMsg == null) {
+            return DELETE_FAILED_INTERNAL_ERROR;
+        }
+        if (commandResult.errorMsg.contains("Permission denied")) {
+            return DELETE_FAILED_PERMISSION_DENIED;
+        }
+        return DELETE_FAILED_INTERNAL_ERROR;
+    }
+
+    /**
+     * install package silent by root
+     * <ul>
+     * <strong>Attentions:</strong>
+     * <li>Don't call this on the ui thread, it may costs some times.</li>
+     * <li>You should add <strong>android.permission.INSTALL_PACKAGES</strong> in manifest, so no need to request root
+     * permission, if you are system app.</li>
+     * <li>Default pm install params is "-r".</li>
+     * </ul>
+     *
+     * @param context
+     * @param filePath file path of package
+     * @see #installSilent(Context, String, String)
+     */
+    public int installSilent(Context context, String filePath) {
+        return installSilent(context, filePath, " -r " + getInstallLocationParams());
+    }
+
+    /**
+     * * install package silent by root
+     * <ul>
+     * <strong>Attentions:</strong>
+     * <li>Don't call this on the ui thread, it may costs some times.</li>
+     * <li>You should add <strong>android.permission.INSTALL_PACKAGES</strong> in manifest, so no need to request root
+     * permission, if you are system app.</li>
+     * </ul>
+     */
+    public int installSilent(Context context, String filePath, String pmParams) {
+        if (filePath == null || filePath.length() == 0) {
+            return INSTALL_FAILED_INVALID_URI;
+        }
+
+        File file = new File(filePath);
+        if (file == null || file.length() <= 0 || !file.exists() || !file.isFile()) {
+            return INSTALL_FAILED_INVALID_URI;
+        }
+
+        /**
+         * if context is system app, don't need root permission, but should add <uses-permission
+         * android:name="android.permission.INSTALL_PACKAGES" /> in mainfest
+         **/
+        StringBuilder command = new StringBuilder().append("LD_LIBRARY_PATH=/vendor/lib:/system/lib pm install ")
+                .append(pmParams == null ? "" : pmParams).append(" ").append(filePath.replace(" ", "\\ "));
+        ShellUtil.CommandResult commandResult = ShellUtil.execCommand(command.toString(),
+                !isSystemApplication(context), true);
+        if (commandResult.responseMsg != null
+                && (commandResult.responseMsg.contains("Success") || commandResult.responseMsg.contains("success"))) {
+            return INSTALL_SUCCEEDED;
+        }
+
+        Log.e(TAG,
+                new StringBuilder().append("installSilent successMsg:").append(commandResult.responseMsg)
+                        .append(", ErrorMsg:").append(commandResult.errorMsg).toString());
+        if (commandResult.errorMsg == null) {
+            return INSTALL_FAILED_OTHER;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_ALREADY_EXISTS")) {
+            return INSTALL_FAILED_ALREADY_EXISTS;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_INVALID_APK")) {
+            return INSTALL_FAILED_INVALID_APK;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_INVALID_URI")) {
+            return INSTALL_FAILED_INVALID_URI;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_INSUFFICIENT_STORAGE")) {
+            return INSTALL_FAILED_INSUFFICIENT_STORAGE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_DUPLICATE_PACKAGE")) {
+            return INSTALL_FAILED_DUPLICATE_PACKAGE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_NO_SHARED_USER")) {
+            return INSTALL_FAILED_NO_SHARED_USER;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_UPDATE_INCOMPATIBLE")) {
+            return INSTALL_FAILED_UPDATE_INCOMPATIBLE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_SHARED_USER_INCOMPATIBLE")) {
+            return INSTALL_FAILED_SHARED_USER_INCOMPATIBLE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_MISSING_SHARED_LIBRARY")) {
+            return INSTALL_FAILED_MISSING_SHARED_LIBRARY;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_REPLACE_COULDNT_DELETE")) {
+            return INSTALL_FAILED_REPLACE_COULDNT_DELETE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_DEXOPT")) {
+            return INSTALL_FAILED_DEXOPT;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_OLDER_SDK")) {
+            return INSTALL_FAILED_OLDER_SDK;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_CONFLICTING_PROVIDER")) {
+            return INSTALL_FAILED_CONFLICTING_PROVIDER;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_NEWER_SDK")) {
+            return INSTALL_FAILED_NEWER_SDK;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_TEST_ONLY")) {
+            return INSTALL_FAILED_TEST_ONLY;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_CPU_ABI_INCOMPATIBLE")) {
+            return INSTALL_FAILED_CPU_ABI_INCOMPATIBLE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_MISSING_FEATURE")) {
+            return INSTALL_FAILED_MISSING_FEATURE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_CONTAINER_ERROR")) {
+            return INSTALL_FAILED_CONTAINER_ERROR;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_INVALID_INSTALL_LOCATION")) {
+            return INSTALL_FAILED_INVALID_INSTALL_LOCATION;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_MEDIA_UNAVAILABLE")) {
+            return INSTALL_FAILED_MEDIA_UNAVAILABLE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_VERIFICATION_TIMEOUT")) {
+            return INSTALL_FAILED_VERIFICATION_TIMEOUT;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_VERIFICATION_FAILURE")) {
+            return INSTALL_FAILED_VERIFICATION_FAILURE;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_PACKAGE_CHANGED")) {
+            return INSTALL_FAILED_PACKAGE_CHANGED;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_UID_CHANGED")) {
+            return INSTALL_FAILED_UID_CHANGED;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_NOT_APK")) {
+            return INSTALL_PARSE_FAILED_NOT_APK;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_BAD_MANIFEST")) {
+            return INSTALL_PARSE_FAILED_BAD_MANIFEST;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION")) {
+            return INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_NO_CERTIFICATES")) {
+            return INSTALL_PARSE_FAILED_NO_CERTIFICATES;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES")) {
+            return INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING")) {
+            return INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME")) {
+            return INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID")) {
+            return INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_MANIFEST_MALFORMED")) {
+            return INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_PARSE_FAILED_MANIFEST_EMPTY")) {
+            return INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
+        }
+        if (commandResult.errorMsg.contains("INSTALL_FAILED_INTERNAL_ERROR")) {
+            return INSTALL_FAILED_INTERNAL_ERROR;
+        }
+        return INSTALL_FAILED_OTHER;
+    }
+
+
+    /**
+     * 获取当前系统安装应用的默认位置
+     *
+     * @return APP_INSTALL_AUTO or APP_INSTALL_INTERNAL or APP_INSTALL_EXTERNAL.
+     */
+    public int getInstallLocation() {
+        ShellUtil.CommandResult commandResult = ShellUtil.execCommand(
+                "LD_LIBRARY_PATH=/vendor/lib:/system/lib pm get-install-location", false, true);
+        if (commandResult.result == 0 && commandResult.responseMsg != null && commandResult.responseMsg.length() > 0) {
+            try {
+                return Integer.parseInt(commandResult.responseMsg.substring(0, 1));
+            } catch (NumberFormatException e) {
+                e.printStackTrace();
+            }
+        }
+        return APP_INSTALL_AUTO;
+    }
+
+    /**
+     * get params for pm install location
+     *
+     * @return
+     */
+    private String getInstallLocationParams() {
+        int location = getInstallLocation();
+        switch (location) {
+            case APP_INSTALL_INTERNAL:
+                return "-f";
+            case APP_INSTALL_EXTERNAL:
+                return "-s";
+        }
+        return "";
+    }
+
+    /**
+     * /**
+     * whether packageName is system application
+     */
+    public boolean isSystemApplication(Context context) {
+        PackageManager packageManager = context.getPackageManager();
+        String packageName = context.getPackageName();
+        if (packageManager == null || packageName == null || packageName.length() == 0) {
+            return false;
+        }
+        try {
+            ApplicationInfo app = packageManager.getApplicationInfo(packageName, 0);
+            return (app != null && (app.flags & ApplicationInfo.FLAG_SYSTEM) > 0);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+}
Index: customfresco/src/main/java/com/scene/customfresco/zoomable/ZoomableController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/zoomable/ZoomableController.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/zoomable/ZoomableController.java	(revision )
@@ -0,0 +1,49 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.scene.customfresco.zoomable;
+
+import android.graphics.Matrix;
+import android.graphics.RectF;
+import android.view.MotionEvent;
+
+/**
+ * Interface for implementing a controller that works with {@link ZoomableDraweeView}
+ * to control the zoom.
+ */
+public interface ZoomableController {
+
+  /**
+   * Listener interface.
+   */
+  public interface Listener {
+
+    void onTransformChanged(Matrix transform);
+  }
+
+
+  void setEnabled(boolean enabled);
+
+  boolean isEnabled();
+
+  void setListener(Listener listener);
+
+  float getScaleFactor();
+
+  Matrix getTransform();
+
+  void setImageBounds(RectF imageBounds);
+
+  void setViewBounds(RectF viewBounds);
+
+  boolean onTouchEvent(MotionEvent event);
+}
Index: timeline/src/main/java/com/scene/timeline/LineType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/main/java/com/scene/timeline/LineType.java	(revision )
+++ timeline/src/main/java/com/scene/timeline/LineType.java	(revision )
@@ -0,0 +1,11 @@
+package com.scene.timeline;
+
+/**
+ * Created by HP-HP on 05-12-2015.
+ */
+public class LineType {
+    public static final int NORMAL = 0;
+    public static final int BEGIN = 1;
+    public static final int END = 2;
+    public static final int ONLYONE = 3;
+}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.gradle	(revision )
+++ build.gradle	(revision )
@@ -0,0 +1,23 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.5.0'
+
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
+
+task clean(type: Delete) {
+    delete rootProject.buildDir
+}
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/OnListLoadNextPageListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/OnListLoadNextPageListener.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/OnListLoadNextPageListener.java	(revision )
@@ -0,0 +1,17 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.view.View;
+
+/**
+ * Created by scene on 2015/10/9.
+ * RecyclerView/ListView/GridView 滑动加载下一页时的回调接口
+ */
+public interface OnListLoadNextPageListener {
+
+    /**
+     * 开始加载下一页
+     *
+     * @param view 当前RecyclerView/ListView/GridView
+     */
+    public void onLoadNextPage(View view);
+}
Index: chooseimagelib/src/main/res/layout/cropimage.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/res/layout/cropimage.xml	(revision )
+++ chooseimagelib/src/main/res/layout/cropimage.xml	(revision )
@@ -0,0 +1,58 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="horizontal">
+
+    <view
+        android:id="@+id/image"
+        class="com.scene.chooseimagelib.simplecropimage.CropImageView"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:layout_x="0dip"
+        android:layout_y="0dip"
+        android:background="#55000000" />
+
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_height="50dp"
+        android:layout_alignParentBottom="true"
+        android:layout_centerHorizontal="true"
+        android:orientation="horizontal"
+        android:paddingLeft="10dip"
+        android:paddingRight="10dip">
+
+
+        <Button
+            android:id="@+id/discard"
+            style="@style/CropButton"
+            android:layout_width="80dp"
+            android:layout_height="fill_parent"
+            android:layout_alignParentLeft="true"
+            android:text="@string/cancel" />
+
+        <ImageButton
+            android:id="@+id/rotateLeft"
+            style="@style/CropButton"
+            android:layout_width="50dp"
+            android:layout_height="fill_parent"
+            android:layout_toRightOf="@id/discard"
+            android:src="@drawable/ic_rotate_left" />
+
+        <ImageButton
+            android:id="@+id/rotateRight"
+            style="@style/CropButton"
+            android:layout_width="50dp"
+            android:layout_height="fill_parent"
+            android:layout_toRightOf="@id/rotateLeft"
+            android:src="@drawable/ic_rotate_right" />
+
+        <Button
+            android:id="@+id/save"
+            style="@style/CropButton"
+            android:layout_width="80dp"
+            android:layout_height="fill_parent"
+            android:layout_toRightOf="@id/rotateRight"
+            android:text="@string/save" />
+
+    </RelativeLayout>
+</RelativeLayout>
Index: common/src/main/java/com/scene/common/common/io/FilenameUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/FilenameUtils.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/FilenameUtils.java	(revision )
@@ -0,0 +1,1063 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * General filename and filepath manipulation utilities.
+ * <p>
+ * When dealing with filenames you can hit problems when moving from a Windows
+ * based development machine to a Unix based production machine.
+ * This class aims to help avoid those problems.
+ * <p>
+ * <b>NOTE</b>: You may be able to avoid using this class entirely simply by
+ * using JDK {@link File File} objects and the two argument constructor
+ * {@link File#File(File, String) File(File,String)}.
+ * <p>
+ * Most methods on this class are designed to work the same on both Unix and Windows.
+ * Those that don't include 'System', 'Unix' or 'Windows' in their name.
+ * <p>
+ * Most methods recognise both separators (forward and back), and both
+ * sets of prefixes. See the javadoc of each method for details.
+ * <p>
+ * This class defines six components within a filename
+ * (example C:\dev\project\file.txt):
+ * <ul>
+ * <li>the prefix - C:\</li>
+ * <li>the path - dev\project\</li>
+ * <li>the full path - C:\dev\project\</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
+ * Note that this class works best if directory filenames end with a separator.
+ * If you omit the last separator, it is impossible to determine if the filename
+ * corresponds to a file or a directory. As a result, we have chosen to say
+ * it corresponds to a file.
+ * <p>
+ * This class only supports Unix and Windows style names.
+ * Prefixes are matched as follows:
+ * <pre>
+ * Windows:
+ * a\b\c.txt           --> ""          --> relative
+ * \a\b\c.txt          --> "\"         --> current drive absolute
+ * C:a\b\c.txt         --> "C:"        --> drive relative
+ * C:\a\b\c.txt        --> "C:\"       --> absolute
+ * \\server\a\b\c.txt  --> "\\server\" --> UNC
+ *
+ * Unix:
+ * a/b/c.txt           --> ""          --> relative
+ * /a/b/c.txt          --> "/"         --> absolute
+ * ~/a/b/c.txt         --> "~/"        --> current user
+ * ~                   --> "~/"        --> current user (slash added)
+ * ~user/a/b/c.txt     --> "~user/"    --> named user
+ * ~user               --> "~user/"    --> named user (slash added)
+ * </pre>
+ * Both prefix styles are matched always, irrespective of the machine that you are
+ * currently running on.
+ * <p>
+ * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.
+ *
+ * @version $Id: FilenameUtils.java 1307462 2012-03-30 15:13:11Z ggregory $
+ * @since 1.1
+ */
+public class FilenameUtils {
+
+    /**
+     * The extension separator character.
+     * @since 1.4
+     */
+    public static final char EXTENSION_SEPARATOR = '.';
+
+    /**
+     * The extension separator String.
+     * @since 1.4
+     */
+    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);
+
+    /**
+     * The Unix separator character.
+     */
+    private static final char UNIX_SEPARATOR = '/';
+
+    /**
+     * The Windows separator character.
+     */
+    private static final char WINDOWS_SEPARATOR = '\\';
+
+    /**
+     * The system separator character.
+     */
+    private static final char SYSTEM_SEPARATOR = File.separatorChar;
+
+    /**
+     * The separator character that is the opposite of the system separator.
+     */
+    private static final char OTHER_SEPARATOR;
+    static {
+        if (isSystemWindows()) {
+            OTHER_SEPARATOR = UNIX_SEPARATOR;
+        } else {
+            OTHER_SEPARATOR = WINDOWS_SEPARATOR;
+        }
+    }
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public FilenameUtils() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Determines if Windows file system is in use.
+     * 
+     * @return true if the system is Windows
+     */
+    static boolean isSystemWindows() {
+        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Checks if the character is a separator.
+     * 
+     * @param ch  the character to check
+     * @return true if it is a separator character
+     */
+    private static boolean isSeparator(char ch) {
+        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Normalizes a path, removing double and single dot path steps.
+     * <p>
+     * This method normalizes a path to a standard format.
+     * The input may contain separators in either Unix or Windows format.
+     * The output will contain separators in the format of the system.
+     * <p>
+     * A trailing slash will be retained.
+     * A double slash will be merged to a single slash (but UNC names are handled).
+     * A single dot path segment will be removed.
+     * A double dot will cause that path segment and the one before to be removed.
+     * If the double dot has no parent path segment to work with, {@code null}
+     * is returned.
+     * <p>
+     * The output will be the same on both Unix and Windows except
+     * for the separator character.
+     * <pre>
+     * /foo//               -->   /foo/
+     * /foo/./              -->   /foo/
+     * /foo/../bar          -->   /bar
+     * /foo/../bar/         -->   /bar/
+     * /foo/../bar/../baz   -->   /baz
+     * //foo//./bar         -->   /foo/bar
+     * /../                 -->   null
+     * ../foo               -->   null
+     * foo/bar/..           -->   foo/
+     * foo/../../bar        -->   null
+     * foo/../bar           -->   bar
+     * //server/foo/../bar  -->   //server/bar
+     * //server/../bar      -->   null
+     * C:\foo\..\bar        -->   C:\bar
+     * C:\..\bar            -->   null
+     * ~/foo/../bar/        -->   ~/bar/
+     * ~/../bar             -->   null
+     * </pre>
+     * (Note the file separator returned will be correct for Windows/Unix)
+     *
+     * @param filename  the filename to normalize, null returns null
+     * @return the normalized filename, or null if invalid
+     */
+    public static String normalize(String filename) {
+        return doNormalize(filename, SYSTEM_SEPARATOR, true);
+    }
+    /**
+     * Normalizes a path, removing double and single dot path steps.
+     * <p>
+     * This method normalizes a path to a standard format.
+     * The input may contain separators in either Unix or Windows format.
+     * The output will contain separators in the format specified.
+     * <p>
+     * A trailing slash will be retained.
+     * A double slash will be merged to a single slash (but UNC names are handled).
+     * A single dot path segment will be removed.
+     * A double dot will cause that path segment and the one before to be removed.
+     * If the double dot has no parent path segment to work with, {@code null}
+     * is returned.
+     * <p>
+     * The output will be the same on both Unix and Windows except
+     * for the separator character.
+     * <pre>
+     * /foo//               -->   /foo/
+     * /foo/./              -->   /foo/
+     * /foo/../bar          -->   /bar
+     * /foo/../bar/         -->   /bar/
+     * /foo/../bar/../baz   -->   /baz
+     * //foo//./bar         -->   /foo/bar
+     * /../                 -->   null
+     * ../foo               -->   null
+     * foo/bar/..           -->   foo/
+     * foo/../../bar        -->   null
+     * foo/../bar           -->   bar
+     * //server/foo/../bar  -->   //server/bar
+     * //server/../bar      -->   null
+     * C:\foo\..\bar        -->   C:\bar
+     * C:\..\bar            -->   null
+     * ~/foo/../bar/        -->   ~/bar/
+     * ~/../bar             -->   null
+     * </pre>
+     * The output will be the same on both Unix and Windows including
+     * the separator character.
+     *
+     * @param filename  the filename to normalize, null returns null
+     * @param unixSeparator {@code true} if a unix separator should
+     * be used or {@code false} if a windows separator should be used.
+     * @return the normalized filename, or null if invalid
+     * @since 2.0
+     */
+    public static String normalize(String filename, boolean unixSeparator) {
+        char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;
+        return doNormalize(filename, separator, true);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Normalizes a path, removing double and single dot path steps,
+     * and removing any final directory separator.
+     * <p>
+     * This method normalizes a path to a standard format.
+     * The input may contain separators in either Unix or Windows format.
+     * The output will contain separators in the format of the system.
+     * <p>
+     * A trailing slash will be removed.
+     * A double slash will be merged to a single slash (but UNC names are handled).
+     * A single dot path segment will be removed.
+     * A double dot will cause that path segment and the one before to be removed.
+     * If the double dot has no parent path segment to work with, {@code null}
+     * is returned.
+     * <p>
+     * The output will be the same on both Unix and Windows except
+     * for the separator character.
+     * <pre>
+     * /foo//               -->   /foo
+     * /foo/./              -->   /foo
+     * /foo/../bar          -->   /bar
+     * /foo/../bar/         -->   /bar
+     * /foo/../bar/../baz   -->   /baz
+     * //foo//./bar         -->   /foo/bar
+     * /../                 -->   null
+     * ../foo               -->   null
+     * foo/bar/..           -->   foo
+     * foo/../../bar        -->   null
+     * foo/../bar           -->   bar
+     * //server/foo/../bar  -->   //server/bar
+     * //server/../bar      -->   null
+     * C:\foo\..\bar        -->   C:\bar
+     * C:\..\bar            -->   null
+     * ~/foo/../bar/        -->   ~/bar
+     * ~/../bar             -->   null
+     * </pre>
+     * (Note the file separator returned will be correct for Windows/Unix)
+     *
+     * @param filename  the filename to normalize, null returns null
+     * @return the normalized filename, or null if invalid
+     */
+    public static String normalizeNoEndSeparator(String filename) {
+        return doNormalize(filename, SYSTEM_SEPARATOR, false);
+    }
+
+    /**
+     * Normalizes a path, removing double and single dot path steps,
+     * and removing any final directory separator.
+     * <p>
+     * This method normalizes a path to a standard format.
+     * The input may contain separators in either Unix or Windows format.
+     * The output will contain separators in the format specified.
+     * <p>
+     * A trailing slash will be removed.
+     * A double slash will be merged to a single slash (but UNC names are handled).
+     * A single dot path segment will be removed.
+     * A double dot will cause that path segment and the one before to be removed.
+     * If the double dot has no parent path segment to work with, {@code null}
+     * is returned.
+     * <p>
+     * The output will be the same on both Unix and Windows including
+     * the separator character.
+     * <pre>
+     * /foo//               -->   /foo
+     * /foo/./              -->   /foo
+     * /foo/../bar          -->   /bar
+     * /foo/../bar/         -->   /bar
+     * /foo/../bar/../baz   -->   /baz
+     * //foo//./bar         -->   /foo/bar
+     * /../                 -->   null
+     * ../foo               -->   null
+     * foo/bar/..           -->   foo
+     * foo/../../bar        -->   null
+     * foo/../bar           -->   bar
+     * //server/foo/../bar  -->   //server/bar
+     * //server/../bar      -->   null
+     * C:\foo\..\bar        -->   C:\bar
+     * C:\..\bar            -->   null
+     * ~/foo/../bar/        -->   ~/bar
+     * ~/../bar             -->   null
+     * </pre>
+     *
+     * @param filename  the filename to normalize, null returns null
+     * @param unixSeparator {@code true} if a unix separator should
+     * be used or {@code false} if a windows separtor should be used.
+     * @return the normalized filename, or null if invalid
+     * @since 2.0
+     */
+    public static String normalizeNoEndSeparator(String filename, boolean unixSeparator) {
+         char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;
+        return doNormalize(filename, separator, false);
+    }
+
+    /**
+     * Internal method to perform the normalization.
+     *
+     * @param filename  the filename
+     * @param separator The separator character to use
+     * @param keepSeparator  true to keep the final separator
+     * @return the normalized filename
+     */
+    private static String doNormalize(String filename, char separator, boolean keepSeparator) {
+        if (filename == null) {
+            return null;
+        }
+        int size = filename.length();
+        if (size == 0) {
+            return filename;
+        }
+        int prefix = getPrefixLength(filename);
+        if (prefix < 0) {
+            return null;
+        }
+        
+        char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy
+        filename.getChars(0, filename.length(), array, 0);
+        
+        // fix separators throughout
+        char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;
+        for (int i = 0; i < array.length; i++) {
+            if (array[i] == otherSeparator) {
+                array[i] = separator;
+            }
+        }
+        
+        // add extra separator on the end to simplify code below
+        boolean lastIsDirectory = true;
+        if (array[size - 1] != separator) {
+            array[size++] = separator;
+            lastIsDirectory = false;
+        }
+        
+        // adjoining slashes
+        for (int i = prefix + 1; i < size; i++) {
+            if (array[i] == separator && array[i - 1] == separator) {
+                System.arraycopy(array, i, array, i - 1, size - i);
+                size--;
+                i--;
+            }
+        }
+        
+        // dot slash
+        for (int i = prefix + 1; i < size; i++) {
+            if (array[i] == separator && array[i - 1] == '.' &&
+                    (i == prefix + 1 || array[i - 2] == separator)) {
+                if (i == size - 1) {
+                    lastIsDirectory = true;
+                }
+                System.arraycopy(array, i + 1, array, i - 1, size - i);
+                size -=2;
+                i--;
+            }
+        }
+        
+        // double dot slash
+        outer:
+        for (int i = prefix + 2; i < size; i++) {
+            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&
+                    (i == prefix + 2 || array[i - 3] == separator)) {
+                if (i == prefix + 2) {
+                    return null;
+                }
+                if (i == size - 1) {
+                    lastIsDirectory = true;
+                }
+                int j;
+                for (j = i - 4 ; j >= prefix; j--) {
+                    if (array[j] == separator) {
+                        // remove b/../ from a/b/../c
+                        System.arraycopy(array, i + 1, array, j + 1, size - i);
+                        size -= i - j;
+                        i = j + 1;
+                        continue outer;
+                    }
+                }
+                // remove a/../ from a/../c
+                System.arraycopy(array, i + 1, array, prefix, size - i);
+                size -= i + 1 - prefix;
+                i = prefix + 1;
+            }
+        }
+        
+        if (size <= 0) {  // should never be less than 0
+            return "";
+        }
+        if (size <= prefix) {  // should never be less than prefix
+            return new String(array, 0, size);
+        }
+        if (lastIsDirectory && keepSeparator) {
+            return new String(array, 0, size);  // keep trailing separator
+        }
+        return new String(array, 0, size - 1);  // lose trailing separator
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Concatenates a filename to a base path using normal command line style rules.
+     * <p>
+     * The effect is equivalent to resultant directory after changing
+     * directory to the first argument, followed by changing directory to
+     * the second argument.
+     * <p>
+     * The first argument is the base path, the second is the path to concatenate.
+     * The returned path is always normalized via {@link #normalize(String)},
+     * thus <code>..</code> is handled.
+     * <p>
+     * If <code>pathToAdd</code> is absolute (has an absolute prefix), then
+     * it will be normalized and returned.
+     * Otherwise, the paths will be joined, normalized and returned.
+     * <p>
+     * The output will be the same on both Unix and Windows except
+     * for the separator character.
+     * <pre>
+     * /foo/ + bar          -->   /foo/bar
+     * /foo + bar           -->   /foo/bar
+     * /foo + /bar          -->   /bar
+     * /foo + C:/bar        -->   C:/bar
+     * /foo + C:bar         -->   C:bar (*)
+     * /foo/a/ + ../bar     -->   foo/bar
+     * /foo/ + ../../bar    -->   null
+     * /foo/ + /bar         -->   /bar
+     * /foo/.. + /bar       -->   /bar
+     * /foo + bar/c.txt     -->   /foo/bar/c.txt
+     * /foo/c.txt + bar     -->   /foo/c.txt/bar (!)
+     * </pre>
+     * (*) Note that the Windows relative drive prefix is unreliable when
+     * used with this method.
+     * (!) Note that the first parameter must be a path. If it ends with a name, then
+     * the name will be built into the concatenated path. If this might be a problem,
+     * use {@link #getFullPath(String)} on the base path argument.
+     *
+     * @param basePath  the base path to attach to, always treated as a path
+     * @param fullFilenameToAdd  the filename (or path) to attach to the base
+     * @return the concatenated path, or null if invalid
+     */
+    public static String concat(String basePath, String fullFilenameToAdd) {
+        int prefix = getPrefixLength(fullFilenameToAdd);
+        if (prefix < 0) {
+            return null;
+        }
+        if (prefix > 0) {
+            return normalize(fullFilenameToAdd);
+        }
+        if (basePath == null) {
+            return null;
+        }
+        int len = basePath.length();
+        if (len == 0) {
+            return normalize(fullFilenameToAdd);
+        }
+        char ch = basePath.charAt(len - 1);
+        if (isSeparator(ch)) {
+            return normalize(basePath + fullFilenameToAdd);
+        } else {
+            return normalize(basePath + '/' + fullFilenameToAdd);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Converts all separators to the Unix separator of forward slash.
+     * 
+     * @param path  the path to be changed, null ignored
+     * @return the updated path
+     */
+    public static String separatorsToUnix(String path) {
+        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {
+            return path;
+        }
+        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);
+    }
+
+    /**
+     * Converts all separators to the Windows separator of backslash.
+     * 
+     * @param path  the path to be changed, null ignored
+     * @return the updated path
+     */
+    public static String separatorsToWindows(String path) {
+        if (path == null || path.indexOf(UNIX_SEPARATOR) == -1) {
+            return path;
+        }
+        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);
+    }
+
+    /**
+     * Converts all separators to the system separator.
+     * 
+     * @param path  the path to be changed, null ignored
+     * @return the updated path
+     */
+    public static String separatorsToSystem(String path) {
+        if (path == null) {
+            return null;
+        }
+        if (isSystemWindows()) {
+            return separatorsToWindows(path);
+        } else {
+            return separatorsToUnix(path);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns the length of the filename prefix, such as <code>C:/</code> or <code>~/</code>.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * <p>
+     * The prefix length includes the first slash in the full filename
+     * if applicable. Thus, it is possible that the length returned is greater
+     * than the length of the input string.
+     * <pre>
+     * Windows:
+     * a\b\c.txt           --> ""          --> relative
+     * \a\b\c.txt          --> "\"         --> current drive absolute
+     * C:a\b\c.txt         --> "C:"        --> drive relative
+     * C:\a\b\c.txt        --> "C:\"       --> absolute
+     * \\server\a\b\c.txt  --> "\\server\" --> UNC
+     *
+     * Unix:
+     * a/b/c.txt           --> ""          --> relative
+     * /a/b/c.txt          --> "/"         --> absolute
+     * ~/a/b/c.txt         --> "~/"        --> current user
+     * ~                   --> "~/"        --> current user (slash added)
+     * ~user/a/b/c.txt     --> "~user/"    --> named user
+     * ~user               --> "~user/"    --> named user (slash added)
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * ie. both Unix and Windows prefixes are matched regardless.
+     *
+     * @param filename  the filename to find the prefix in, null returns -1
+     * @return the length of the prefix, -1 if invalid or null
+     */
+    public static int getPrefixLength(String filename) {
+        if (filename == null) {
+            return -1;
+        }
+        int len = filename.length();
+        if (len == 0) {
+            return 0;
+        }
+        char ch0 = filename.charAt(0);
+        if (ch0 == ':') {
+            return -1;
+        }
+        if (len == 1) {
+            if (ch0 == '~') {
+                return 2;  // return a length greater than the input
+            }
+            return isSeparator(ch0) ? 1 : 0;
+        } else {
+            if (ch0 == '~') {
+                int posUnix = filename.indexOf(UNIX_SEPARATOR, 1);
+                int posWin = filename.indexOf(WINDOWS_SEPARATOR, 1);
+                if (posUnix == -1 && posWin == -1) {
+                    return len + 1;  // return a length greater than the input
+                }
+                posUnix = posUnix == -1 ? posWin : posUnix;
+                posWin = posWin == -1 ? posUnix : posWin;
+                return Math.min(posUnix, posWin) + 1;
+            }
+            char ch1 = filename.charAt(1);
+            if (ch1 == ':') {
+                ch0 = Character.toUpperCase(ch0);
+                if (ch0 >= 'A' && ch0 <= 'Z') {
+                    if (len == 2 || isSeparator(filename.charAt(2)) == false) {
+                        return 2;
+                    }
+                    return 3;
+                }
+                return -1;
+                
+            } else if (isSeparator(ch0) && isSeparator(ch1)) {
+                int posUnix = filename.indexOf(UNIX_SEPARATOR, 2);
+                int posWin = filename.indexOf(WINDOWS_SEPARATOR, 2);
+                if (posUnix == -1 && posWin == -1 || posUnix == 2 || posWin == 2) {
+                    return -1;
+                }
+                posUnix = posUnix == -1 ? posWin : posUnix;
+                posWin = posWin == -1 ? posUnix : posWin;
+                return Math.min(posUnix, posWin) + 1;
+            } else {
+                return isSeparator(ch0) ? 1 : 0;
+            }
+        }
+    }
+
+    /**
+     * Returns the index of the last directory separator character.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The position of the last forward or backslash is returned.
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * 
+     * @param filename  the filename to find the last path separator in, null returns -1
+     * @return the index of the last separator character, or -1 if there
+     * is no such character
+     */
+    public static int indexOfLastSeparator(String filename) {
+        if (filename == null) {
+            return -1;
+        }
+        int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);
+        int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);
+        return Math.max(lastUnixPos, lastWindowsPos);
+    }
+
+    /**
+     * Returns the index of the last extension separator character, which is a dot.
+     * <p>
+     * This method also checks that there is no directory separator after the last dot.
+     * To do this it uses {@link #indexOfLastSeparator(String)} which will
+     * handle a file in either Unix or Windows format.
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * 
+     * @param filename  the filename to find the last path separator in, null returns -1
+     * @return the index of the last separator character, or -1 if there
+     * is no such character
+     */
+    public static int indexOfExtension(String filename) {
+        if (filename == null) {
+            return -1;
+        }
+        int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);
+        int lastSeparator = indexOfLastSeparator(filename);
+        return lastSeparator > extensionPos ? -1 : extensionPos;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the prefix from a full filename, such as <code>C:/</code>
+     * or <code>~/</code>.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The prefix includes the first slash in the full filename where applicable.
+     * <pre>
+     * Windows:
+     * a\b\c.txt           --> ""          --> relative
+     * \a\b\c.txt          --> "\"         --> current drive absolute
+     * C:a\b\c.txt         --> "C:"        --> drive relative
+     * C:\a\b\c.txt        --> "C:\"       --> absolute
+     * \\server\a\b\c.txt  --> "\\server\" --> UNC
+     *
+     * Unix:
+     * a/b/c.txt           --> ""          --> relative
+     * /a/b/c.txt          --> "/"         --> absolute
+     * ~/a/b/c.txt         --> "~/"        --> current user
+     * ~                   --> "~/"        --> current user (slash added)
+     * ~user/a/b/c.txt     --> "~user/"    --> named user
+     * ~user               --> "~user/"    --> named user (slash added)
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * ie. both Unix and Windows prefixes are matched regardless.
+     *
+     * @param filename  the filename to query, null returns null
+     * @return the prefix of the file, null if invalid
+     */
+    public static String getPrefix(String filename) {
+        if (filename == null) {
+            return null;
+        }
+        int len = getPrefixLength(filename);
+        if (len < 0) {
+            return null;
+        }
+        if (len > filename.length()) {
+            return filename + UNIX_SEPARATOR;  // we know this only happens for unix
+        }
+        return filename.substring(0, len);
+    }
+
+    /**
+     * Gets the path from a full filename, which excludes the prefix.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The method is entirely text based, and returns the text before and
+     * including the last forward or backslash.
+     * <pre>
+     * C:\a\b\c.txt --> a\b\
+     * ~/a/b/c.txt  --> a/b/
+     * a.txt        --> ""
+     * a/b/c        --> a/b/
+     * a/b/c/       --> a/b/c/
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * <p>
+     * This method drops the prefix from the result.
+     * See {@link #getFullPath(String)} for the method that retains the prefix.
+     *
+     * @param filename  the filename to query, null returns null
+     * @return the path of the file, an empty string if none exists, null if invalid
+     */
+    public static String getPath(String filename) {
+        return doGetPath(filename, 1);
+    }
+
+    /**
+     * Gets the path from a full filename, which excludes the prefix, and
+     * also excluding the final directory separator.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The method is entirely text based, and returns the text before the
+     * last forward or backslash.
+     * <pre>
+     * C:\a\b\c.txt --> a\b
+     * ~/a/b/c.txt  --> a/b
+     * a.txt        --> ""
+     * a/b/c        --> a/b
+     * a/b/c/       --> a/b/c
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     * <p>
+     * This method drops the prefix from the result.
+     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.
+     *
+     * @param filename  the filename to query, null returns null
+     * @return the path of the file, an empty string if none exists, null if invalid
+     */
+    public static String getPathNoEndSeparator(String filename) {
+        return doGetPath(filename, 0);
+    }
+
+    /**
+     * Does the work of getting the path.
+     * 
+     * @param filename  the filename
+     * @param separatorAdd  0 to omit the end separator, 1 to return it
+     * @return the path
+     */
+    private static String doGetPath(String filename, int separatorAdd) {
+        if (filename == null) {
+            return null;
+        }
+        int prefix = getPrefixLength(filename);
+        if (prefix < 0) {
+            return null;
+        }
+        int index = indexOfLastSeparator(filename);
+        int endIndex = index+separatorAdd;
+        if (prefix >= filename.length() || index < 0 || prefix >= endIndex) {
+            return "";
+        }
+        return filename.substring(prefix, endIndex);
+    }
+
+    /**
+     * Gets the full path from a full filename, which is the prefix + path.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The method is entirely text based, and returns the text before and
+     * including the last forward or backslash.
+     * <pre>
+     * C:\a\b\c.txt --> C:\a\b\
+     * ~/a/b/c.txt  --> ~/a/b/
+     * a.txt        --> ""
+     * a/b/c        --> a/b/
+     * a/b/c/       --> a/b/c/
+     * C:           --> C:
+     * C:\          --> C:\
+     * ~            --> ~/
+     * ~/           --> ~/
+     * ~user        --> ~user/
+     * ~user/       --> ~user/
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     *
+     * @param filename  the filename to query, null returns null
+     * @return the path of the file, an empty string if none exists, null if invalid
+     */
+    public static String getFullPath(String filename) {
+        return doGetFullPath(filename, true);
+    }
+
+    /**
+     * Gets the full path from a full filename, which is the prefix + path,
+     * and also excluding the final directory separator.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The method is entirely text based, and returns the text before the
+     * last forward or backslash.
+     * <pre>
+     * C:\a\b\c.txt --> C:\a\b
+     * ~/a/b/c.txt  --> ~/a/b
+     * a.txt        --> ""
+     * a/b/c        --> a/b
+     * a/b/c/       --> a/b/c
+     * C:           --> C:
+     * C:\          --> C:\
+     * ~            --> ~
+     * ~/           --> ~
+     * ~user        --> ~user
+     * ~user/       --> ~user
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     *
+     * @param filename  the filename to query, null returns null
+     * @return the path of the file, an empty string if none exists, null if invalid
+     */
+    public static String getFullPathNoEndSeparator(String filename) {
+        return doGetFullPath(filename, false);
+    }
+
+    /**
+     * Does the work of getting the path.
+     * 
+     * @param filename  the filename
+     * @param includeSeparator  true to include the end separator
+     * @return the path
+     */
+    private static String doGetFullPath(String filename, boolean includeSeparator) {
+        if (filename == null) {
+            return null;
+        }
+        int prefix = getPrefixLength(filename);
+        if (prefix < 0) {
+            return null;
+        }
+        if (prefix >= filename.length()) {
+            if (includeSeparator) {
+                return getPrefix(filename);  // add end slash if necessary
+            } else {
+                return filename;
+            }
+        }
+        int index = indexOfLastSeparator(filename);
+        if (index < 0) {
+            return filename.substring(0, prefix);
+        }
+        int end = index + (includeSeparator ?  1 : 0);
+        if (end == 0) {
+            end++;
+        }
+        return filename.substring(0, end);
+    }
+
+    /**
+     * Gets the name minus the path from a full filename.
+     * <p>
+     * This method will handle a file in either Unix or Windows format.
+     * The text after the last forward or backslash is returned.
+     * <pre>
+     * a/b/c.txt --> c.txt
+     * a.txt     --> a.txt
+     * a/b/c     --> c
+     * a/b/c/    --> ""
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     *
+     * @param filename  the filename to query, null returns null
+     * @return the name of the file without the path, or an empty string if none exists
+     */
+    public static String getName(String filename) {
+        if (filename == null) {
+            return null;
+        }
+        int index = indexOfLastSeparator(filename);
+        return filename.substring(index + 1);
+    }
+
+    /**
+     * Gets the extension of a filename.
+     * <p>
+     * This method returns the textual part of the filename after the last dot.
+     * There must be no directory separator after the dot.
+     * <pre>
+     * foo.txt      --> "txt"
+     * a/b/c.jpg    --> "jpg"
+     * a/b.txt/c    --> ""
+     * a/b/c        --> ""
+     * </pre>
+     * <p>
+     * The output will be the same irrespective of the machine that the code is running on.
+     *
+     * @param filename the filename to retrieve the extension of.
+     * @return the extension of the file or an empty string if none exists or {@code null}
+     * if the filename is {@code null}.
+     */
+    public static String getExtension(String filename) {
+        if (filename == null) {
+            return null;
+        }
+        int index = indexOfExtension(filename);
+        if (index == -1) {
+            return "";
+        } else {
+            return filename.substring(index + 1);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Checks whether the extension of the filename is that specified.
+     * <p>
+     * This method obtains the extension as the textual part of the filename
+     * after the last dot. There must be no directory separator after the dot.
+     * The extension check is case-sensitive on all platforms.
+     *
+     * @param filename  the filename to query, null returns false
+     * @param extension  the extension to check for, null or empty checks for no extension
+     * @return true if the filename has the specified extension
+     */
+    public static boolean isExtension(String filename, String extension) {
+        if (filename == null) {
+            return false;
+        }
+        if (extension == null || extension.length() == 0) {
+            return indexOfExtension(filename) == -1;
+        }
+        String fileExt = getExtension(filename);
+        return fileExt.equals(extension);
+    }
+
+    /**
+     * Checks whether the extension of the filename is one of those specified.
+     * <p>
+     * This method obtains the extension as the textual part of the filename
+     * after the last dot. There must be no directory separator after the dot.
+     * The extension check is case-sensitive on all platforms.
+     *
+     * @param filename  the filename to query, null returns false
+     * @param extensions  the extensions to check for, null checks for no extension
+     * @return true if the filename is one of the extensions
+     */
+    public static boolean isExtension(String filename, String[] extensions) {
+        if (filename == null) {
+            return false;
+        }
+        if (extensions == null || extensions.length == 0) {
+            return indexOfExtension(filename) == -1;
+        }
+        String fileExt = getExtension(filename);
+        for (String extension : extensions) {
+            if (fileExt.equals(extension)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks whether the extension of the filename is one of those specified.
+     * <p>
+     * This method obtains the extension as the textual part of the filename
+     * after the last dot. There must be no directory separator after the dot.
+     * The extension check is case-sensitive on all platforms.
+     *
+     * @param filename  the filename to query, null returns false
+     * @param extensions  the extensions to check for, null checks for no extension
+     * @return true if the filename is one of the extensions
+     */
+    public static boolean isExtension(String filename, Collection<String> extensions) {
+        if (filename == null) {
+            return false;
+        }
+        if (extensions == null || extensions.isEmpty()) {
+            return indexOfExtension(filename) == -1;
+        }
+        String fileExt = getExtension(filename);
+        for (String extension : extensions) {
+            if (fileExt.equals(extension)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Splits a string into a number of tokens.
+     * The text is split by '?' and '*'.
+     * Where multiple '*' occur consecutively they are collapsed into a single '*'.
+     * 
+     * @param text  the text to split
+     * @return the array of tokens, never null
+     */
+    static String[] splitOnTokens(String text) {
+        // used by wildcardMatch
+        // package level so a unit test may run on this
+        
+        if (text.indexOf('?') == -1 && text.indexOf('*') == -1) {
+            return new String[] { text };
+        }
+
+        char[] array = text.toCharArray();
+        ArrayList<String> list = new ArrayList<String>();
+        StringBuilder buffer = new StringBuilder();
+        for (int i = 0; i < array.length; i++) {
+            if (array[i] == '?' || array[i] == '*') {
+                if (buffer.length() != 0) {
+                    list.add(buffer.toString());
+                    buffer.setLength(0);
+                }
+                if (array[i] == '?') {
+                    list.add("?");
+                } else if (list.isEmpty() ||
+                        i > 0 && list.get(list.size() - 1).equals("*") == false) {
+                    list.add("*");
+                }
+            } else {
+                buffer.append(array[i]);
+            }
+        }
+        if (buffer.length() != 0) {
+            list.add(buffer.toString());
+        }
+
+        return list.toArray( new String[ list.size() ] );
+    }
+
+}
Index: ucrop/src/main/res/menu/ucrop_menu_activity.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/menu/ucrop_menu_activity.xml	(revision )
+++ ucrop/src/main/res/menu/ucrop_menu_activity.xml	(revision )
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_next"
+        android:icon="@drawable/ucrop_ic_next"
+        android:title="@string/ucrop_menu_next"
+        app:showAsAction="always"/>
+
+</menu>
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/ExStaggeredGridLayoutManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/ExStaggeredGridLayoutManager.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/ExStaggeredGridLayoutManager.java	(revision )
@@ -0,0 +1,69 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.StaggeredGridLayoutManager;
+import android.view.View;
+
+/**
+ * Created by scene on 2015/10/9.
+ * <p/>
+ * 拓展的StaggeredGridLayoutManager，tks @Jack Tony
+ */
+public class ExStaggeredGridLayoutManager extends StaggeredGridLayoutManager {
+
+    private final String TAG = getClass().getSimpleName();
+
+    GridLayoutManager.SpanSizeLookup mSpanSizeLookup;
+
+    public ExStaggeredGridLayoutManager(int spanCount, int orientation) {
+        super(spanCount, orientation);
+    }
+
+    /**
+     * Returns the current used by the GridLayoutManager.
+     *
+     * @return The current used by the GridLayoutManager.
+     */
+    public GridLayoutManager.SpanSizeLookup getSpanSizeLookup() {
+        return mSpanSizeLookup;
+    }
+
+    /**
+     * 设置某个位置的item的跨列程度，这里和GridLayoutManager有点不一样，
+     * 如果你设置某个位置的item的span>1了，那么这个item会占据所有列
+     *
+     * @param spanSizeLookup instance to be used to query number of spans
+     *                       occupied by each item
+     */
+    public void setSpanSizeLookup(GridLayoutManager.SpanSizeLookup spanSizeLookup) {
+        mSpanSizeLookup = spanSizeLookup;
+    }
+
+    @Override
+    public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec) {
+        //Log.d(TAG, "item count = " + getItemCount());
+        for (int i = 0; i < getItemCount(); i++) {
+
+            if (mSpanSizeLookup.getSpanSize(i) > 1) {
+                //Log.d(TAG, "lookup > 1 = " + i);
+                try {
+                    //fix 动态添加时报IndexOutOfBoundsException
+                    View view = recycler.getViewForPosition(i);
+                    if (view != null) {
+                        /**
+                         *占用所有的列
+                         * @see https://plus.google.com/+EtienneLawlor/posts/c5T7fu9ujqi
+                         */
+                        StaggeredGridLayoutManager.LayoutParams lp = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams();
+                        lp.setFullSpan(true);
+                    }
+                    // recycler.recycleView(view);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        super.onMeasure(recycler, state, widthSpec, heightSpec);
+    }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/RecyclerViewBaseAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/RecyclerViewBaseAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/RecyclerViewBaseAdapter.java	(revision )
@@ -0,0 +1,124 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.view.ViewGroup;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * 横向RecyclerView基类adapter
+ *
+ * @param <ItemDataType> 数据实体类型
+ * @author scene
+ *         time 2015-04-10 12:33:43
+ */
+public abstract class RecyclerViewBaseAdapter<ItemDataType> extends
+        RecyclerView.Adapter<RecyclerView.ViewHolder> {
+
+    protected ArrayList<ItemDataType> mItemDataList = new ArrayList<ItemDataType>();
+
+    public RecyclerViewBaseAdapter() {
+    }
+
+    /**
+     * 动态增加一条数据
+     *
+     * @param itemDataType 数据实体类对象
+     */
+    public void append(ItemDataType itemDataType) {
+        if (itemDataType != null) {
+            mItemDataList.add(itemDataType);
+            notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * 动态增加一组数据集合
+     *
+     * @param itemDataTypes 数据实体类集合
+     */
+    public void append(List<ItemDataType> itemDataTypes) {
+        if (itemDataTypes.size() > 0) {
+            for (ItemDataType itemDataType : itemDataTypes) {
+                mItemDataList.add(itemDataType);
+            }
+            notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * 替换全部数据
+     *
+     * @param itemDataTypes 数据实体类集合
+     */
+    public void replace(List<ItemDataType> itemDataTypes) {
+        mItemDataList.clear();
+        if (itemDataTypes.size() > 0) {
+            mItemDataList.addAll(itemDataTypes);
+            notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * 移除一条数据集合
+     *
+     * @param position
+     */
+    public void remove(int position) {
+        mItemDataList.remove(position);
+        notifyDataSetChanged();
+    }
+
+    /**
+     * 移除所有数据
+     */
+    public void removeAll() {
+        mItemDataList.clear();
+        notifyDataSetChanged();
+    }
+
+    @Override
+    public int getItemCount() {
+        return mItemDataList.size();
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
+        showData(viewHolder, position, mItemDataList);
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int position) {
+        View view = createView(viewGroup, position);
+        RecyclerView.ViewHolder holder = createViewHolder(view);
+        return holder;
+    }
+
+    /**
+     * 显示数据抽象函数
+     *
+     * @param viewHolder    基类ViewHolder,需要向下转型为对应的ViewHolder（example:MainRecyclerViewHolder mainRecyclerViewHolder=(MainRecyclerViewHolder) viewHolder;）
+     * @param i             位置
+     * @param mItemDataList 数据集合
+     */
+    public abstract void showData(RecyclerView.ViewHolder viewHolder, int i, List<ItemDataType> mItemDataList);
+
+    /**
+     * 加载item的view,直接返回加载的view即可
+     *
+     * @param viewGroup 如果需要Context,可以viewGroup.getContext()获取
+     * @param position
+     * @return item 的 view
+     */
+    public abstract View createView(ViewGroup viewGroup, int position);
+
+    /**
+     * 加载一个ViewHolder,为RecyclerViewHolderBase子类,直接返回子类的对象即可
+     *
+     * @param view item 的view
+     * @return BaseViewHolder 基类ViewHolder
+     */
+    public abstract RecyclerView.ViewHolder createViewHolder(View view);
+}
\ No newline at end of file
Index: ucrop/src/main/res/values/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/values/dimens.xml	(revision )
+++ ucrop/src/main/res/values/dimens.xml	(revision )
@@ -0,0 +1,12 @@
+<resources>
+
+    <dimen name="ucrop_default_crop_grid_stoke_size">1dp</dimen>
+    <dimen name="ucrop_default_crop_frame_stoke_size">1dp</dimen>
+
+    <dimen name="ucrop_size_dot_scale_text_view">8dp</dimen>
+
+    <dimen name="ucrop_height_horizontal_wheel_progress_line">20dp</dimen>
+    <dimen name="ucrop_width_horizontal_wheel_progress_line">2dp</dimen>
+    <dimen name="ucrop_margin_horizontal_wheel_progress_line">10dp</dimen>
+
+</resources>
Index: ucrop/src/main/res/drawable/ucrop_ic_selector_scale.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/drawable/ucrop_ic_selector_scale.xml	(revision )
+++ ucrop/src/main/res/drawable/ucrop_ic_selector_scale.xml	(revision )
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/ucrop_ic_scale_active" android:state_selected="true"/>
+    <item android:drawable="@drawable/ucrop_ic_scale"/>
+</selector>
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/activity/CustomRatingBarActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/activity/CustomRatingBarActivity.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/activity/CustomRatingBarActivity.java	(revision )
@@ -0,0 +1,40 @@
+package com.scene.sceneandroiddemo.ui.activity;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+import com.scene.mylib.view.ratingbar.ProperRatingBar;
+import com.scene.mylib.view.ratingbar.RatingListener;
+import com.scene.sceneandroiddemo.BaseActivity;
+import com.scene.sceneandroiddemo.R;
+
+import butterknife.Bind;
+
+/**
+ * 自定义评星条
+ * 解决不同分辨率适配问题
+ */
+public class CustomRatingBarActivity extends BaseActivity {
+    @Bind(R.id.ratingBar)
+    ProperRatingBar ratingBar;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        init();
+    }
+
+    @Override
+    protected int setLayoutResId() {
+        return R.layout.activity_custom_rating_bar;
+    }
+
+    private void init() {
+        ratingBar.setListener(new RatingListener() {
+            @Override
+            public void onRatePicked(ProperRatingBar ratingBar) {
+                showToast("当前选择的是：" + ratingBar.getRating());
+            }
+        });
+    }
+}
Index: mylib/src/main/res/layout/sample_common_list_footer.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/sample_common_list_footer.xml	(revision )
+++ mylib/src/main/res/layout/sample_common_list_footer.xml	(revision )
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/loading_view"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/dp_60"
+    android:gravity="center"
+    android:orientation="vertical">
+
+    <ViewStub
+        android:id="@+id/loading_viewstub"
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/dp_60"
+        android:layout="@layout/sample_common_list_footer_loading" />
+
+    <ViewStub
+        android:id="@+id/end_viewstub"
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/dp_60"
+        android:layout="@layout/sample_common_list_footer_end" />
+
+    <ViewStub
+        android:id="@+id/network_error_viewstub"
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/dp_60"
+        android:layout="@layout/sample_common_list_footer_network_error" />
+
+</LinearLayout>
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/BaseActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/BaseActivity.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/BaseActivity.java	(revision )
@@ -0,0 +1,179 @@
+package com.scene.sceneandroiddemo;
+
+import android.Manifest;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v7.app.AppCompatActivity;
+import android.text.TextUtils;
+import android.widget.Toast;
+
+import java.util.List;
+
+import butterknife.ButterKnife;
+import pub.devrel.easypermissions.AfterPermissionGranted;
+import pub.devrel.easypermissions.EasyPermissions;
+
+/**
+ * Created by scene on 16/01/27.
+ */
+public abstract class BaseActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {
+
+    private ProgressDialog progressDialog;
+    public Context mContext;
+    private Toast mToast;
+    //权限的类型用于同一页面多个操作需要同一权限的问题
+    private int permissionType = 0;
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(setLayoutResId());
+        ButterKnife.bind(this);
+        mContext = this;
+    }
+
+    protected abstract int setLayoutResId();
+
+    /**
+     * 显示dialog
+     *
+     * @param message
+     */
+    public void showProgressDialog(String message) {
+        if (progressDialog == null) {
+            progressDialog = new ProgressDialog(mContext);
+        }
+        progressDialog.setMessage("加载中...");
+        dismissProgressDialog();
+        progressDialog.show();
+    }
+
+    /**
+     * 隐藏
+     */
+    public void dismissProgressDialog() {
+        if (progressDialog != null && progressDialog.isShowing()) {
+            progressDialog.dismiss();
+        }
+    }
+
+    /**
+     * 显示Toast
+     *
+     * @param message
+     */
+    public void showToast(String message) {
+        if (message == null || TextUtils.isEmpty(message)) {
+            return;
+        }
+        if (mToast == null) {
+            mToast = Toast.makeText(mContext, message, Toast.LENGTH_SHORT);
+        } else {
+            mToast.setText(message);
+        }
+        mToast.show();
+    }
+
+    /**
+     * 通过注解验证是否有相机权限
+     * 没有则需要申请权限
+     * ps:该方法不能有参数
+     */
+    @AfterPermissionGranted(PermissionConfig.RC_CAMERA_PERM)
+    public void applyCameraPermission() {
+        if (EasyPermissions.hasPermissions(this, Manifest.permission.CAMERA)) {
+            // Have permission, do the thing!
+            onCameraPermissionSuccess(getPermissionType());
+        } else {
+            // Ask for one permission
+            EasyPermissions.requestPermissions(this, getString(R.string.camera_permission),
+                    PermissionConfig.RC_CAMERA_PERM, Manifest.permission.CAMERA);
+        }
+    }
+
+    /**
+     * 通过注解验证是否有存储空间权限
+     * 没有则需要申请权限
+     * ps:该方法不能有参数
+     */
+    @AfterPermissionGranted(PermissionConfig.RC_Storage_PERM)
+    public void applyStoragePermission() {
+        if (EasyPermissions.hasPermissions(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
+            // Have permission, do the thing!
+            onStoragePermissionSuccess(getPermissionType());
+        } else {
+            // Ask for one permission
+            EasyPermissions.requestPermissions(this, getString(R.string.storage_permission),
+                    PermissionConfig.RC_Storage_PERM, Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        }
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
+        // EasyPermissions handles the request result.
+        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);
+    }
+
+    /**
+     * 允许授权
+     * 这个方法可以不用管
+     *
+     * @param perms
+     */
+    @Override
+    public void onPermissionsGranted(List<String> perms) {
+    }
+
+    /**
+     * 拒绝授权
+     * 交互友好为了在用户拒绝授权时响应用户按下效果
+     *
+     * @param perms
+     */
+    @Override
+    public void onPermissionsDenied(List<String> perms) {
+        for (String perm : perms) {
+            if (perm.equals(Manifest.permission.CAMERA)) {
+                showToast("相机权限被拒绝");
+            }
+            if (perm.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
+                showToast("存储空间权限被拒绝");
+            }
+        }
+    }
+
+    /**
+     * 成功获取相机权限后的操作
+     * 在这儿不做处理需要的时候再处理
+     *
+     * @return type 添加一个类型处理同一页面多个地方需要相同权限
+     */
+    public void onCameraPermissionSuccess(int type) {
+    }
+
+    /**
+     * 成功获取存储空间权限后的操作
+     * 在这儿不做处理需要的时候再处理
+     *
+     * @return type 添加一个类型处理同一页面多个地方需要相同权限
+     */
+    public void onStoragePermissionSuccess(int type) {
+    }
+
+    public void setPermissionType(int permissionType) {
+        this.permissionType = permissionType;
+    }
+
+    public int getPermissionType() {
+        return permissionType;
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        ButterKnife.unbind(this);
+    }
+}
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/CursorSwipeAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/CursorSwipeAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/CursorSwipeAdapter.java	(revision )
@@ -0,0 +1,85 @@
+package com.scene.mylib.view.swipelayout.adapters;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.support.v4.widget.CursorAdapter;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.implments.SwipeItemMangerImpl;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeAdapterInterface;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeItemMangerInterface;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.List;
+
+public abstract class CursorSwipeAdapter extends CursorAdapter implements SwipeItemMangerInterface, SwipeAdapterInterface {
+
+    private SwipeItemMangerImpl mItemManger = new SwipeItemMangerImpl(this);
+
+    protected CursorSwipeAdapter(Context context, Cursor c, boolean autoRequery) {
+        super(context, c, autoRequery);
+    }
+
+    protected CursorSwipeAdapter(Context context, Cursor c, int flags) {
+        super(context, c, flags);
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        View v = super.getView(position, convertView, parent);
+        mItemManger.bind(v, position);
+        return v;
+    }
+
+    @Override
+    public void openItem(int position) {
+        mItemManger.openItem(position);
+    }
+
+    @Override
+    public void closeItem(int position) {
+        mItemManger.closeItem(position);
+    }
+
+    @Override
+    public void closeAllExcept(SwipeLayout layout) {
+        mItemManger.closeAllExcept(layout);
+    }
+
+    @Override
+    public void closeAllItems() {
+        mItemManger.closeAllItems();
+    }
+
+    @Override
+    public List<Integer> getOpenItems() {
+        return mItemManger.getOpenItems();
+    }
+
+    @Override
+    public List<SwipeLayout> getOpenLayouts() {
+        return mItemManger.getOpenLayouts();
+    }
+
+    @Override
+    public void removeShownLayouts(SwipeLayout layout) {
+        mItemManger.removeShownLayouts(layout);
+    }
+
+    @Override
+    public boolean isOpen(int position) {
+        return mItemManger.isOpen(position);
+    }
+
+    @Override
+    public Attributes.Mode getMode() {
+        return mItemManger.getMode();
+    }
+
+    @Override
+    public void setMode(Attributes.Mode mode) {
+        mItemManger.setMode(mode);
+    }
+}
Index: mylib/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/proguard-rules.pro	(revision )
+++ mylib/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\Devolopment\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: common/src/main/java/com/scene/common/android/log/Log.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/android/log/Log.java	(revision )
+++ common/src/main/java/com/scene/common/android/log/Log.java	(revision )
@@ -0,0 +1,135 @@
+package com.scene.common.android.log;
+
+/**
+ * the logger
+ *
+ * @author MaTianyu
+ *         2014-1-1下午4:05:39
+ */
+public final class Log {
+
+    /**
+     * isPrint: print switch, true will print. false not print
+     */
+    public static boolean isPrint = true;
+    private static String defaultTag = "Log";
+
+    private Log() {}
+
+    public static void setTag(String tag) {
+        defaultTag = tag;
+    }
+
+    public static int i(Object o) {
+        return isPrint && o != null ? android.util.Log.i(defaultTag, o.toString()) : -1;
+    }
+
+    public static int i(String m) {
+        return isPrint && m != null ? android.util.Log.i(defaultTag, m) : -1;
+    }
+
+    /**
+     * ******************** Log **************************
+     */
+    public static int v(String tag, String msg) {
+        return isPrint && msg != null ? android.util.Log.v(tag, msg) : -1;
+    }
+
+    public static int d(String tag, String msg) {
+        return isPrint && msg != null ? android.util.Log.d(tag, msg) : -1;
+    }
+
+    public static int i(String tag, String msg) {
+        return isPrint && msg != null ? android.util.Log.i(tag, msg) : -1;
+    }
+
+    public static int w(String tag, String msg) {
+        return isPrint && msg != null ? android.util.Log.w(tag, msg) : -1;
+    }
+
+    public static int e(String tag, String msg) {
+        return isPrint && msg != null ? android.util.Log.e(tag, msg) : -1;
+    }
+
+    /**
+     * ******************** Log with object list **************************
+     */
+    public static int v(String tag, Object... msg) {
+        return isPrint ? android.util.Log.v(tag, getLogMessage(msg)) : -1;
+    }
+
+    public static int d(String tag, Object... msg) {
+        return isPrint ? android.util.Log.d(tag, getLogMessage(msg)) : -1;
+    }
+
+    public static int i(String tag, Object... msg) {
+        return isPrint ? android.util.Log.i(tag, getLogMessage(msg)) : -1;
+    }
+
+    public static int w(String tag, Object... msg) {
+        return isPrint ? android.util.Log.w(tag, getLogMessage(msg)) : -1;
+    }
+
+    public static int e(String tag, Object... msg) {
+        return isPrint ? android.util.Log.e(tag, getLogMessage(msg)) : -1;
+    }
+
+    private static String getLogMessage(Object... msg) {
+        if (msg != null && msg.length > 0) {
+            StringBuilder sb = new StringBuilder();
+            for (Object s : msg) {
+                if (s != null) {
+                    sb.append(s.toString());
+                }
+            }
+            return sb.toString();
+        }
+        return "";
+    }
+
+    /**
+     * ******************** Log with Throwable **************************
+     */
+    public static int v(String tag, String msg, Throwable tr) {
+        return isPrint && msg != null ? android.util.Log.v(tag, msg, tr) : -1;
+    }
+
+    public static int d(String tag, String msg, Throwable tr) {
+        return isPrint && msg != null ? android.util.Log.d(tag, msg, tr) : -1;
+    }
+
+    public static int i(String tag, String msg, Throwable tr) {
+        return isPrint && msg != null ? android.util.Log.i(tag, msg, tr) : -1;
+    }
+
+    public static int w(String tag, String msg, Throwable tr) {
+        return isPrint && msg != null ? android.util.Log.w(tag, msg, tr) : -1;
+    }
+
+    public static int e(String tag, String msg, Throwable tr) {
+        return isPrint && msg != null ? android.util.Log.e(tag, msg, tr) : -1;
+    }
+
+    /**
+     * ******************** TAG use Object Tag **************************
+     */
+    public static int v(Object tag, String msg) {
+        return isPrint ? android.util.Log.v(tag.getClass().getSimpleName(), msg) : -1;
+    }
+
+    public static int d(Object tag, String msg) {
+        return isPrint ? android.util.Log.d(tag.getClass().getSimpleName(), msg) : -1;
+    }
+
+    public static int i(Object tag, String msg) {
+        return isPrint ? android.util.Log.i(tag.getClass().getSimpleName(), msg) : -1;
+    }
+
+    public static int w(Object tag, String msg) {
+        return isPrint ? android.util.Log.w(tag.getClass().getSimpleName(), msg) : -1;
+    }
+
+    public static int e(Object tag, String msg) {
+        return isPrint ? android.util.Log.e(tag.getClass().getSimpleName(), msg) : -1;
+    }
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/BaseFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/BaseFragment.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/BaseFragment.java	(revision )
@@ -0,0 +1,57 @@
+package com.scene.sceneandroiddemo;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import butterknife.ButterKnife;
+
+/**
+ * Created by scene on 16/02/23.
+ */
+public abstract class BaseFragment extends Fragment {
+    private boolean hasLoad = false;
+
+    @Nullable
+    @Override
+    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
+        View view = inflater.inflate(setLayoutResId(), null);
+        ButterKnife.bind(this, view);
+        return view;
+    }
+
+    public abstract int setLayoutResId();
+
+    public abstract void init();
+
+    /**
+     * 以下两个方法是防止预加载用的
+     * @param isVisibleToUser
+     */
+    @Override
+    public void setUserVisibleHint(boolean isVisibleToUser) {
+        if (isVisibleToUser && isVisible() && !hasLoad) {
+            hasLoad = true;
+            init();
+        }
+        super.setUserVisibleHint(isVisibleToUser);
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        if (getUserVisibleHint() && !hasLoad) {
+            hasLoad = true;
+            init();
+        }
+        super.onActivityCreated(savedInstanceState);
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        ButterKnife.unbind(this);
+    }
+}
Index: common/src/main/java/com/scene/common/common/io/FileUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/FileUtils.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/FileUtils.java	(revision )
@@ -0,0 +1,2547 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io;
+
+import java.io.*;
+import java.math.BigInteger;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+import java.util.*;
+
+
+/**
+ * General file manipulation utilities.
+ * <p/>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>writing to a file
+ * <li>reading from a file
+ * <li>make a directory including parent directories
+ * <li>copying files and directories
+ * <li>deleting files and directories
+ * <li>converting to and from a URL
+ * <li>listing files and directories by filter and extension
+ * <li>comparing file content
+ * <li>file last changed date
+ * <li>calculating a checksum
+ * </ul>
+ * <p/>
+ * Origin of code: Excalibur, Alexandria, Commons-Utils
+ *
+ * @version $Id: FileUtils.java 1349509 2012-06-12 20:39:23Z ggregory $
+ */
+public class FileUtils {
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public FileUtils() {
+        super();
+    }
+
+    /**
+     * The number of bytes in a kilobyte.
+     */
+    public static final long ONE_KB = 1024;
+
+    /**
+     * The number of bytes in a kilobyte.
+     *
+     * @since 2.4
+     */
+    public static final BigInteger ONE_KB_BI = BigInteger.valueOf(ONE_KB);
+
+    /**
+     * The number of bytes in a megabyte.
+     */
+    public static final long ONE_MB = ONE_KB * ONE_KB;
+
+    /**
+     * The number of bytes in a megabyte.
+     *
+     * @since 2.4
+     */
+    public static final BigInteger ONE_MB_BI = ONE_KB_BI.multiply(ONE_KB_BI);
+
+    /**
+     * The file copy buffer size (30 MB)
+     */
+    private static final long FILE_COPY_BUFFER_SIZE = ONE_MB * 30;
+
+    /**
+     * The number of bytes in a gigabyte.
+     */
+    public static final long ONE_GB = ONE_KB * ONE_MB;
+
+    /**
+     * The number of bytes in a gigabyte.
+     *
+     * @since 2.4
+     */
+    public static final BigInteger ONE_GB_BI = ONE_KB_BI.multiply(ONE_MB_BI);
+
+    /**
+     * The number of bytes in a terabyte.
+     */
+    public static final long ONE_TB = ONE_KB * ONE_GB;
+
+    /**
+     * The number of bytes in a terabyte.
+     *
+     * @since 2.4
+     */
+    public static final BigInteger ONE_TB_BI = ONE_KB_BI.multiply(ONE_GB_BI);
+
+    /**
+     * The number of bytes in a petabyte.
+     */
+    public static final long ONE_PB = ONE_KB * ONE_TB;
+
+    /**
+     * The number of bytes in a petabyte.
+     *
+     * @since 2.4
+     */
+    public static final BigInteger ONE_PB_BI = ONE_KB_BI.multiply(ONE_TB_BI);
+
+    /**
+     * The number of bytes in an exabyte.
+     */
+    public static final long ONE_EB = ONE_KB * ONE_PB;
+
+    /**
+     * The number of bytes in an exabyte.
+     *
+     * @since 2.4
+     */
+    public static final BigInteger ONE_EB_BI = ONE_KB_BI.multiply(ONE_PB_BI);
+
+    /**
+     * The number of bytes in a zettabyte.
+     */
+    public static final BigInteger ONE_ZB = BigInteger.valueOf(ONE_KB).multiply(BigInteger.valueOf(ONE_EB));
+
+    /**
+     * The number of bytes in a yottabyte.
+     */
+    public static final BigInteger ONE_YB = ONE_KB_BI.multiply(ONE_ZB);
+
+    /**
+     * An empty array of type <code>File</code>.
+     */
+    public static final File[] EMPTY_FILE_ARRAY = new File[0];
+
+    /**
+     * The UTF-8 character set, used to decode octets in URLs.
+     */
+    private static final Charset UTF8 = Charset.forName("UTF-8");
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Construct a file from the set of name elements.
+     *
+     * @param directory the parent directory
+     * @param names     the name elements
+     * @return the file
+     * @since 2.1
+     */
+    public static File getFile(File directory, String... names) {
+        if (directory == null) {
+            throw new NullPointerException("directorydirectory must not be null");
+        }
+        if (names == null) {
+            throw new NullPointerException("names must not be null");
+        }
+        File file = directory;
+        for (String name : names) {
+            file = new File(file, name);
+        }
+        return file;
+    }
+
+    /**
+     * Construct a file from the set of name elements.
+     *
+     * @param names the name elements
+     * @return the file
+     * @since 2.1
+     */
+    public static File getFile(String... names) {
+        if (names == null) {
+            throw new NullPointerException("names must not be null");
+        }
+        File file = null;
+        for (String name : names) {
+            if (file == null) {
+                file = new File(name);
+            } else {
+                file = new File(file, name);
+            }
+        }
+        return file;
+    }
+
+    /**
+     * Returns the path to the system temporary directory.
+     *
+     * @return the path to the system temporary directory.
+     * @since 2.0
+     */
+    public static String getTempDirectoryPath() {
+        return System.getProperty("java.io.tmpdir");
+    }
+
+    /**
+     * Returns a {@link File} representing the system temporary directory.
+     *
+     * @return the system temporary directory.
+     * @since 2.0
+     */
+    public static File getTempDirectory() {
+        return new File(getTempDirectoryPath());
+    }
+
+    /**
+     * Returns the path to the user's home directory.
+     *
+     * @return the path to the user's home directory.
+     * @since 2.0
+     */
+    public static String getUserDirectoryPath() {
+        return System.getProperty("user.home");
+    }
+
+    /**
+     * Returns a {@link File} representing the user's home directory.
+     *
+     * @return the user's home directory.
+     * @since 2.0
+     */
+    public static File getUserDirectory() {
+        return new File(getUserDirectoryPath());
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Opens a {@link FileInputStream} for the specified file, providing better
+     * error messages than simply calling <code>new FileInputStream(file)</code>.
+     * <p/>
+     * At the end of the method either the stream will be successfully opened,
+     * or an exception will have been thrown.
+     * <p/>
+     * An exception is thrown if the file does not exist.
+     * An exception is thrown if the file object exists but is a directory.
+     * An exception is thrown if the file exists but cannot be read.
+     *
+     * @param file the file to open for input, must not be {@code null}
+     * @return a new {@link FileInputStream} for the specified file
+     * @throws FileNotFoundException if the file does not exist
+     * @throws IOException           if the file object is a directory
+     * @throws IOException           if the file cannot be read
+     * @since 1.3
+     */
+    public static FileInputStream openInputStream(File file) throws IOException {
+        if (file.exists()) {
+            if (file.isDirectory()) {
+                throw new IOException("File '" + file + "' exists but is a directory");
+            }
+            if (file.canRead() == false) {
+                throw new IOException("File '" + file + "' cannot be read");
+            }
+        } else {
+            throw new FileNotFoundException("File '" + file + "' does not exist");
+        }
+        return new FileInputStream(file);
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Opens a {@link FileOutputStream} for the specified file, checking and
+     * creating the parent directory if it does not exist.
+     * <p/>
+     * At the end of the method either the stream will be successfully opened,
+     * or an exception will have been thrown.
+     * <p/>
+     * The parent directory will be created if it does not exist.
+     * The file will be created if it does not exist.
+     * An exception is thrown if the file object exists but is a directory.
+     * An exception is thrown if the file exists but cannot be written to.
+     * An exception is thrown if the parent directory cannot be created.
+     *
+     * @param file the file to open for output, must not be {@code null}
+     * @return a new {@link FileOutputStream} for the specified file
+     * @throws IOException if the file object is a directory
+     * @throws IOException if the file cannot be written to
+     * @throws IOException if a parent directory needs creating but that fails
+     * @since 1.3
+     */
+    public static FileOutputStream openOutputStream(File file) throws IOException {
+        return openOutputStream(file, false);
+    }
+
+    /**
+     * Opens a {@link FileOutputStream} for the specified file, checking and
+     * creating the parent directory if it does not exist.
+     * <p/>
+     * At the end of the method either the stream will be successfully opened,
+     * or an exception will have been thrown.
+     * <p/>
+     * The parent directory will be created if it does not exist.
+     * The file will be created if it does not exist.
+     * An exception is thrown if the file object exists but is a directory.
+     * An exception is thrown if the file exists but cannot be written to.
+     * An exception is thrown if the parent directory cannot be created.
+     *
+     * @param file   the file to open for output, must not be {@code null}
+     * @param append if {@code true}, then bytes will be added to the
+     *               end of the file rather than overwriting
+     * @return a new {@link FileOutputStream} for the specified file
+     * @throws IOException if the file object is a directory
+     * @throws IOException if the file cannot be written to
+     * @throws IOException if a parent directory needs creating but that fails
+     * @since 2.1
+     */
+    public static FileOutputStream openOutputStream(File file, boolean append) throws IOException {
+        if (file.exists()) {
+            if (file.isDirectory()) {
+                throw new IOException("File '" + file + "' exists but is a directory");
+            }
+            if (file.canWrite() == false) {
+                throw new IOException("File '" + file + "' cannot be written to");
+            }
+        } else {
+            File parent = file.getParentFile();
+            if (parent != null) {
+                if (!parent.mkdirs() && !parent.isDirectory()) {
+                    throw new IOException("Directory '" + parent + "' could not be created");
+                }
+            }
+        }
+        return new FileOutputStream(file, append);
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Returns a human-readable version of the file size, where the input represents a specific number of bytes.
+     * <p>
+     * If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the
+     * nearest GB boundary.
+     * </p>
+     * <p>
+     * Similarly for the 1MB and 1KB boundaries.
+     * </p>
+     *
+     * @param size the number of bytes
+     * @return a human-readable display value (includes units - EB, PB, TB, GB, MB, KB or bytes)
+     * @see <a href="https://issues.apache.org/jira/browse/IO-226">IO-226 - should the rounding be changed?</a>
+     * @since 2.4
+     */
+    // See https://issues.apache.org/jira/browse/IO-226 - should the rounding be changed?
+    public static String byteCountToDisplaySize(BigInteger size) {
+        String displaySize;
+
+        if (size.divide(ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {
+            displaySize = String.valueOf(size.divide(ONE_EB_BI)) + " EB";
+        } else if (size.divide(ONE_PB_BI).compareTo(BigInteger.ZERO) > 0) {
+            displaySize = String.valueOf(size.divide(ONE_PB_BI)) + " PB";
+        } else if (size.divide(ONE_TB_BI).compareTo(BigInteger.ZERO) > 0) {
+            displaySize = String.valueOf(size.divide(ONE_TB_BI)) + " TB";
+        } else if (size.divide(ONE_GB_BI).compareTo(BigInteger.ZERO) > 0) {
+            displaySize = String.valueOf(size.divide(ONE_GB_BI)) + " GB";
+        } else if (size.divide(ONE_MB_BI).compareTo(BigInteger.ZERO) > 0) {
+            displaySize = String.valueOf(size.divide(ONE_MB_BI)) + " MB";
+        } else if (size.divide(ONE_KB_BI).compareTo(BigInteger.ZERO) > 0) {
+            displaySize = String.valueOf(size.divide(ONE_KB_BI)) + " KB";
+        } else {
+            displaySize = String.valueOf(size) + " bytes";
+        }
+        return displaySize;
+    }
+
+    /**
+     * Returns a human-readable version of the file size, where the input represents a specific number of bytes.
+     * <p>
+     * If the size is over 1GB, the size is returned as the number of whole GB, i.e. the size is rounded down to the
+     * nearest GB boundary.
+     * </p>
+     * <p>
+     * Similarly for the 1MB and 1KB boundaries.
+     * </p>
+     *
+     * @param size the number of bytes
+     * @return a human-readable display value (includes units - EB, PB, TB, GB, MB, KB or bytes)
+     * @see <a href="https://issues.apache.org/jira/browse/IO-226">IO-226 - should the rounding be changed?</a>
+     */
+    // See https://issues.apache.org/jira/browse/IO-226 - should the rounding be changed?
+    public static String byteCountToDisplaySize(long size) {
+        return byteCountToDisplaySize(BigInteger.valueOf(size));
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Implements the same behaviour as the "touch" utility on Unix. It creates
+     * a new file with size 0 or, if the file exists already, it is opened and
+     * closed without modifying it, but updating the file date and time.
+     * <p/>
+     * NOTE: As from v1.3, this method throws an IOException if the last
+     * modified date of the file cannot be set. Also, as from v1.3 this method
+     * creates parent directories if they do not exist.
+     *
+     * @param file the File to touch
+     * @throws IOException If an I/O problem occurs
+     */
+    public static void touch(File file) throws IOException {
+        if (!file.exists()) {
+            OutputStream out = openOutputStream(file);
+            IOUtils.closeQuietly(out);
+        }
+        boolean success = file.setLastModified(System.currentTimeMillis());
+        if (!success) {
+            throw new IOException("Unable to set the last modification time for " + file);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Converts a Collection containing java.io.File instanced into array
+     * representation. This is to account for the difference between
+     * File.listFiles() and FileUtils.listFiles().
+     *
+     * @param files a Collection containing java.io.File instances
+     * @return an array of java.io.File
+     */
+    public static File[] convertFileCollectionToFileArray(Collection<File> files) {
+        return files.toArray(new File[files.size()]);
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Converts an array of file extensions to suffixes for use
+     * with IOFileFilters.
+     *
+     * @param extensions an array of extensions. Format: {"java", "xml"}
+     * @return an array of suffixes. Format: {".java", ".xml"}
+     */
+    private static String[] toSuffixes(String[] extensions) {
+        String[] suffixes = new String[extensions.length];
+        for (int i = 0; i < extensions.length; i++) {
+            suffixes[i] = "." + extensions[i];
+        }
+        return suffixes;
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Compares the contents of two files to determine if they are equal or not.
+     * <p/>
+     * This method checks to see if the two files are different lengths
+     * or if they point to the same file, before resorting to byte-by-byte
+     * comparison of the contents.
+     * <p/>
+     * Code origin: Avalon
+     *
+     * @param file1 the first file
+     * @param file2 the second file
+     * @return true if the content of the files are equal or they both don't
+     * exist, false otherwise
+     * @throws IOException in case of an I/O error
+     */
+    public static boolean contentEquals(File file1, File file2) throws IOException {
+        boolean file1Exists = file1.exists();
+        if (file1Exists != file2.exists()) {
+            return false;
+        }
+
+        if (!file1Exists) {
+            // two not existing files are equal
+            return true;
+        }
+
+        if (file1.isDirectory() || file2.isDirectory()) {
+            // don't want to compare directory contents
+            throw new IOException("Can't compare directories, only files");
+        }
+
+        if (file1.length() != file2.length()) {
+            // lengths differ, cannot be equal
+            return false;
+        }
+
+        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {
+            // same file
+            return true;
+        }
+
+        InputStream input1 = null;
+        InputStream input2 = null;
+        try {
+            input1 = new FileInputStream(file1);
+            input2 = new FileInputStream(file2);
+            return IOUtils.contentEquals(input1, input2);
+
+        } finally {
+            IOUtils.closeQuietly(input1);
+            IOUtils.closeQuietly(input2);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Compares the contents of two files to determine if they are equal or not.
+     * <p/>
+     * This method checks to see if the two files point to the same file,
+     * before resorting to line-by-line comparison of the contents.
+     * <p/>
+     *
+     * @param file1       the first file
+     * @param file2       the second file
+     * @param charsetName the character encoding to be used.
+     *                    May be null, in which case the platform default is used
+     * @return true if the content of the files are equal or neither exists,
+     * false otherwise
+     * @throws IOException in case of an I/O error
+     * @see IOUtils#contentEqualsIgnoreEOL(Reader, Reader)
+     * @since 2.2
+     */
+    public static boolean contentEqualsIgnoreEOL(File file1, File file2, String charsetName) throws IOException {
+        boolean file1Exists = file1.exists();
+        if (file1Exists != file2.exists()) {
+            return false;
+        }
+
+        if (!file1Exists) {
+            // two not existing files are equal
+            return true;
+        }
+
+        if (file1.isDirectory() || file2.isDirectory()) {
+            // don't want to compare directory contents
+            throw new IOException("Can't compare directories, only files");
+        }
+
+        if (file1.getCanonicalFile().equals(file2.getCanonicalFile())) {
+            // same file
+            return true;
+        }
+
+        Reader input1 = null;
+        Reader input2 = null;
+        try {
+            if (charsetName == null) {
+                input1 = new InputStreamReader(new FileInputStream(file1));
+                input2 = new InputStreamReader(new FileInputStream(file2));
+            } else {
+                input1 = new InputStreamReader(new FileInputStream(file1), charsetName);
+                input2 = new InputStreamReader(new FileInputStream(file2), charsetName);
+            }
+            return IOUtils.contentEqualsIgnoreEOL(input1, input2);
+
+        } finally {
+            IOUtils.closeQuietly(input1);
+            IOUtils.closeQuietly(input2);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Convert from a <code>URL</code> to a <code>File</code>.
+     * <p/>
+     * From version 1.1 this method will decode the URL.
+     * Syntax such as <code>file:///my%20docs/file.txt</code> will be
+     * correctly decoded to <code>/my docs/file.txt</code>. Starting with version
+     * 1.5, this method uses UTF-8 to decode percent-encoded octets to characters.
+     * Additionally, malformed percent-encoded octets are handled leniently by
+     * passing them through literally.
+     *
+     * @param url the file URL to convert, {@code null} returns {@code null}
+     * @return the equivalent <code>File</code> object, or {@code null}
+     * if the URL's protocol is not <code>file</code>
+     */
+    public static File toFile(URL url) {
+        if (url == null || !"file".equalsIgnoreCase(url.getProtocol())) {
+            return null;
+        } else {
+            String filename = url.getFile().replace('/', File.separatorChar);
+            filename = decodeUrl(filename);
+            return new File(filename);
+        }
+    }
+
+    /**
+     * Decodes the specified URL as per RFC 3986, i.e. transforms
+     * percent-encoded octets to characters by decoding with the UTF-8 character
+     * set. This function is primarily intended for usage with
+     * {@link URL} which unfortunately does not enforce proper URLs. As
+     * such, this method will leniently accept invalid characters or malformed
+     * percent-encoded octets and simply pass them literally through to the
+     * result string. Except for rare edge cases, this will make unencoded URLs
+     * pass through unaltered.
+     *
+     * @param url The URL to decode, may be {@code null}.
+     * @return The decoded URL or {@code null} if the input was
+     * {@code null}.
+     */
+    static String decodeUrl(String url) {
+        String decoded = url;
+        if (url != null && url.indexOf('%') >= 0) {
+            int n = url.length();
+            StringBuffer buffer = new StringBuffer();
+            ByteBuffer bytes = ByteBuffer.allocate(n);
+            for (int i = 0; i < n; ) {
+                if (url.charAt(i) == '%') {
+                    try {
+                        do {
+                            byte octet = (byte) Integer.parseInt(url.substring(i + 1, i + 3), 16);
+                            bytes.put(octet);
+                            i += 3;
+                        } while (i < n && url.charAt(i) == '%');
+                        continue;
+                    } catch (RuntimeException e) {
+                        // malformed percent-encoded octet, fall through and
+                        // append characters literally
+                    } finally {
+                        if (bytes.position() > 0) {
+                            bytes.flip();
+                            buffer.append(UTF8.decode(bytes).toString());
+                            bytes.clear();
+                        }
+                    }
+                }
+                buffer.append(url.charAt(i++));
+            }
+            decoded = buffer.toString();
+        }
+        return decoded;
+    }
+
+    /**
+     * Converts each of an array of <code>URL</code> to a <code>File</code>.
+     * <p/>
+     * Returns an array of the same size as the input.
+     * If the input is {@code null}, an empty array is returned.
+     * If the input contains {@code null}, the output array contains {@code null} at the same
+     * index.
+     * <p/>
+     * This method will decode the URL.
+     * Syntax such as <code>file:///my%20docs/file.txt</code> will be
+     * correctly decoded to <code>/my docs/file.txt</code>.
+     *
+     * @param urls the file URLs to convert, {@code null} returns empty array
+     * @return a non-{@code null} array of Files matching the input, with a {@code null} item
+     * if there was a {@code null} at that index in the input array
+     * @throws IllegalArgumentException if any file is not a URL file
+     * @throws IllegalArgumentException if any file is incorrectly encoded
+     * @since 1.1
+     */
+    public static File[] toFiles(URL[] urls) {
+        if (urls == null || urls.length == 0) {
+            return EMPTY_FILE_ARRAY;
+        }
+        File[] files = new File[urls.length];
+        for (int i = 0; i < urls.length; i++) {
+            URL url = urls[i];
+            if (url != null) {
+                if (url.getProtocol().equals("file") == false) {
+                    throw new IllegalArgumentException(
+                            "URL could not be converted to a File: " + url);
+                }
+                files[i] = toFile(url);
+            }
+        }
+        return files;
+    }
+
+    /**
+     * Converts each of an array of <code>File</code> to a <code>URL</code>.
+     * <p/>
+     * Returns an array of the same size as the input.
+     *
+     * @param files the files to convert, must not be {@code null}
+     * @return an array of URLs matching the input
+     * @throws IOException  if a file cannot be converted
+     * @throws NullPointerException if the parameter is null
+     */
+    public static URL[] toURLs(File[] files) throws IOException {
+        URL[] urls = new URL[files.length];
+
+        for (int i = 0; i < urls.length; i++) {
+            urls[i] = files[i].toURI().toURL();
+        }
+
+        return urls;
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copies a file to a directory preserving the file date.
+     * <p/>
+     * This method copies the contents of the specified source file
+     * to a file of the same name in the specified destination directory.
+     * The destination directory is created if it does not exist.
+     * If the destination file exists, then this method will overwrite it.
+     * <p/>
+     * <strong>Note:</strong> This method tries to preserve the file's last
+     * modified date/times using {@link File#setLastModified(long)}, however
+     * it is not guaranteed that the operation will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcFile an existing file to copy, must not be {@code null}
+     * @param destDir the directory to place the copy in, must not be {@code null}
+     * @throws NullPointerException if source or destination is null
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @see #copyFile(File, File, boolean)
+     */
+    public static void copyFileToDirectory(File srcFile, File destDir) throws IOException {
+        copyFileToDirectory(srcFile, destDir, true);
+    }
+
+    /**
+     * Copies a file to a directory optionally preserving the file date.
+     * <p/>
+     * This method copies the contents of the specified source file
+     * to a file of the same name in the specified destination directory.
+     * The destination directory is created if it does not exist.
+     * If the destination file exists, then this method will overwrite it.
+     * <p/>
+     * <strong>Note:</strong> Setting <code>preserveFileDate</code> to
+     * {@code true} tries to preserve the file's last modified
+     * date/times using {@link File#setLastModified(long)}, however it is
+     * not guaranteed that the operation will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcFile          an existing file to copy, must not be {@code null}
+     * @param destDir          the directory to place the copy in, must not be {@code null}
+     * @param preserveFileDate true if the file date of the copy
+     *                         should be the same as the original
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @see #copyFile(File, File, boolean)
+     * @since 1.3
+     */
+    public static void copyFileToDirectory(File srcFile, File destDir, boolean preserveFileDate) throws IOException {
+        if (destDir == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (destDir.exists() && destDir.isDirectory() == false) {
+            throw new IllegalArgumentException("Destination '" + destDir + "' is not a directory");
+        }
+        File destFile = new File(destDir, srcFile.getName());
+        copyFile(srcFile, destFile, preserveFileDate);
+    }
+
+    /**
+     * Copies a file to a new location preserving the file date.
+     * <p/>
+     * This method copies the contents of the specified source file to the
+     * specified destination file. The directory holding the destination file is
+     * created if it does not exist. If the destination file exists, then this
+     * method will overwrite it.
+     * <p/>
+     * <strong>Note:</strong> This method tries to preserve the file's last
+     * modified date/times using {@link File#setLastModified(long)}, however
+     * it is not guaranteed that the operation will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcFile  an existing file to copy, must not be {@code null}
+     * @param destFile the new file, must not be {@code null}
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @see #copyFileToDirectory(File, File)
+     */
+    public static void copyFile(File srcFile, File destFile) throws IOException {
+        copyFile(srcFile, destFile, true);
+    }
+
+    /**
+     * Copies a file to a new location.
+     * <p/>
+     * This method copies the contents of the specified source file
+     * to the specified destination file.
+     * The directory holding the destination file is created if it does not exist.
+     * If the destination file exists, then this method will overwrite it.
+     * <p/>
+     * <strong>Note:</strong> Setting <code>preserveFileDate</code> to
+     * {@code true} tries to preserve the file's last modified
+     * date/times using {@link File#setLastModified(long)}, however it is
+     * not guaranteed that the operation will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcFile          an existing file to copy, must not be {@code null}
+     * @param destFile         the new file, must not be {@code null}
+     * @param preserveFileDate true if the file date of the copy
+     *                         should be the same as the original
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @see #copyFileToDirectory(File, File, boolean)
+     */
+    public static void copyFile(File srcFile, File destFile,
+                                boolean preserveFileDate) throws IOException {
+        if (srcFile == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destFile == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (srcFile.exists() == false) {
+            throw new FileNotFoundException("Source '" + srcFile + "' does not exist");
+        }
+        if (srcFile.isDirectory()) {
+            throw new IOException("Source '" + srcFile + "' exists but is a directory");
+        }
+        if (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath())) {
+            throw new IOException("Source '" + srcFile + "' and destination '" + destFile + "' are the same");
+        }
+        File parentFile = destFile.getParentFile();
+        if (parentFile != null) {
+            if (!parentFile.mkdirs() && !parentFile.isDirectory()) {
+                throw new IOException("Destination '" + parentFile + "' directory cannot be created");
+            }
+        }
+        if (destFile.exists() && destFile.canWrite() == false) {
+            throw new IOException("Destination '" + destFile + "' exists but is read-only");
+        }
+        doCopyFile(srcFile, destFile, preserveFileDate);
+    }
+
+    /**
+     * Copy bytes from a <code>File</code> to an <code>OutputStream</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a <code>BufferedInputStream</code>.
+     * </p>
+     *
+     * @param input  the <code>File</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException  if an I/O error occurs
+     * @since 2.1
+     */
+    public static long copyFile(File input, OutputStream output) throws IOException {
+        final FileInputStream fis = new FileInputStream(input);
+        try {
+            return IOUtils.copyLarge(fis, output);
+        } finally {
+            fis.close();
+        }
+    }
+
+    /**
+     * Internal copy file method.
+     *
+     * @param srcFile          the validated source file, must not be {@code null}
+     * @param destFile         the validated destination file, must not be {@code null}
+     * @param preserveFileDate whether to preserve the file date
+     * @throws IOException if an error occurs
+     */
+    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {
+        if (destFile.exists() && destFile.isDirectory()) {
+            throw new IOException("Destination '" + destFile + "' exists but is a directory");
+        }
+
+        FileInputStream fis = null;
+        FileOutputStream fos = null;
+        FileChannel input = null;
+        FileChannel output = null;
+        try {
+            fis = new FileInputStream(srcFile);
+            fos = new FileOutputStream(destFile);
+            input = fis.getChannel();
+            output = fos.getChannel();
+            long size = input.size();
+            long pos = 0;
+            long count = 0;
+            while (pos < size) {
+                count = size - pos > FILE_COPY_BUFFER_SIZE ? FILE_COPY_BUFFER_SIZE : size - pos;
+                pos += output.transferFrom(input, pos, count);
+            }
+        } finally {
+            IOUtils.closeQuietly(output);
+            IOUtils.closeQuietly(fos);
+            IOUtils.closeQuietly(input);
+            IOUtils.closeQuietly(fis);
+        }
+
+        if (srcFile.length() != destFile.length()) {
+            throw new IOException("Failed to copy full contents from '" +
+                    srcFile + "' to '" + destFile + "'");
+        }
+        if (preserveFileDate) {
+            destFile.setLastModified(srcFile.lastModified());
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copies a directory to within another directory preserving the file dates.
+     * <p/>
+     * This method copies the source directory and all its contents to a
+     * directory of the same name in the specified destination directory.
+     * <p/>
+     * The destination directory is created if it does not exist.
+     * If the destination directory did exist, then this method merges
+     * the source with the destination, with the source taking precedence.
+     * <p/>
+     * <strong>Note:</strong> This method tries to preserve the files' last
+     * modified date/times using {@link File#setLastModified(long)}, however
+     * it is not guaranteed that those operations will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcDir  an existing directory to copy, must not be {@code null}
+     * @param destDir the directory to place the copy in, must not be {@code null}
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @since 1.2
+     */
+    public static void copyDirectoryToDirectory(File srcDir, File destDir) throws IOException {
+        if (srcDir == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (srcDir.exists() && srcDir.isDirectory() == false) {
+            throw new IllegalArgumentException("Source '" + destDir + "' is not a directory");
+        }
+        if (destDir == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (destDir.exists() && destDir.isDirectory() == false) {
+            throw new IllegalArgumentException("Destination '" + destDir + "' is not a directory");
+        }
+        copyDirectory(srcDir, new File(destDir, srcDir.getName()), true);
+    }
+
+    /**
+     * Copies a whole directory to a new location preserving the file dates.
+     * <p/>
+     * This method copies the specified directory and all its child
+     * directories and files to the specified destination.
+     * The destination is the new location and name of the directory.
+     * <p/>
+     * The destination directory is created if it does not exist.
+     * If the destination directory did exist, then this method merges
+     * the source with the destination, with the source taking precedence.
+     * <p/>
+     * <strong>Note:</strong> This method tries to preserve the files' last
+     * modified date/times using {@link File#setLastModified(long)}, however
+     * it is not guaranteed that those operations will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcDir  an existing directory to copy, must not be {@code null}
+     * @param destDir the new directory, must not be {@code null}
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @since 1.1
+     */
+    public static void copyDirectory(File srcDir, File destDir) throws IOException {
+        copyDirectory(srcDir, destDir, true);
+    }
+
+    /**
+     * Copies a whole directory to a new location.
+     * <p/>
+     * This method copies the contents of the specified source directory
+     * to within the specified destination directory.
+     * <p/>
+     * The destination directory is created if it does not exist.
+     * If the destination directory did exist, then this method merges
+     * the source with the destination, with the source taking precedence.
+     * <p/>
+     * <strong>Note:</strong> Setting <code>preserveFileDate</code> to
+     * {@code true} tries to preserve the files' last modified
+     * date/times using {@link File#setLastModified(long)}, however it is
+     * not guaranteed that those operations will succeed.
+     * If the modification operation fails, no indication is provided.
+     *
+     * @param srcDir           an existing directory to copy, must not be {@code null}
+     * @param destDir          the new directory, must not be {@code null}
+     * @param preserveFileDate true if the file date of the copy
+     *                         should be the same as the original
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @since 1.1
+     */
+    public static void copyDirectory(File srcDir, File destDir,
+                                     boolean preserveFileDate) throws IOException {
+        copyDirectory(srcDir, destDir, null, preserveFileDate);
+    }
+
+    /**
+     * Copies a filtered directory to a new location preserving the file dates.
+     * <p/>
+     * This method copies the contents of the specified source directory
+     * to within the specified destination directory.
+     * <p/>
+     * The destination directory is created if it does not exist.
+     * If the destination directory did exist, then this method merges
+     * the source with the destination, with the source taking precedence.
+     * <p/>
+     * <strong>Note:</strong> This method tries to preserve the files' last
+     * modified date/times using {@link File#setLastModified(long)}, however
+     * it is not guaranteed that those operations will succeed.
+     * If the modification operation fails, no indication is provided.
+     * <p/>
+     * <h4>Example: Copy directories only</h4>
+     * <pre>
+     *  // only copy the directory structure
+     *  FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY);
+     *  </pre>
+     *
+     * <h4>Example: Copy directories and txt files</h4>
+     * <pre>
+     *  // Create a filter for ".txt" files
+     *  IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
+     *  IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
+     *
+     *  // Create a filter for either directories or ".txt" files
+     *  FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
+     *
+     *  // Copy using the filter
+     *  FileUtils.copyDirectory(srcDir, destDir, filter);
+     *  </pre>
+     *
+     * @param srcDir  an existing directory to copy, must not be {@code null}
+     * @param destDir the new directory, must not be {@code null}
+     * @param filter  the filter to apply, null means copy all directories and files
+     *                should be the same as the original
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @since 1.4
+     */
+    public static void copyDirectory(File srcDir, File destDir,
+                                     FileFilter filter) throws IOException {
+        copyDirectory(srcDir, destDir, filter, true);
+    }
+
+    /**
+     * Copies a filtered directory to a new location.
+     * <p/>
+     * This method copies the contents of the specified source directory
+     * to within the specified destination directory.
+     * <p/>
+     * The destination directory is created if it does not exist.
+     * If the destination directory did exist, then this method merges
+     * the source with the destination, with the source taking precedence.
+     * <p/>
+     * <strong>Note:</strong> Setting <code>preserveFileDate</code> to
+     * {@code true} tries to preserve the files' last modified
+     * date/times using {@link File#setLastModified(long)}, however it is
+     * not guaranteed that those operations will succeed.
+     * If the modification operation fails, no indication is provided.
+     * <p/>
+     * <h4>Example: Copy directories only</h4>
+     * <pre>
+     *  // only copy the directory structure
+     *  FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY, false);
+     *  </pre>
+     *
+     * <h4>Example: Copy directories and txt files</h4>
+     * <pre>
+     *  // Create a filter for ".txt" files
+     *  IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
+     *  IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
+     *
+     *  // Create a filter for either directories or ".txt" files
+     *  FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
+     *
+     *  // Copy using the filter
+     *  FileUtils.copyDirectory(srcDir, destDir, filter, false);
+     *  </pre>
+     *
+     * @param srcDir           an existing directory to copy, must not be {@code null}
+     * @param destDir          the new directory, must not be {@code null}
+     * @param filter           the filter to apply, null means copy all directories and files
+     * @param preserveFileDate true if the file date of the copy
+     *                         should be the same as the original
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs during copying
+     * @since 1.4
+     */
+    public static void copyDirectory(File srcDir, File destDir,
+                                     FileFilter filter, boolean preserveFileDate) throws IOException {
+        if (srcDir == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destDir == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (srcDir.exists() == false) {
+            throw new FileNotFoundException("Source '" + srcDir + "' does not exist");
+        }
+        if (srcDir.isDirectory() == false) {
+            throw new IOException("Source '" + srcDir + "' exists but is not a directory");
+        }
+        if (srcDir.getCanonicalPath().equals(destDir.getCanonicalPath())) {
+            throw new IOException("Source '" + srcDir + "' and destination '" + destDir + "' are the same");
+        }
+
+        // Cater for destination being directory within the source directory (see IO-141)
+        List<String> exclusionList = null;
+        if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath())) {
+            File[] srcFiles = filter == null ? srcDir.listFiles() : srcDir.listFiles(filter);
+            if (srcFiles != null && srcFiles.length > 0) {
+                exclusionList = new ArrayList<String>(srcFiles.length);
+                for (File srcFile : srcFiles) {
+                    File copiedFile = new File(destDir, srcFile.getName());
+                    exclusionList.add(copiedFile.getCanonicalPath());
+                }
+            }
+        }
+        doCopyDirectory(srcDir, destDir, filter, preserveFileDate, exclusionList);
+    }
+
+    /**
+     * Internal copy directory method.
+     *
+     * @param srcDir           the validated source directory, must not be {@code null}
+     * @param destDir          the validated destination directory, must not be {@code null}
+     * @param filter           the filter to apply, null means copy all directories and files
+     * @param preserveFileDate whether to preserve the file date
+     * @param exclusionList    List of files and directories to exclude from the copy, may be null
+     * @throws IOException if an error occurs
+     * @since 1.1
+     */
+    private static void doCopyDirectory(File srcDir, File destDir, FileFilter filter,
+                                        boolean preserveFileDate, List<String> exclusionList) throws IOException {
+        // recurse
+        File[] srcFiles = filter == null ? srcDir.listFiles() : srcDir.listFiles(filter);
+        if (srcFiles == null) {  // null if abstract pathname does not denote a directory, or if an I/O error occurs
+            throw new IOException("Failed to list contents of " + srcDir);
+        }
+        if (destDir.exists()) {
+            if (destDir.isDirectory() == false) {
+                throw new IOException("Destination '" + destDir + "' exists but is not a directory");
+            }
+        } else {
+            if (!destDir.mkdirs() && !destDir.isDirectory()) {
+                throw new IOException("Destination '" + destDir + "' directory cannot be created");
+            }
+        }
+        if (destDir.canWrite() == false) {
+            throw new IOException("Destination '" + destDir + "' cannot be written to");
+        }
+        for (File srcFile : srcFiles) {
+            File dstFile = new File(destDir, srcFile.getName());
+            if (exclusionList == null || !exclusionList.contains(srcFile.getCanonicalPath())) {
+                if (srcFile.isDirectory()) {
+                    doCopyDirectory(srcFile, dstFile, filter, preserveFileDate, exclusionList);
+                } else {
+                    doCopyFile(srcFile, dstFile, preserveFileDate);
+                }
+            }
+        }
+
+        // Do this last, as the above has probably affected directory metadata
+        if (preserveFileDate) {
+            destDir.setLastModified(srcDir.lastModified());
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Copies bytes from the URL <code>source</code> to a file
+     * <code>destination</code>. The directories up to <code>destination</code>
+     * will be created if they don't already exist. <code>destination</code>
+     * will be overwritten if it already exists.
+     * <p/>
+     * Warning: this method does not set a connection or read timeout and thus
+     * might block forever. Use {@link #copyURLToFile(URL, File, int, int)}
+     * with reasonable timeouts to prevent this.
+     *
+     * @param source      the <code>URL</code> to copy bytes from, must not be {@code null}
+     * @param destination the non-directory <code>File</code> to write bytes to
+     *                    (possibly overwriting), must not be {@code null}
+     * @throws IOException if <code>source</code> URL cannot be opened
+     * @throws IOException if <code>destination</code> is a directory
+     * @throws IOException if <code>destination</code> cannot be written
+     * @throws IOException if <code>destination</code> needs creating but can't be
+     * @throws IOException if an IO error occurs during copying
+     */
+    public static void copyURLToFile(URL source, File destination) throws IOException {
+        InputStream input = source.openStream();
+        copyInputStreamToFile(input, destination);
+    }
+
+    /**
+     * Copies bytes from the URL <code>source</code> to a file
+     * <code>destination</code>. The directories up to <code>destination</code>
+     * will be created if they don't already exist. <code>destination</code>
+     * will be overwritten if it already exists.
+     *
+     * @param source            the <code>URL</code> to copy bytes from, must not be {@code null}
+     * @param destination       the non-directory <code>File</code> to write bytes to
+     *                          (possibly overwriting), must not be {@code null}
+     * @param connectionTimeout the number of milliseconds until this method
+     *                          will timeout if no connection could be established to the <code>source</code>
+     * @param readTimeout       the number of milliseconds until this method will
+     *                          timeout if no data could be read from the <code>source</code>
+     * @throws IOException if <code>source</code> URL cannot be opened
+     * @throws IOException if <code>destination</code> is a directory
+     * @throws IOException if <code>destination</code> cannot be written
+     * @throws IOException if <code>destination</code> needs creating but can't be
+     * @throws IOException if an IO error occurs during copying
+     * @since 2.0
+     */
+    public static void copyURLToFile(URL source, File destination,
+                                     int connectionTimeout, int readTimeout) throws IOException {
+        URLConnection connection = source.openConnection();
+        connection.setConnectTimeout(connectionTimeout);
+        connection.setReadTimeout(readTimeout);
+        InputStream input = connection.getInputStream();
+        copyInputStreamToFile(input, destination);
+    }
+
+    /**
+     * Copies bytes from an {@link InputStream} <code>source</code> to a file
+     * <code>destination</code>. The directories up to <code>destination</code>
+     * will be created if they don't already exist. <code>destination</code>
+     * will be overwritten if it already exists.
+     *
+     * @param source      the <code>InputStream</code> to copy bytes from, must not be {@code null}
+     * @param destination the non-directory <code>File</code> to write bytes to
+     *                    (possibly overwriting), must not be {@code null}
+     * @throws IOException if <code>destination</code> is a directory
+     * @throws IOException if <code>destination</code> cannot be written
+     * @throws IOException if <code>destination</code> needs creating but can't be
+     * @throws IOException if an IO error occurs during copying
+     * @since 2.0
+     */
+    public static void copyInputStreamToFile(InputStream source, File destination) throws IOException {
+        try {
+            FileOutputStream output = openOutputStream(destination);
+            try {
+                IOUtils.copy(source, output);
+                output.close(); // don't swallow close Exception if copy completes normally
+            } finally {
+                IOUtils.closeQuietly(output);
+            }
+        } finally {
+            IOUtils.closeQuietly(source);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Deletes a directory recursively.
+     *
+     * @param directory directory to delete
+     * @throws IOException in case deletion is unsuccessful
+     */
+    public static void deleteDirectory(File directory) throws IOException {
+        if (!directory.exists()) {
+            return;
+        }
+
+        if (!isSymlink(directory)) {
+            cleanDirectory(directory);
+        }
+
+        if (!directory.delete()) {
+            String message =
+                    "Unable to delete directory " + directory + ".";
+            throw new IOException(message);
+        }
+    }
+
+    /**
+     * Deletes a file, never throwing an exception. If file is a directory, delete it and all sub-directories.
+     * <p/>
+     * The difference between File.delete() and this method are:
+     * <ul>
+     * <li>A directory to be deleted does not have to be empty.</li>
+     * <li>No exceptions are thrown when a file or directory cannot be deleted.</li>
+     * </ul>
+     *
+     * @param file file or directory to delete, can be {@code null}
+     * @return {@code true} if the file or directory was deleted, otherwise
+     * {@code false}
+     * @since 1.4
+     */
+    public static boolean deleteQuietly(File file) {
+        if (file == null) {
+            return false;
+        }
+        try {
+            if (file.isDirectory()) {
+                cleanDirectory(file);
+            }
+        } catch (Exception ignored) {
+        }
+
+        try {
+            return file.delete();
+        } catch (Exception ignored) {
+            return false;
+        }
+    }
+
+    /**
+     * Cleans a directory without deleting it.
+     *
+     * @param directory directory to clean
+     * @throws IOException in case cleaning is unsuccessful
+     */
+    public static void cleanDirectory(File directory) throws IOException {
+        if (!directory.exists()) {
+            String message = directory + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (!directory.isDirectory()) {
+            String message = directory + " is not a directory";
+            throw new IllegalArgumentException(message);
+        }
+
+        File[] files = directory.listFiles();
+        if (files == null) {  // null if security restricted
+            throw new IOException("Failed to list contents of " + directory);
+        }
+
+        IOException exception = null;
+        for (File file : files) {
+            try {
+                forceDelete(file);
+            } catch (IOException ioe) {
+                exception = ioe;
+            }
+        }
+
+        if (null != exception) {
+            throw exception;
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Waits for NFS to propagate a file creation, imposing a timeout.
+     * <p/>
+     * This method repeatedly tests {@link File#exists()} until it returns
+     * true up to the maximum time specified in seconds.
+     *
+     * @param file    the file to check, must not be {@code null}
+     * @param seconds the maximum time in seconds to wait
+     * @return true if file exists
+     * @throws NullPointerException if the file is {@code null}
+     */
+    public static boolean waitFor(File file, int seconds) {
+        int timeout = 0;
+        int tick = 0;
+        while (!file.exists()) {
+            if (tick++ >= 10) {
+                tick = 0;
+                if (timeout++ > seconds) {
+                    return false;
+                }
+            }
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ignore) {
+                // ignore exception
+            } catch (Exception ex) {
+                break;
+            }
+        }
+        return true;
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Reads the contents of a file into a String.
+     * The file is always closed.
+     *
+     * @param file     the file to read, must not be {@code null}
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @return the file contents, never {@code null}
+     * @throws IOException in case of an I/O error
+     * @since 2.3
+     */
+    public static String readFileToString(File file, Charset encoding) throws IOException {
+        InputStream in = null;
+        try {
+            in = openInputStream(file);
+            return IOUtils.toString(in, Charsets.toCharset(encoding));
+        } finally {
+            IOUtils.closeQuietly(in);
+        }
+    }
+
+    /**
+     * Reads the contents of a file into a String. The file is always closed.
+     *
+     * @param file     the file to read, must not be {@code null}
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @return the file contents, never {@code null}
+     * @throws IOException                          in case of an I/O error
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 2.3
+     */
+    public static String readFileToString(File file, String encoding) throws IOException {
+        return readFileToString(file, Charsets.toCharset(encoding));
+    }
+
+
+    /**
+     * Reads the contents of a file into a String using the default encoding for the VM.
+     * The file is always closed.
+     *
+     * @param file the file to read, must not be {@code null}
+     * @return the file contents, never {@code null}
+     * @throws IOException in case of an I/O error
+     * @since 1.3.1
+     */
+    public static String readFileToString(File file) throws IOException {
+        return readFileToString(file, Charset.defaultCharset());
+    }
+
+    /**
+     * Reads the contents of a file into a byte array.
+     * The file is always closed.
+     *
+     * @param file the file to read, must not be {@code null}
+     * @return the file contents, never {@code null}
+     * @throws IOException in case of an I/O error
+     * @since 1.1
+     */
+    public static byte[] readFileToByteArray(File file) throws IOException {
+        InputStream in = null;
+        try {
+            in = openInputStream(file);
+            return IOUtils.toByteArray(in, file.length());
+        } finally {
+            IOUtils.closeQuietly(in);
+        }
+    }
+
+    /**
+     * Reads the contents of a file line by line to a List of Strings.
+     * The file is always closed.
+     *
+     * @param file     the file to read, must not be {@code null}
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @return the list of Strings representing each line in the file, never {@code null}
+     * @throws IOException in case of an I/O error
+     * @since 2.3
+     */
+    public static List<String> readLines(File file, Charset encoding) throws IOException {
+        InputStream in = null;
+        try {
+            in = openInputStream(file);
+            return IOUtils.readLines(in, Charsets.toCharset(encoding));
+        } finally {
+            IOUtils.closeQuietly(in);
+        }
+    }
+
+    /**
+     * Reads the contents of a file line by line to a List of Strings. The file is always closed.
+     *
+     * @param file     the file to read, must not be {@code null}
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @return the list of Strings representing each line in the file, never {@code null}
+     * @throws IOException                          in case of an I/O error
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported.
+     * @since 1.1
+     */
+    public static List<String> readLines(File file, String encoding) throws IOException {
+        return readLines(file, Charsets.toCharset(encoding));
+    }
+
+    /**
+     * Reads the contents of a file line by line to a List of Strings using the default encoding for the VM.
+     * The file is always closed.
+     *
+     * @param file the file to read, must not be {@code null}
+     * @return the list of Strings representing each line in the file, never {@code null}
+     * @throws IOException in case of an I/O error
+     * @since 1.3
+     */
+    public static List<String> readLines(File file) throws IOException {
+        return readLines(file, Charset.defaultCharset());
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Writes a String to a file creating the file if it does not exist.
+     * <p/>
+     * NOTE: As from v1.3, the parent directories of the file will be created
+     * if they do not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     * @since 2.4
+     */
+    public static void writeStringToFile(File file, String data, Charset encoding) throws IOException {
+        writeStringToFile(file, data, encoding, false);
+    }
+
+    /**
+     * Writes a String to a file creating the file if it does not exist.
+     * <p/>
+     * NOTE: As from v1.3, the parent directories of the file will be created
+     * if they do not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     */
+    public static void writeStringToFile(File file, String data, String encoding) throws IOException {
+        writeStringToFile(file, data, encoding, false);
+    }
+
+    /**
+     * Writes a String to a file creating the file if it does not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @param append   if {@code true}, then the String will be added to the
+     *                 end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since 2.3
+     */
+    public static void writeStringToFile(File file, String data, Charset encoding, boolean append) throws IOException {
+        OutputStream out = null;
+        try {
+            out = openOutputStream(file, append);
+            IOUtils.write(data, out, encoding);
+            out.close(); // don't swallow close Exception if copy completes normally
+        } finally {
+            IOUtils.closeQuietly(out);
+        }
+    }
+
+    /**
+     * Writes a String to a file creating the file if it does not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @param append   if {@code true}, then the String will be added to the
+     *                 end of the file rather than overwriting
+     * @throws IOException                          in case of an I/O error
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported by the VM
+     * @since 2.1
+     */
+    public static void writeStringToFile(File file, String data, String encoding, boolean append) throws IOException {
+        writeStringToFile(file, data, Charsets.toCharset(encoding), append);
+    }
+
+    /**
+     * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.
+     *
+     * @param file the file to write
+     * @param data the content to write to the file
+     * @throws IOException in case of an I/O error
+     */
+    public static void writeStringToFile(File file, String data) throws IOException {
+        writeStringToFile(file, data, Charset.defaultCharset(), false);
+    }
+
+    /**
+     * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.
+     *
+     * @param file   the file to write
+     * @param data   the content to write to the file
+     * @param append if {@code true}, then the String will be added to the
+     *               end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since 2.1
+     */
+    public static void writeStringToFile(File file, String data, boolean append) throws IOException {
+        writeStringToFile(file, data, Charset.defaultCharset(), append);
+    }
+
+    /**
+     * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.
+     *
+     * @param file the file to write
+     * @param data the content to write to the file
+     * @throws IOException in case of an I/O error
+     * @since 2.0
+     */
+    public static void write(File file, CharSequence data) throws IOException {
+        write(file, data, Charset.defaultCharset(), false);
+    }
+
+    /**
+     * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.
+     *
+     * @param file   the file to write
+     * @param data   the content to write to the file
+     * @param append if {@code true}, then the data will be added to the
+     *               end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since 2.1
+     */
+    public static void write(File file, CharSequence data, boolean append) throws IOException {
+        write(file, data, Charset.defaultCharset(), append);
+    }
+
+    /**
+     * Writes a CharSequence to a file creating the file if it does not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @throws IOException in case of an I/O error
+     * @since 2.3
+     */
+    public static void write(File file, CharSequence data, Charset encoding) throws IOException {
+        write(file, data, encoding, false);
+    }
+
+    /**
+     * Writes a CharSequence to a file creating the file if it does not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     * @since 2.0
+     */
+    public static void write(File file, CharSequence data, String encoding) throws IOException {
+        write(file, data, encoding, false);
+    }
+
+    /**
+     * Writes a CharSequence to a file creating the file if it does not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @param append   if {@code true}, then the data will be added to the
+     *                 end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since 2.3
+     */
+    public static void write(File file, CharSequence data, Charset encoding, boolean append) throws IOException {
+        String str = data == null ? null : data.toString();
+        writeStringToFile(file, str, encoding, append);
+    }
+
+    /**
+     * Writes a CharSequence to a file creating the file if it does not exist.
+     *
+     * @param file     the file to write
+     * @param data     the content to write to the file
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @param append   if {@code true}, then the data will be added to the
+     *                 end of the file rather than overwriting
+     * @throws IOException                          in case of an I/O error
+     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not
+     *                                                      supported by the VM
+     * @since IO 2.1
+     */
+    public static void write(File file, CharSequence data, String encoding, boolean append) throws IOException {
+        write(file, data, Charsets.toCharset(encoding), append);
+    }
+
+    /**
+     * Writes a byte array to a file creating the file if it does not exist.
+     * <p/>
+     * NOTE: As from v1.3, the parent directories of the file will be created
+     * if they do not exist.
+     *
+     * @param file the file to write to
+     * @param data the content to write to the file
+     * @throws IOException in case of an I/O error
+     * @since 1.1
+     */
+    public static void writeByteArrayToFile(File file, byte[] data) throws IOException {
+        writeByteArrayToFile(file, data, false);
+    }
+
+    /**
+     * Writes a byte array to a file creating the file if it does not exist.
+     *
+     * @param file   the file to write to
+     * @param data   the content to write to the file
+     * @param append if {@code true}, then bytes will be added to the
+     *               end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since IO 2.1
+     */
+    public static void writeByteArrayToFile(File file, byte[] data, boolean append) throws IOException {
+        OutputStream out = null;
+        try {
+            out = openOutputStream(file, append);
+            out.write(data);
+            out.close(); // don't swallow close Exception if copy completes normally
+        } finally {
+            IOUtils.closeQuietly(out);
+        }
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The specified character encoding and the default line ending will be used.
+     * <p/>
+     * NOTE: As from v1.3, the parent directories of the file will be created
+     * if they do not exist.
+     *
+     * @param file     the file to write to
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @param lines    the lines to write, {@code null} entries produce blank lines
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     * @since 1.1
+     */
+    public static void writeLines(File file, String encoding, Collection<?> lines) throws IOException {
+        writeLines(file, encoding, lines, null, false);
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line, optionally appending.
+     * The specified character encoding and the default line ending will be used.
+     *
+     * @param file     the file to write to
+     * @param encoding the encoding to use, {@code null} means platform default
+     * @param lines    the lines to write, {@code null} entries produce blank lines
+     * @param append   if {@code true}, then the lines will be added to the
+     *                 end of the file rather than overwriting
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     * @since 2.1
+     */
+    public static void writeLines(File file, String encoding, Collection<?> lines, boolean append) throws IOException {
+        writeLines(file, encoding, lines, null, append);
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The default VM encoding and the default line ending will be used.
+     *
+     * @param file  the file to write to
+     * @param lines the lines to write, {@code null} entries produce blank lines
+     * @throws IOException in case of an I/O error
+     * @since 1.3
+     */
+    public static void writeLines(File file, Collection<?> lines) throws IOException {
+        writeLines(file, null, lines, null, false);
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The default VM encoding and the default line ending will be used.
+     *
+     * @param file   the file to write to
+     * @param lines  the lines to write, {@code null} entries produce blank lines
+     * @param append if {@code true}, then the lines will be added to the
+     *               end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since 2.1
+     */
+    public static void writeLines(File file, Collection<?> lines, boolean append) throws IOException {
+        writeLines(file, null, lines, null, append);
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The specified character encoding and the line ending will be used.
+     * <p/>
+     * NOTE: As from v1.3, the parent directories of the file will be created
+     * if they do not exist.
+     *
+     * @param file       the file to write to
+     * @param encoding   the encoding to use, {@code null} means platform default
+     * @param lines      the lines to write, {@code null} entries produce blank lines
+     * @param lineEnding the line separator to use, {@code null} is system default
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     * @since 1.1
+     */
+    public static void writeLines(File file, String encoding, Collection<?> lines, String lineEnding)
+            throws IOException {
+        writeLines(file, encoding, lines, lineEnding, false);
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The specified character encoding and the line ending will be used.
+     *
+     * @param file       the file to write to
+     * @param encoding   the encoding to use, {@code null} means platform default
+     * @param lines      the lines to write, {@code null} entries produce blank lines
+     * @param lineEnding the line separator to use, {@code null} is system default
+     * @param append     if {@code true}, then the lines will be added to the
+     *                   end of the file rather than overwriting
+     * @throws IOException                  in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported by the VM
+     * @since 2.1
+     */
+    public static void writeLines(File file, String encoding, Collection<?> lines, String lineEnding, boolean append)
+            throws IOException {
+        FileOutputStream out = null;
+        try {
+            out = openOutputStream(file, append);
+            final BufferedOutputStream buffer = new BufferedOutputStream(out);
+            IOUtils.writeLines(lines, lineEnding, buffer, encoding);
+            buffer.flush();
+            out.close(); // don't swallow close Exception if copy completes normally
+        } finally {
+            IOUtils.closeQuietly(out);
+        }
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The default VM encoding and the specified line ending will be used.
+     *
+     * @param file       the file to write to
+     * @param lines      the lines to write, {@code null} entries produce blank lines
+     * @param lineEnding the line separator to use, {@code null} is system default
+     * @throws IOException in case of an I/O error
+     * @since 1.3
+     */
+    public static void writeLines(File file, Collection<?> lines, String lineEnding) throws IOException {
+        writeLines(file, null, lines, lineEnding, false);
+    }
+
+    /**
+     * Writes the <code>toString()</code> value of each item in a collection to
+     * the specified <code>File</code> line by line.
+     * The default VM encoding and the specified line ending will be used.
+     *
+     * @param file       the file to write to
+     * @param lines      the lines to write, {@code null} entries produce blank lines
+     * @param lineEnding the line separator to use, {@code null} is system default
+     * @param append     if {@code true}, then the lines will be added to the
+     *                   end of the file rather than overwriting
+     * @throws IOException in case of an I/O error
+     * @since 2.1
+     */
+    public static void writeLines(File file, Collection<?> lines, String lineEnding, boolean append)
+            throws IOException {
+        writeLines(file, null, lines, lineEnding, append);
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Deletes a file. If file is a directory, delete it and all sub-directories.
+     * <p/>
+     * The difference between File.delete() and this method are:
+     * <ul>
+     * <li>A directory to be deleted does not have to be empty.</li>
+     * <li>You get exceptions when a file or directory cannot be deleted.
+     * (java.io.File methods returns a boolean)</li>
+     * </ul>
+     *
+     * @param file file or directory to delete, must not be {@code null}
+     * @throws NullPointerException          if the directory is {@code null}
+     * @throws FileNotFoundException if the file was not found
+     * @throws IOException           in case deletion is unsuccessful
+     */
+    public static void forceDelete(File file) throws IOException {
+        if (file.isDirectory()) {
+            deleteDirectory(file);
+        } else {
+            boolean filePresent = file.exists();
+            if (!file.delete()) {
+                if (!filePresent) {
+                    throw new FileNotFoundException("File does not exist: " + file);
+                }
+                String message =
+                        "Unable to delete file: " + file;
+                throw new IOException(message);
+            }
+        }
+    }
+
+    /**
+     * Schedules a file to be deleted when JVM exits.
+     * If file is directory delete it and all sub-directories.
+     *
+     * @param file file or directory to delete, must not be {@code null}
+     * @throws NullPointerException if the file is {@code null}
+     * @throws IOException  in case deletion is unsuccessful
+     */
+    public static void forceDeleteOnExit(File file) throws IOException {
+        if (file.isDirectory()) {
+            deleteDirectoryOnExit(file);
+        } else {
+            file.deleteOnExit();
+        }
+    }
+
+    /**
+     * Schedules a directory recursively for deletion on JVM exit.
+     *
+     * @param directory directory to delete, must not be {@code null}
+     * @throws NullPointerException if the directory is {@code null}
+     * @throws IOException  in case deletion is unsuccessful
+     */
+    private static void deleteDirectoryOnExit(File directory) throws IOException {
+        if (!directory.exists()) {
+            return;
+        }
+
+        directory.deleteOnExit();
+        if (!isSymlink(directory)) {
+            cleanDirectoryOnExit(directory);
+        }
+    }
+
+    /**
+     * Cleans a directory without deleting it.
+     *
+     * @param directory directory to clean, must not be {@code null}
+     * @throws NullPointerException if the directory is {@code null}
+     * @throws IOException  in case cleaning is unsuccessful
+     */
+    private static void cleanDirectoryOnExit(File directory) throws IOException {
+        if (!directory.exists()) {
+            String message = directory + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (!directory.isDirectory()) {
+            String message = directory + " is not a directory";
+            throw new IllegalArgumentException(message);
+        }
+
+        File[] files = directory.listFiles();
+        if (files == null) {  // null if security restricted
+            throw new IOException("Failed to list contents of " + directory);
+        }
+
+        IOException exception = null;
+        for (File file : files) {
+            try {
+                forceDeleteOnExit(file);
+            } catch (IOException ioe) {
+                exception = ioe;
+            }
+        }
+
+        if (null != exception) {
+            throw exception;
+        }
+    }
+
+    /**
+     * Makes a directory, including any necessary but nonexistent parent
+     * directories. If a file already exists with specified name but it is
+     * not a directory then an IOException is thrown.
+     * If the directory cannot be created (or does not already exist)
+     * then an IOException is thrown.
+     *
+     * @param directory directory to create, must not be {@code null}
+     * @throws NullPointerException if the directory is {@code null}
+     * @throws IOException  if the directory cannot be created or the file already exists but is not a directory
+     */
+    public static void forceMkdir(File directory) throws IOException {
+        if (directory.exists()) {
+            if (!directory.isDirectory()) {
+                String message =
+                        "File "
+                                + directory
+                                + " exists and is "
+                                + "not a directory. Unable to create directory.";
+                throw new IOException(message);
+            }
+        } else {
+            if (!directory.mkdirs()) {
+                // Double-check that some other thread or process hasn't made
+                // the directory in the background
+                if (!directory.isDirectory()) {
+                    String message =
+                            "Unable to create directory " + directory;
+                    throw new IOException(message);
+                }
+            }
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Returns the size of the specified file or directory. If the provided
+     * {@link File} is a regular file, then the file's length is returned.
+     * If the argument is a directory, then the size of the directory is
+     * calculated recursively. If a directory or subdirectory is security
+     * restricted, its size will not be included.
+     *
+     * @param file the regular file or directory to return the size
+     *             of (must not be {@code null}).
+     * @return the length of the file, or recursive size of the directory,
+     * provided (in bytes).
+     * @throws NullPointerException     if the file is {@code null}
+     * @throws IllegalArgumentException if the file does not exist.
+     * @since 2.0
+     */
+    public static long sizeOf(File file) {
+
+        if (!file.exists()) {
+            String message = file + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (file.isDirectory()) {
+            return sizeOfDirectory(file);
+        } else {
+            return file.length();
+        }
+
+    }
+
+    /**
+     * Returns the size of the specified file or directory. If the provided
+     * {@link File} is a regular file, then the file's length is returned.
+     * If the argument is a directory, then the size of the directory is
+     * calculated recursively. If a directory or subdirectory is security
+     * restricted, its size will not be included.
+     *
+     * @param file the regular file or directory to return the size
+     *             of (must not be {@code null}).
+     * @return the length of the file, or recursive size of the directory,
+     * provided (in bytes).
+     * @throws NullPointerException     if the file is {@code null}
+     * @throws IllegalArgumentException if the file does not exist.
+     * @since 2.4
+     */
+    public static BigInteger sizeOfAsBigInteger(File file) {
+
+        if (!file.exists()) {
+            String message = file + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (file.isDirectory()) {
+            return sizeOfDirectoryAsBigInteger(file);
+        } else {
+            return BigInteger.valueOf(file.length());
+        }
+
+    }
+
+    /**
+     * Counts the size of a directory recursively (sum of the length of all files).
+     *
+     * @param directory directory to inspect, must not be {@code null}
+     * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total
+     * is greater than {@link Long#MAX_VALUE}.
+     * @throws NullPointerException if the directory is {@code null}
+     */
+    public static long sizeOfDirectory(File directory) {
+        checkDirectory(directory);
+
+        final File[] files = directory.listFiles();
+        if (files == null) {  // null if security restricted
+            return 0L;
+        }
+        long size = 0;
+
+        for (final File file : files) {
+            try {
+                if (!isSymlink(file)) {
+                    size += sizeOf(file);
+                    if (size < 0) {
+                        break;
+                    }
+                }
+            } catch (IOException ioe) {
+                // Ignore exceptions caught when asking if a File is a symlink.
+            }
+        }
+
+        return size;
+    }
+
+    /**
+     * Counts the size of a directory recursively (sum of the length of all files).
+     *
+     * @param directory directory to inspect, must not be {@code null}
+     * @return size of directory in bytes, 0 if directory is security restricted.
+     * @throws NullPointerException if the directory is {@code null}
+     * @since 2.4
+     */
+    public static BigInteger sizeOfDirectoryAsBigInteger(File directory) {
+        checkDirectory(directory);
+
+        final File[] files = directory.listFiles();
+        if (files == null) {  // null if security restricted
+            return BigInteger.ZERO;
+        }
+        BigInteger size = BigInteger.ZERO;
+
+        for (final File file : files) {
+            try {
+                if (!isSymlink(file)) {
+                    size = size.add(BigInteger.valueOf(sizeOf(file)));
+                }
+            } catch (IOException ioe) {
+                // Ignore exceptions caught when asking if a File is a symlink.
+            }
+        }
+
+        return size;
+    }
+
+    /**
+     * Checks that the given {@code File} exists and is a directory.
+     *
+     * @param directory The {@code File} to check.
+     * @throws IllegalArgumentException if the given {@code File} does not exist or is not a directory.
+     */
+    private static void checkDirectory(File directory) {
+        if (!directory.exists()) {
+            throw new IllegalArgumentException(directory + " does not exist");
+        }
+        if (!directory.isDirectory()) {
+            throw new IllegalArgumentException(directory + " is not a directory");
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the reference
+     * <code>File</code>.
+     *
+     * @param file      the <code>File</code> of which the modification date must
+     *                  be compared, must not be {@code null}
+     * @param reference the <code>File</code> of which the modification date
+     *                  is used, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified more
+     * recently than the reference <code>File</code>
+     * @throws IllegalArgumentException if the file is {@code null}
+     * @throws IllegalArgumentException if the reference file is {@code null} or doesn't exist
+     */
+    public static boolean isFileNewer(File file, File reference) {
+        if (reference == null) {
+            throw new IllegalArgumentException("No specified reference file");
+        }
+        if (!reference.exists()) {
+            throw new IllegalArgumentException("The reference file '"
+                    + reference + "' doesn't exist");
+        }
+        return isFileNewer(file, reference.lastModified());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>Date</code>.
+     *
+     * @param file the <code>File</code> of which the modification date
+     *             must be compared, must not be {@code null}
+     * @param date the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>Date</code>.
+     * @throws IllegalArgumentException if the file is {@code null}
+     * @throws IllegalArgumentException if the date is {@code null}
+     */
+    public static boolean isFileNewer(File file, Date date) {
+        if (date == null) {
+            throw new IllegalArgumentException("No specified date");
+        }
+        return isFileNewer(file, date.getTime());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * time reference.
+     *
+     * @param file       the <code>File</code> of which the modification date must
+     *                   be compared, must not be {@code null}
+     * @param timeMillis the time reference measured in milliseconds since the
+     *                   epoch (00:00:00 GMT, January 1, 1970)
+     * @return true if the <code>File</code> exists and has been modified after
+     * the given time reference.
+     * @throws IllegalArgumentException if the file is {@code null}
+     */
+    public static boolean isFileNewer(File file, long timeMillis) {
+        if (file == null) {
+            throw new IllegalArgumentException("No specified file");
+        }
+        if (!file.exists()) {
+            return false;
+        }
+        return file.lastModified() > timeMillis;
+    }
+
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Tests if the specified <code>File</code> is older than the reference
+     * <code>File</code>.
+     *
+     * @param file      the <code>File</code> of which the modification date must
+     *                  be compared, must not be {@code null}
+     * @param reference the <code>File</code> of which the modification date
+     *                  is used, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified before
+     * the reference <code>File</code>
+     * @throws IllegalArgumentException if the file is {@code null}
+     * @throws IllegalArgumentException if the reference file is {@code null} or doesn't exist
+     */
+    public static boolean isFileOlder(File file, File reference) {
+        if (reference == null) {
+            throw new IllegalArgumentException("No specified reference file");
+        }
+        if (!reference.exists()) {
+            throw new IllegalArgumentException("The reference file '"
+                    + reference + "' doesn't exist");
+        }
+        return isFileOlder(file, reference.lastModified());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * <code>Date</code>.
+     *
+     * @param file the <code>File</code> of which the modification date
+     *             must be compared, must not be {@code null}
+     * @param date the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * before the given <code>Date</code>.
+     * @throws IllegalArgumentException if the file is {@code null}
+     * @throws IllegalArgumentException if the date is {@code null}
+     */
+    public static boolean isFileOlder(File file, Date date) {
+        if (date == null) {
+            throw new IllegalArgumentException("No specified date");
+        }
+        return isFileOlder(file, date.getTime());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * time reference.
+     *
+     * @param file       the <code>File</code> of which the modification date must
+     *                   be compared, must not be {@code null}
+     * @param timeMillis the time reference measured in milliseconds since the
+     *                   epoch (00:00:00 GMT, January 1, 1970)
+     * @return true if the <code>File</code> exists and has been modified before
+     * the given time reference.
+     * @throws IllegalArgumentException if the file is {@code null}
+     */
+    public static boolean isFileOlder(File file, long timeMillis) {
+        if (file == null) {
+            throw new IllegalArgumentException("No specified file");
+        }
+        if (!file.exists()) {
+            return false;
+        }
+        return file.lastModified() < timeMillis;
+    }
+
+    //-----------------------------------------------------------------------
+
+    /**
+     * Moves a directory.
+     * <p/>
+     * When the destination directory is on another file system, do a "copy and delete".
+     *
+     * @param srcDir  the directory to be moved
+     * @param destDir the destination directory
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws FileExistsException  if the destination directory exists
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs moving the file
+     * @since 1.4
+     */
+    public static void moveDirectory(File srcDir, File destDir) throws IOException {
+        if (srcDir == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destDir == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (!srcDir.exists()) {
+            throw new FileNotFoundException("Source '" + srcDir + "' does not exist");
+        }
+        if (!srcDir.isDirectory()) {
+            throw new IOException("Source '" + srcDir + "' is not a directory");
+        }
+        if (destDir.exists()) {
+            throw new FileExistsException("Destination '" + destDir + "' already exists");
+        }
+        boolean rename = srcDir.renameTo(destDir);
+        if (!rename) {
+            if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath())) {
+                throw new IOException("Cannot move directory: " + srcDir + " to a subdirectory of itself: " + destDir);
+            }
+            copyDirectory(srcDir, destDir);
+            deleteDirectory(srcDir);
+            if (srcDir.exists()) {
+                throw new IOException("Failed to delete original directory '" + srcDir +
+                        "' after copy to '" + destDir + "'");
+            }
+        }
+    }
+
+    /**
+     * Moves a directory to another directory.
+     *
+     * @param src           the file to be moved
+     * @param destDir       the destination file
+     * @param createDestDir If {@code true} create the destination directory,
+     *                      otherwise if {@code false} throw an IOException
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws FileExistsException  if the directory exists in the destination directory
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs moving the file
+     * @since 1.4
+     */
+    public static void moveDirectoryToDirectory(File src, File destDir, boolean createDestDir) throws IOException {
+        if (src == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destDir == null) {
+            throw new NullPointerException("Destination directory must not be null");
+        }
+        if (!destDir.exists() && createDestDir) {
+            destDir.mkdirs();
+        }
+        if (!destDir.exists()) {
+            throw new FileNotFoundException("Destination directory '" + destDir +
+                    "' does not exist [createDestDir=" + createDestDir + "]");
+        }
+        if (!destDir.isDirectory()) {
+            throw new IOException("Destination '" + destDir + "' is not a directory");
+        }
+        moveDirectory(src, new File(destDir, src.getName()));
+
+    }
+
+    /**
+     * Moves a file.
+     * <p/>
+     * When the destination file is on another file system, do a "copy and delete".
+     *
+     * @param srcFile  the file to be moved
+     * @param destFile the destination file
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws FileExistsException  if the destination file exists
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs moving the file
+     * @since 1.4
+     */
+    public static void moveFile(File srcFile, File destFile) throws IOException {
+        if (srcFile == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destFile == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (!srcFile.exists()) {
+            throw new FileNotFoundException("Source '" + srcFile + "' does not exist");
+        }
+        if (srcFile.isDirectory()) {
+            throw new IOException("Source '" + srcFile + "' is a directory");
+        }
+        if (destFile.exists()) {
+            throw new FileExistsException("Destination '" + destFile + "' already exists");
+        }
+        if (destFile.isDirectory()) {
+            throw new IOException("Destination '" + destFile + "' is a directory");
+        }
+        boolean rename = srcFile.renameTo(destFile);
+        if (!rename) {
+            copyFile(srcFile, destFile);
+            if (!srcFile.delete()) {
+                FileUtils.deleteQuietly(destFile);
+                throw new IOException("Failed to delete original file '" + srcFile +
+                        "' after copy to '" + destFile + "'");
+            }
+        }
+    }
+
+    /**
+     * Moves a file to a directory.
+     *
+     * @param srcFile       the file to be moved
+     * @param destDir       the destination file
+     * @param createDestDir If {@code true} create the destination directory,
+     *                      otherwise if {@code false} throw an IOException
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs moving the file
+     * @since 1.4
+     */
+    public static void moveFileToDirectory(File srcFile, File destDir, boolean createDestDir) throws IOException {
+        if (srcFile == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destDir == null) {
+            throw new NullPointerException("Destination directory must not be null");
+        }
+        if (!destDir.exists() && createDestDir) {
+            destDir.mkdirs();
+        }
+        if (!destDir.exists()) {
+            throw new FileNotFoundException("Destination directory '" + destDir +
+                    "' does not exist [createDestDir=" + createDestDir + "]");
+        }
+        if (!destDir.isDirectory()) {
+            throw new IOException("Destination '" + destDir + "' is not a directory");
+        }
+        moveFile(srcFile, new File(destDir, srcFile.getName()));
+    }
+
+    /**
+     * Moves a file or directory to the destination directory.
+     * <p/>
+     * When the destination is on another file system, do a "copy and delete".
+     *
+     * @param src           the file or directory to be moved
+     * @param destDir       the destination directory
+     * @param createDestDir If {@code true} create the destination directory,
+     *                      otherwise if {@code false} throw an IOException
+     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IOException  if source or destination is invalid
+     * @throws IOException  if an IO error occurs moving the file
+     * @since 1.4
+     */
+    public static void moveToDirectory(File src, File destDir, boolean createDestDir) throws IOException {
+        if (src == null) {
+            throw new NullPointerException("Source must not be null");
+        }
+        if (destDir == null) {
+            throw new NullPointerException("Destination must not be null");
+        }
+        if (!src.exists()) {
+            throw new FileNotFoundException("Source '" + src + "' does not exist");
+        }
+        if (src.isDirectory()) {
+            moveDirectoryToDirectory(src, destDir, createDestDir);
+        } else {
+            moveFileToDirectory(src, destDir, createDestDir);
+        }
+    }
+
+    /**
+     * Determines whether the specified file is a Symbolic Link rather than an actual file.
+     * <p/>
+     * Will not return true if there is a Symbolic Link anywhere in the path,
+     * only if the specific file is.
+     * <p/>
+     * <b>Note:</b> the current implementation always returns {@code false} if the system
+     * is detected as Windows using {@link FilenameUtils#isSystemWindows()}
+     *
+     * @param file the file to check
+     * @return true if the file is a Symbolic Link
+     * @throws IOException if an IO error occurs while checking the file
+     * @since 2.0
+     */
+    public static boolean isSymlink(File file) throws IOException {
+        if (file == null) {
+            throw new NullPointerException("File must not be null");
+        }
+        if (FilenameUtils.isSystemWindows()) {
+            return false;
+        }
+        File fileInCanonicalDir = null;
+        if (file.getParent() == null) {
+            fileInCanonicalDir = file;
+        } else {
+            File canonicalDir = file.getParentFile().getCanonicalFile();
+            fileInCanonicalDir = new File(canonicalDir, file.getName());
+        }
+
+        if (fileInCanonicalDir.getCanonicalFile().equals(fileInCanonicalDir.getAbsoluteFile())) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * Indicates that a file already exists.
+     *
+     * @version $Id: FileExistsException.java 1304052 2012-03-22 20:55:29Z ggregory $
+     * @since 2.0
+     */
+    public static class FileExistsException extends IOException {
+
+        /**
+         * Defines the serial version UID.
+         */
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Default Constructor.
+         */
+        public FileExistsException() {
+            super();
+        }
+
+        /**
+         * Construct an instance with the specified message.
+         *
+         * @param message The error message
+         */
+        public FileExistsException(String message) {
+            super(message);
+        }
+
+        /**
+         * Construct an instance with the specified file.
+         *
+         * @param file The file that exists
+         */
+        public FileExistsException(File file) {
+            super("File " + file + " exists");
+        }
+
+    }
+}
Index: timeline/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/main/res/values/strings.xml	(revision )
+++ timeline/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">TimeLine</string>
+</resources>
Index: gradlew.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradlew.bat	(revision )
+++ gradlew.bat	(revision )
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
Index: app/src/main/res/drawable/tab_bg_normal.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/drawable/tab_bg_normal.xml	(revision )
+++ app/src/main/res/drawable/tab_bg_normal.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <solid android:color="#ff303032" />
+</shape>
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/viewholder/MainViewHoder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/viewholder/MainViewHoder.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/viewholder/MainViewHoder.java	(revision )
@@ -0,0 +1,24 @@
+package com.scene.sceneandroiddemo.viewholder;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.widget.TextView;
+
+import com.scene.sceneandroiddemo.R;
+
+import butterknife.Bind;
+import butterknife.ButterKnife;
+
+/**
+ * Created by scene on 16/01/26.
+ */
+public class MainViewHoder extends RecyclerView.ViewHolder {
+    @Bind(R.id.type)
+    public TextView type;
+
+    public MainViewHoder(View itemView) {
+        super(itemView);
+        ButterKnife.bind(this, itemView);
+    }
+
+}
Index: common/src/main/java/com/scene/common/common/assist/KeyguardLock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/KeyguardLock.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/KeyguardLock.java	(revision )
@@ -0,0 +1,86 @@
+package com.scene.common.common.assist;
+
+import android.app.KeyguardManager;
+import android.content.Context;
+import android.os.Build;
+
+import com.scene.common.android.log.Log;
+
+/**
+ * <!-- 解锁 -->
+ * require <uses-permission android:name="android.permission.DISABLE_KEYGUARD"/>
+ *
+ * @author MaTianyu
+ * @date 2014-12-12
+ */
+public class KeyguardLock {
+    KeyguardManager              keyguardManager;
+    KeyguardManager.KeyguardLock keyguardLock;
+
+    public KeyguardLock(Context context, String tag) {
+        //获取系统服务
+        keyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
+        //初始化键盘锁，可以锁定或解开键盘锁
+        keyguardLock = keyguardManager.newKeyguardLock(tag);
+    }
+
+    /**
+     * Call requires API level 16
+     */
+    public boolean isKeyguardLocked() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+            Log.e("Log : ", "can not call isKeyguardLocked if SDK_INT < 16 ");
+            return false;
+        } else {
+            return keyguardManager.isKeyguardLocked();
+        }
+
+    }
+
+    /**
+     * Call requires API level 16
+     */
+    public boolean isKeyguardSecure() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+            Log.e("Log : ", "can not call isKeyguardSecure if SDK_INT < 16 ");
+            return false;
+        } else {
+            return keyguardManager.isKeyguardSecure();
+        }
+    }
+
+    public boolean inKeyguardRestrictedInputMode() {
+        return keyguardManager.inKeyguardRestrictedInputMode();
+    }
+
+    public void disableKeyguard() {
+        keyguardLock.disableKeyguard();
+    }
+
+    public void reenableKeyguard() {
+        keyguardLock.reenableKeyguard();
+    }
+
+    public void release() {
+        if (keyguardLock != null) {
+            //禁用显示键盘锁定
+            keyguardLock.reenableKeyguard();
+        }
+    }
+
+    public KeyguardManager getKeyguardManager() {
+        return keyguardManager;
+    }
+
+    public void setKeyguardManager(KeyguardManager keyguardManager) {
+        this.keyguardManager = keyguardManager;
+    }
+
+    public KeyguardManager.KeyguardLock getKeyguardLock() {
+        return keyguardLock;
+    }
+
+    public void setKeyguardLock(KeyguardManager.KeyguardLock keyguardLock) {
+        this.keyguardLock = keyguardLock;
+    }
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/ThirdFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/ThirdFragment.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/ThirdFragment.java	(revision )
@@ -0,0 +1,47 @@
+package com.scene.sceneandroiddemo.ui.fragments;
+
+import android.graphics.Color;
+import android.view.View;
+
+import com.facebook.drawee.generic.GenericDraweeHierarchy;
+import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
+import com.facebook.imagepipeline.decoder.SimpleProgressiveJpegConfig;
+import com.scene.customfresco.FrescoImageView;
+import com.scene.customfresco.FrescoZoomImageView;
+import com.scene.customfresco.custom.CustomProgressBar;
+import com.scene.sceneandroiddemo.BaseFragment;
+import com.scene.sceneandroiddemo.R;
+
+import butterknife.Bind;
+
+
+public class ThirdFragment extends BaseFragment {
+    @Bind(R.id.img)
+    FrescoImageView img;
+
+    @Bind(R.id.img2)
+    FrescoZoomImageView img2;
+
+    public static ThirdFragment instance() {
+        ThirdFragment view = new ThirdFragment();
+        return view;
+    }
+
+    @Override
+    public int setLayoutResId() {
+        return R.layout.fragment3;
+    }
+
+    @Override
+    public void init() {
+        //必须在loadview之前调用才会生效
+        img.setShowProgress(true);
+        img.loadView("https://raw.githubusercontent.com/renjunjia3/MyTest/master/app/src/main/res/drawable/png6.jpg", R.mipmap.ic_launcher);
+        //设置圆形和边框 无参数时就是原型
+        img.asCircle(10, Color.RED);
+        //关闭gif
+        img.setAnim(false);
+
+    }
+
+}
\ No newline at end of file
Index: .idea/dictionaries/Administrator.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/dictionaries/Administrator.xml	(revision )
+++ .idea/dictionaries/Administrator.xml	(revision )
@@ -0,0 +1,3 @@
+<component name="ProjectDictionaryState">
+  <dictionary name="Administrator" />
+</component>
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/ratingbar/RatingListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/ratingbar/RatingListener.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/ratingbar/RatingListener.java	(revision )
@@ -0,0 +1,26 @@
+package com.scene.mylib.view.ratingbar;
+
+/*
+    The MIT License (MIT)
+    Copyright (c) 2015 Techery (http://techery.io/)
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+    The above copyright notice and this permission notice shall be included in
+    all copies or substantial portions of the Software.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+    THE SOFTWARE.
+ */
+
+public interface RatingListener {
+
+    void onRatePicked(ProperRatingBar ratingBar);
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/InputMethodUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/InputMethodUtils.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/InputMethodUtils.java	(revision )
@@ -0,0 +1,55 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Build;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+
+/**
+ * @author MaTianyu(http://litesuits.com) on 2015-06-01
+ */
+@TargetApi(Build.VERSION_CODES.CUPCAKE)
+public class InputMethodUtils {
+
+    public static void toggleSoftInput(Context context) {
+        InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+        imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);
+    }
+
+    public static boolean showSoftInput(View view) {
+        InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        return imm.showSoftInput(view, InputMethodManager.SHOW_FORCED);
+    }
+
+    public static boolean showSoftInput(Activity activity) {
+        View view = activity.getCurrentFocus();
+        if (view != null) {
+            InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(
+                    Context.INPUT_METHOD_SERVICE);
+            return imm.showSoftInput(view, InputMethodManager.SHOW_FORCED);
+        }
+        return false;
+    }
+
+    public static boolean hideSoftInput(View view) {
+        InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        return imm.hideSoftInputFromWindow(view.getWindowToken(), 0);
+    }
+
+    public static boolean hideSoftInput(Activity activity) {
+        if (activity.getCurrentFocus() != null) {
+            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
+            return imm.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), 0);
+        }
+        return false;
+    }
+
+    public static boolean isActive(Context context) {
+        InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+        return imm.isActive();
+    }
+
+
+}
Index: mylib/src/main/java/com/scene/mylib/view/utils/GlideUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/utils/GlideUtil.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/utils/GlideUtil.java	(revision )
@@ -0,0 +1,36 @@
+package com.scene.mylib.view.utils;
+
+import android.app.Activity;
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.widget.ImageView;
+
+import com.bumptech.glide.Glide;
+
+/**
+ * 封装的Glide图片处理库
+ * Created by scene on 16/03/11.
+ */
+public class GlideUtil {
+
+    public static void loadImage(String url, ImageView imageView, Context context) {
+        Glide.with(context).load(url).into(imageView);
+    }
+
+    public static void loadImage(String url, ImageView imageView, Fragment fragment) {
+        Glide.with(fragment).load(url).into(imageView);
+    }
+
+    public static void loadImage(String url, ImageView imageView, android.app.Fragment fragment) {
+        Glide.with(fragment).load(url).into(imageView);
+    }
+
+    public static void loadImage(String url, ImageView imageView, Activity activity) {
+        Glide.with(activity).load(url).into(imageView);
+    }
+
+    public static void loadImage(String url, ImageView imageView, FragmentActivity activity) {
+        Glide.with(activity).load(url).into(imageView);
+    }
+}
Index: timeline/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/build.gradle	(revision )
+++ timeline/build.gradle	(revision )
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+}
Index: easypermissions/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/build.gradle	(revision )
+++ easypermissions/build.gradle	(revision )
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile 'com.android.support:appcompat-v7:23.1.1'
+}
+
+
Index: common/src/test/java/com/scene/common/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/test/java/com/scene/common/ExampleUnitTest.java	(revision )
+++ common/src/test/java/com/scene/common/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.scene.common;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/ImageViewTouchBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/ImageViewTouchBase.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/ImageViewTouchBase.java	(revision )
@@ -0,0 +1,428 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.chooseimagelib.simplecropimage;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.util.AttributeSet;
+import android.view.KeyEvent;
+import android.widget.ImageView;
+
+abstract class ImageViewTouchBase extends ImageView {
+
+    @SuppressWarnings("unused")
+    private static final String TAG = "ImageViewTouchBase";
+
+    // This is the base transformation which is used to show the image
+    // initially.  The current computation for this shows the image in
+    // it's entirety, letterboxing as needed.  One could choose to
+    // show the image as cropped instead.
+    //
+    // This matrix is recomputed when we go from the thumbnail image to
+    // the full size image.
+    protected Matrix mBaseMatrix = new Matrix();
+
+    // This is the supplementary transformation which reflects what
+    // the user has done in terms of zooming and panning.
+    //
+    // This matrix remains the same when we go from the thumbnail image
+    // to the full size image.
+    protected Matrix mSuppMatrix = new Matrix();
+
+    // This is the final matrix which is computed as the concatentation
+    // of the base matrix and the supplementary matrix.
+    private final Matrix mDisplayMatrix = new Matrix();
+
+    // Temporary buffer used for getting the values out of a matrix.
+    private final float[] mMatrixValues = new float[9];
+
+    // The current bitmap being displayed.
+    final protected RotateBitmap mBitmapDisplayed = new RotateBitmap(null);
+
+    int mThisWidth = -1, mThisHeight = -1;
+
+    float mMaxZoom;
+
+    int mLeft;
+
+    int mRight;
+
+    int mTop;
+
+    int mBottom;
+
+    // ImageViewTouchBase will pass a Bitmap to the Recycler if it has finished
+    // its use of that Bitmap.
+    public interface Recycler {
+
+        public void recycle(Bitmap b);
+    }
+
+    public void setRecycler(Recycler r) {
+
+        mRecycler = r;
+    }
+
+    private Recycler mRecycler;
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top,
+                            int right, int bottom) {
+
+        super.onLayout(changed, left, top, right, bottom);
+        mLeft = left;
+        mRight = right;
+        mTop = top;
+        mBottom = bottom;
+        mThisWidth = right - left;
+        mThisHeight = bottom - top;
+        Runnable r = mOnLayoutRunnable;
+        if (r != null) {
+            mOnLayoutRunnable = null;
+            r.run();
+        }
+        if (mBitmapDisplayed.getBitmap() != null) {
+            getProperBaseMatrix(mBitmapDisplayed, mBaseMatrix);
+            setImageMatrix(getImageViewMatrix());
+        }
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+
+        if (keyCode == KeyEvent.KEYCODE_BACK && getScale() > 1.0f) {
+            // If we're zoomed in, pressing Back jumps out to show the entire
+            // image, otherwise Back returns the user to the gallery.
+            zoomTo(1.0f);
+            return true;
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    protected Handler mHandler = new Handler();
+
+    @Override
+    public void setImageBitmap(Bitmap bitmap) {
+
+        setImageBitmap(bitmap, 0);
+    }
+
+    private void setImageBitmap(Bitmap bitmap, int rotation) {
+
+        super.setImageBitmap(bitmap);
+        Drawable d = getDrawable();
+        if (d != null) {
+            d.setDither(true);
+        }
+
+        Bitmap old = mBitmapDisplayed.getBitmap();
+        mBitmapDisplayed.setBitmap(bitmap);
+        mBitmapDisplayed.setRotation(rotation);
+
+        if (old != null && old != bitmap && mRecycler != null) {
+            mRecycler.recycle(old);
+        }
+    }
+
+    public void clear() {
+
+        setImageBitmapResetBase(null, true);
+    }
+
+    private Runnable mOnLayoutRunnable = null;
+
+    // This function changes bitmap, reset base matrix according to the size
+    // of the bitmap, and optionally reset the supplementary matrix.
+    public void setImageBitmapResetBase(final Bitmap bitmap,
+                                        final boolean resetSupp) {
+
+        setImageRotateBitmapResetBase(new RotateBitmap(bitmap), resetSupp);
+    }
+
+    public void setImageRotateBitmapResetBase(final RotateBitmap bitmap,
+                                              final boolean resetSupp) {
+
+        final int viewWidth = getWidth();
+
+        if (viewWidth <= 0) {
+            mOnLayoutRunnable = new Runnable() {
+                public void run() {
+
+                    setImageRotateBitmapResetBase(bitmap, resetSupp);
+                }
+            };
+            return;
+        }
+
+        if (bitmap.getBitmap() != null) {
+            getProperBaseMatrix(bitmap, mBaseMatrix);
+            setImageBitmap(bitmap.getBitmap(), bitmap.getRotation());
+        } else {
+            mBaseMatrix.reset();
+            setImageBitmap(null);
+        }
+
+        if (resetSupp) {
+            mSuppMatrix.reset();
+        }
+        setImageMatrix(getImageViewMatrix());
+        mMaxZoom = maxZoom();
+    }
+
+    // Center as much as possible in one or both axis.  Centering is
+    // defined as follows:  if the image is scaled down below the
+    // view's dimensions then center it (literally).  If the image
+    // is scaled larger than the view and is translated out of view
+    // then translate it back into view (i.e. eliminate black bars).
+    protected void center(boolean horizontal, boolean vertical) {
+
+        if (mBitmapDisplayed.getBitmap() == null) {
+            return;
+        }
+
+        Matrix m = getImageViewMatrix();
+
+        RectF rect = new RectF(0, 0,
+                mBitmapDisplayed.getBitmap().getWidth(),
+                mBitmapDisplayed.getBitmap().getHeight());
+
+        m.mapRect(rect);
+
+        float height = rect.height();
+        float width = rect.width();
+
+        float deltaX = 0, deltaY = 0;
+
+        if (vertical) {
+            int viewHeight = getHeight();
+            if (height < viewHeight) {
+                deltaY = (viewHeight - height) / 2 - rect.top;
+            } else if (rect.top > 0) {
+                deltaY = -rect.top;
+            } else if (rect.bottom < viewHeight) {
+                deltaY = getHeight() - rect.bottom;
+            }
+        }
+
+        if (horizontal) {
+            int viewWidth = getWidth();
+            if (width < viewWidth) {
+                deltaX = (viewWidth - width) / 2 - rect.left;
+            } else if (rect.left > 0) {
+                deltaX = -rect.left;
+            } else if (rect.right < viewWidth) {
+                deltaX = viewWidth - rect.right;
+            }
+        }
+
+        postTranslate(deltaX, deltaY);
+        setImageMatrix(getImageViewMatrix());
+    }
+
+    public ImageViewTouchBase(Context context) {
+
+        super(context);
+        init();
+    }
+
+    public ImageViewTouchBase(Context context, AttributeSet attrs) {
+
+        super(context, attrs);
+        init();
+    }
+
+    private void init() {
+
+        setScaleType(ScaleType.MATRIX);
+    }
+
+    protected float getValue(Matrix matrix, int whichValue) {
+
+        matrix.getValues(mMatrixValues);
+        return mMatrixValues[whichValue];
+    }
+
+    // Get the scale factor out of the matrix.
+    protected float getScale(Matrix matrix) {
+
+        return getValue(matrix, Matrix.MSCALE_X);
+    }
+
+    protected float getScale() {
+
+        return getScale(mSuppMatrix);
+    }
+
+    // Setup the base matrix so that the image is centered and scaled properly.
+    private void getProperBaseMatrix(RotateBitmap bitmap, Matrix matrix) {
+
+        float viewWidth = getWidth();
+        float viewHeight = getHeight();
+
+        float w = bitmap.getWidth();
+        float h = bitmap.getHeight();
+        int rotation = bitmap.getRotation();
+        matrix.reset();
+
+        // We limit up-scaling to 2x otherwise the result may look bad if it's
+        // a small icon.
+        float widthScale = Math.min(viewWidth / w, 2.0f);
+        float heightScale = Math.min(viewHeight / h, 2.0f);
+        float scale = Math.min(widthScale, heightScale);
+
+        matrix.postConcat(bitmap.getRotateMatrix());
+        matrix.postScale(scale, scale);
+
+        matrix.postTranslate(
+                (viewWidth - w * scale) / 2F,
+                (viewHeight - h * scale) / 2F);
+    }
+
+    // Combine the base matrix and the supp matrix to make the final matrix.
+    protected Matrix getImageViewMatrix() {
+        // The final matrix is computed as the concatentation of the base matrix
+        // and the supplementary matrix.
+        mDisplayMatrix.set(mBaseMatrix);
+        mDisplayMatrix.postConcat(mSuppMatrix);
+        return mDisplayMatrix;
+    }
+
+    static final float SCALE_RATE = 1.25F;
+
+    // Sets the maximum zoom, which is a scale relative to the base matrix. It
+    // is calculated to show the image at 400% zoom regardless of screen or
+    // image orientation. If in the future we decode the full 3 megapixel image,
+    // rather than the current 1024x768, this should be changed down to 200%.
+    protected float maxZoom() {
+
+        if (mBitmapDisplayed.getBitmap() == null) {
+            return 1F;
+        }
+
+        float fw = (float) mBitmapDisplayed.getWidth() / (float) mThisWidth;
+        float fh = (float) mBitmapDisplayed.getHeight() / (float) mThisHeight;
+        float max = Math.max(fw, fh) * 4;
+        return max;
+    }
+
+    protected void zoomTo(float scale, float centerX, float centerY) {
+
+        if (scale > mMaxZoom) {
+            scale = mMaxZoom;
+        }
+
+        float oldScale = getScale();
+        float deltaScale = scale / oldScale;
+
+        mSuppMatrix.postScale(deltaScale, deltaScale, centerX, centerY);
+        setImageMatrix(getImageViewMatrix());
+        center(true, true);
+    }
+
+    protected void zoomTo(final float scale, final float centerX,
+                          final float centerY, final float durationMs) {
+
+        final float incrementPerMs = (scale - getScale()) / durationMs;
+        final float oldScale = getScale();
+        final long startTime = System.currentTimeMillis();
+
+        mHandler.post(new Runnable() {
+            public void run() {
+
+                long now = System.currentTimeMillis();
+                float currentMs = Math.min(durationMs, now - startTime);
+                float target = oldScale + (incrementPerMs * currentMs);
+                zoomTo(target, centerX, centerY);
+
+                if (currentMs < durationMs) {
+                    mHandler.post(this);
+                }
+            }
+        });
+    }
+
+    protected void zoomTo(float scale) {
+
+        float cx = getWidth() / 2F;
+        float cy = getHeight() / 2F;
+
+        zoomTo(scale, cx, cy);
+    }
+
+    protected void zoomIn() {
+
+        zoomIn(SCALE_RATE);
+    }
+
+    protected void zoomOut() {
+
+        zoomOut(SCALE_RATE);
+    }
+
+    protected void zoomIn(float rate) {
+
+        if (getScale() >= mMaxZoom) {
+            return;     // Don't let the user zoom into the molecular level.
+        }
+        if (mBitmapDisplayed.getBitmap() == null) {
+            return;
+        }
+
+        float cx = getWidth() / 2F;
+        float cy = getHeight() / 2F;
+
+        mSuppMatrix.postScale(rate, rate, cx, cy);
+        setImageMatrix(getImageViewMatrix());
+    }
+
+    protected void zoomOut(float rate) {
+
+        if (mBitmapDisplayed.getBitmap() == null) {
+            return;
+        }
+
+        float cx = getWidth() / 2F;
+        float cy = getHeight() / 2F;
+
+        // Zoom out to at most 1x.
+        Matrix tmp = new Matrix(mSuppMatrix);
+        tmp.postScale(1F / rate, 1F / rate, cx, cy);
+
+        if (getScale(tmp) < 1F) {
+            mSuppMatrix.setScale(1F, 1F, cx, cy);
+        } else {
+            mSuppMatrix.postScale(1F / rate, 1F / rate, cx, cy);
+        }
+        setImageMatrix(getImageViewMatrix());
+        center(true, true);
+    }
+
+    protected void postTranslate(float dx, float dy) {
+
+        mSuppMatrix.postTranslate(dx, dy);
+    }
+
+    protected void panBy(float dx, float dy) {
+
+        postTranslate(dx, dy);
+        setImageMatrix(getImageViewMatrix());
+    }
+}
Index: app/src/main/res/layout/fragment2.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/fragment2.xml	(revision )
+++ app/src/main/res/layout/fragment2.xml	(revision )
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+    <Button
+        android:id="@+id/next"
+        android:text="Next"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" />
+
+</LinearLayout>
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/adapter/TimeLineAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/adapter/TimeLineAdapter.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/adapter/TimeLineAdapter.java	(revision )
@@ -0,0 +1,48 @@
+package com.scene.sceneandroiddemo.adapter;
+
+import android.content.Context;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.ViewGroup;
+
+import com.scene.sceneandroiddemo.R;
+import com.scene.sceneandroiddemo.viewholder.TimeLineViewHolder;
+import com.scene.timeline.TimelineView;
+
+import java.util.List;
+
+/**
+ * Created by scene on 16/02/25.
+ */
+public class TimeLineAdapter extends RecyclerView.Adapter {
+    private Context mContext;
+    private List<String> mList;
+    private LayoutInflater mlayoutInflater;
+
+    public TimeLineAdapter(Context mContext, List<String> mList) {
+        this.mContext = mContext;
+        this.mList = mList;
+        mlayoutInflater = LayoutInflater.from(mContext);
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        return TimelineView.getTimeLineViewType(position, getItemCount());
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        return new TimeLineViewHolder(mlayoutInflater.inflate(R.layout.item_time_line, parent, false), viewType);
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+        TimeLineViewHolder viewHolder = (TimeLineViewHolder) holder;
+        viewHolder.name.setText(mList.get(position));
+    }
+
+    @Override
+    public int getItemCount() {
+        return mList == null ? 0 : mList.size();
+    }
+}
Index: customfresco/src/test/java/com/scene/customfresco/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/test/java/com/scene/customfresco/ExampleUnitTest.java	(revision )
+++ customfresco/src/test/java/com/scene/customfresco/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.scene.customfresco;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: ucrop/src/main/java/com/yalantis/ucrop/UCropActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/UCropActivity.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/UCropActivity.java	(revision )
@@ -0,0 +1,374 @@
+package com.yalantis.ucrop;
+
+import android.annotation.TargetApi;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.ColorInt;
+import android.support.annotation.IdRes;
+import android.support.annotation.NonNull;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import com.yalantis.ucrop.util.BitmapLoadUtils;
+import com.yalantis.ucrop.view.CropImageView;
+import com.yalantis.ucrop.view.GestureCropImageView;
+import com.yalantis.ucrop.view.TransformImageView;
+import com.yalantis.ucrop.view.widget.AspectRatioTextView;
+import com.yalantis.ucrop.view.widget.HorizontalProgressWheelView;
+
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ */
+public class UCropActivity extends AppCompatActivity {
+
+    public static final int DEFAULT_MAX_BITMAP_SIZE = 0;
+    public static final int DEFAULT_COMPRESS_QUALITY = 90;
+    public static final Bitmap.CompressFormat DEFAULT_COMPRESS_FORMAT = Bitmap.CompressFormat.JPEG;
+
+    private static final String TAG = "UCropActivity";
+
+    private static final int SCALE_WIDGET_SENSITIVITY_COEFFICIENT = 15000;
+    private static final int ROTATE_WIDGET_SENSITIVITY_COEFFICIENT = 42;
+
+    private GestureCropImageView mGestureCropImageView;
+    private ViewGroup mWrapperStateAspectRatio, mWrapperStateRotate, mWrapperStateScale;
+    private ViewGroup mLayoutAspectRatio, mLayoutRotate, mLayoutScale;
+    private List<ViewGroup> mCropAspectRatioViews = new ArrayList<>();
+    private TextView mTextViewRotateAngle, mTextViewScalePercent;
+
+    private Uri mOutputUri;
+
+    private int mMaxBitmapSize = DEFAULT_MAX_BITMAP_SIZE;
+    private Bitmap.CompressFormat mCompressFormat = DEFAULT_COMPRESS_FORMAT;
+    private int mCompressQuality = DEFAULT_COMPRESS_QUALITY;
+    private boolean mGesturesAlwaysEnabled = false;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.ucrop_activity_photobox);
+
+        setupViews();
+        setImageData();
+        setInitialState();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(final Menu menu) {
+        getMenuInflater().inflate(R.menu.ucrop_menu_activity, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == R.id.menu_next) {
+            cropAndSaveImage();
+        } else if (item.getItemId() == android.R.id.home) {
+            onBackPressed();
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        if (mGestureCropImageView != null) {
+            mGestureCropImageView.cancelAllAnimations();
+        }
+    }
+
+    private void setImageData() {
+        final Intent intent = getIntent();
+
+        Uri inputUri = intent.getParcelableExtra(UCrop.EXTRA_INPUT_URI);
+        mOutputUri = intent.getParcelableExtra(UCrop.EXTRA_OUTPUT_URI);
+        processOptions(intent);
+
+        if (inputUri != null && mOutputUri != null) {
+            try {
+                mGestureCropImageView.setMaxBitmapSize(mMaxBitmapSize);
+                mGestureCropImageView.setImageUri(inputUri);
+            } catch (Exception e) {
+                setResultException(e);
+                finish();
+            }
+        } else {
+            setResultException(new NullPointerException(getString(R.string.ucrop_error_input_data_is_absent)));
+            finish();
+        }
+
+        if (intent.getBooleanExtra(UCrop.EXTRA_ASPECT_RATIO_SET, false)) {
+            mWrapperStateAspectRatio.setVisibility(View.GONE);
+
+            int aspectRatioX = intent.getIntExtra(UCrop.EXTRA_ASPECT_RATIO_X, 0);
+            int aspectRatioY = intent.getIntExtra(UCrop.EXTRA_ASPECT_RATIO_Y, 0);
+
+            if (aspectRatioX > 0 && aspectRatioY > 0) {
+                mGestureCropImageView.setTargetAspectRatio(aspectRatioX / (float) aspectRatioY);
+            } else {
+                mGestureCropImageView.setTargetAspectRatio(CropImageView.SOURCE_IMAGE_ASPECT_RATIO);
+            }
+        }
+
+        if (intent.getBooleanExtra(UCrop.EXTRA_MAX_SIZE_SET, false)) {
+            int maxSizeX = intent.getIntExtra(UCrop.EXTRA_MAX_SIZE_X, 0);
+            int maxSizeY = intent.getIntExtra(UCrop.EXTRA_MAX_SIZE_Y, 0);
+
+            if (maxSizeX > 0 && maxSizeY > 0) {
+                mGestureCropImageView.setMaxResultImageSizeX(maxSizeX);
+                mGestureCropImageView.setMaxResultImageSizeY(maxSizeY);
+            } else {
+                Log.w(TAG, "EXTRA_MAX_SIZE_X and EXTRA_MAX_SIZE_Y must be greater than 0");
+            }
+        }
+    }
+
+    private void processOptions(@NonNull Intent intent) {
+        UCrop.Options options = intent.getParcelableExtra(UCrop.EXTRA_OPTIONS);
+        if (options != null) {
+            mMaxBitmapSize = options.getMaxBitmapSize();
+
+            String compressionFormatName = options.getCompressionFormatName();
+            Bitmap.CompressFormat compressFormat = null;
+            if (!TextUtils.isEmpty(compressionFormatName)) {
+                compressFormat = Bitmap.CompressFormat.valueOf(compressionFormatName);
+            }
+            mCompressFormat = (compressFormat == null) ? DEFAULT_COMPRESS_FORMAT : compressFormat;
+
+            mCompressQuality = options.getCompressionQuality();
+            mGesturesAlwaysEnabled = options.isGesturesAlwaysEnabled();
+        }
+    }
+
+    private void setupViews() {
+        final Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+        setSupportActionBar(toolbar);
+        toolbar.setNavigationIcon(R.drawable.ucrop_ic_cross);
+        final ActionBar actionBar = getSupportActionBar();
+        if (actionBar != null) {
+            actionBar.setDisplayShowTitleEnabled(false);
+        }
+        setStatusBarColor(getResources().getColor(R.color.ucrop_color_statusbar));
+
+        mGestureCropImageView = (GestureCropImageView) findViewById(R.id.image_view_crop);
+        mGestureCropImageView.setTransformImageListener(new TransformImageView.TransformImageListener() {
+            @Override
+            public void onRotate(float currentAngle) {
+                setAngleText(currentAngle);
+            }
+
+            @Override
+            public void onScale(float currentScale) {
+                setScaleText(currentScale);
+            }
+        });
+
+        mWrapperStateAspectRatio = (ViewGroup) findViewById(R.id.state_aspect_ratio);
+        mWrapperStateAspectRatio.setOnClickListener(mStateClickListener);
+        mWrapperStateRotate = (ViewGroup) findViewById(R.id.state_rotate);
+        mWrapperStateRotate.setOnClickListener(mStateClickListener);
+        mWrapperStateScale = (ViewGroup) findViewById(R.id.state_scale);
+        mWrapperStateScale.setOnClickListener(mStateClickListener);
+
+        mLayoutAspectRatio = (ViewGroup) findViewById(R.id.layout_aspect_ratio);
+        mLayoutRotate = (ViewGroup) findViewById(R.id.layout_rotate_wheel);
+        mLayoutScale = (ViewGroup) findViewById(R.id.layout_scale_wheel);
+
+        setupAspectRatioWidget();
+        setupRotateWidget();
+        setupScaleWidget();
+    }
+
+    /**
+     * Sets status-bar color for L devices.
+     *
+     * @param color - status-bar color
+     */
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public void setStatusBarColor(@ColorInt int color) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            if (getWindow() != null) {
+                getWindow().setStatusBarColor(color);
+            }
+        }
+    }
+
+    private void setupAspectRatioWidget() {
+        mCropAspectRatioViews.add((ViewGroup) findViewById(R.id.crop_aspect_ratio_1_1));
+        mCropAspectRatioViews.add((ViewGroup) findViewById(R.id.crop_aspect_ratio_3_4));
+        mCropAspectRatioViews.add((ViewGroup) findViewById(R.id.crop_aspect_ratio_original));
+        mCropAspectRatioViews.add((ViewGroup) findViewById(R.id.crop_aspect_ratio_3_2));
+        mCropAspectRatioViews.add((ViewGroup) findViewById(R.id.crop_aspect_ratio_16_9));
+        mCropAspectRatioViews.get(2).setSelected(true);
+
+        for (ViewGroup cropAspectRatioView : mCropAspectRatioViews) {
+            cropAspectRatioView.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mGestureCropImageView.setTargetAspectRatio(
+                            ((AspectRatioTextView) ((ViewGroup) v).getChildAt(0)).getAspectRatio(v.isSelected()));
+                    mGestureCropImageView.setImageToWrapCropBounds();
+                    if (!v.isSelected()) {
+                        for (ViewGroup cropAspectRatioView : mCropAspectRatioViews) {
+                            cropAspectRatioView.setSelected(cropAspectRatioView == v);
+                        }
+                    }
+                }
+            });
+        }
+    }
+
+    private void setupRotateWidget() {
+        mTextViewRotateAngle = ((TextView) findViewById(R.id.text_view_rotate));
+        ((HorizontalProgressWheelView) findViewById(R.id.rotate_scroll_wheel))
+                .setScrollingListener(new HorizontalProgressWheelView.ScrollingListener() {
+                    @Override
+                    public void onScroll(float delta, float totalDistance) {
+                        mGestureCropImageView.postRotate(delta / ROTATE_WIDGET_SENSITIVITY_COEFFICIENT);
+                    }
+
+                    @Override
+                    public void onScrollEnd() {
+                        mGestureCropImageView.setImageToWrapCropBounds();
+                    }
+
+                    @Override
+                    public void onScrollStart() {
+                        mGestureCropImageView.cancelAllAnimations();
+                    }
+                });
+
+
+        findViewById(R.id.wrapper_reset_rotate).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                resetRotation();
+            }
+        });
+        findViewById(R.id.wrapper_rotate_by_angle).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                rotateByAngle(90);
+            }
+        });
+    }
+
+    private void setupScaleWidget() {
+        mTextViewScalePercent = ((TextView) findViewById(R.id.text_view_scale));
+        ((HorizontalProgressWheelView) findViewById(R.id.scale_scroll_wheel))
+                .setScrollingListener(new HorizontalProgressWheelView.ScrollingListener() {
+                    @Override
+                    public void onScroll(float delta, float totalDistance) {
+                        if (delta > 0) {
+                            mGestureCropImageView.zoomInImage(mGestureCropImageView.getCurrentScale()
+                                    + delta * ((mGestureCropImageView.getMaxScale() - mGestureCropImageView.getMinScale()) / SCALE_WIDGET_SENSITIVITY_COEFFICIENT));
+                        } else {
+                            mGestureCropImageView.zoomOutImage(mGestureCropImageView.getCurrentScale()
+                                    + delta * ((mGestureCropImageView.getMaxScale() - mGestureCropImageView.getMinScale()) / SCALE_WIDGET_SENSITIVITY_COEFFICIENT));
+                        }
+                    }
+
+                    @Override
+                    public void onScrollEnd() {
+                        mGestureCropImageView.setImageToWrapCropBounds();
+                    }
+
+                    @Override
+                    public void onScrollStart() {
+                        mGestureCropImageView.cancelAllAnimations();
+                    }
+                });
+    }
+
+    private void setAngleText(float angle) {
+        if (mTextViewRotateAngle != null) {
+            mTextViewRotateAngle.setText(String.format("%.1f°", angle));
+        }
+    }
+
+    private void setScaleText(float scale) {
+        if (mTextViewScalePercent != null) {
+            mTextViewScalePercent.setText(String.format("%d%%", (int) (scale * 100)));
+        }
+    }
+
+    private void resetRotation() {
+        mGestureCropImageView.postRotate(-mGestureCropImageView.getCurrentAngle());
+        mGestureCropImageView.setImageToWrapCropBounds();
+    }
+
+    private void rotateByAngle(int angle) {
+        mGestureCropImageView.postRotate(angle);
+        mGestureCropImageView.setImageToWrapCropBounds();
+    }
+
+    private final View.OnClickListener mStateClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            if (!v.isSelected()) {
+                setWidgetState(v.getId());
+            }
+        }
+    };
+
+    private void setInitialState() {
+        setWidgetState(R.id.state_scale);
+    }
+
+    private void setWidgetState(@IdRes int stateViewId) {
+        mWrapperStateAspectRatio.setSelected(stateViewId == R.id.state_aspect_ratio);
+        mWrapperStateRotate.setSelected(stateViewId == R.id.state_rotate);
+        mWrapperStateScale.setSelected(stateViewId == R.id.state_scale);
+
+        mLayoutAspectRatio.setVisibility(stateViewId == R.id.state_aspect_ratio ? View.VISIBLE : View.GONE);
+        mLayoutRotate.setVisibility(stateViewId == R.id.state_rotate ? View.VISIBLE : View.GONE);
+        mLayoutScale.setVisibility(stateViewId == R.id.state_scale ? View.VISIBLE : View.GONE);
+
+        mGestureCropImageView.setRotateEnabled(mGesturesAlwaysEnabled || stateViewId != R.id.state_scale);
+        mGestureCropImageView.setScaleEnabled(mGesturesAlwaysEnabled || stateViewId != R.id.state_rotate);
+    }
+
+    private void cropAndSaveImage() {
+        OutputStream outputStream = null;
+        try {
+            final Bitmap croppedBitmap = mGestureCropImageView.cropImage();
+            if (croppedBitmap != null) {
+                outputStream = getContentResolver().openOutputStream(mOutputUri);
+                croppedBitmap.compress(mCompressFormat, mCompressQuality, outputStream);
+                croppedBitmap.recycle();
+
+                setResultUri(mOutputUri);
+                finish();
+            }
+        } catch (Exception e) {
+            setResultException(e);
+            finish();
+        } finally {
+            BitmapLoadUtils.close(outputStream);
+        }
+    }
+
+    private void setResultUri(Uri uri) {
+        setResult(RESULT_OK, new Intent().putExtra(UCrop.EXTRA_OUTPUT_URI, uri));
+    }
+
+    private void setResultException(Throwable throwable) {
+        setResult(UCrop.RESULT_ERROR, new Intent().putExtra(UCrop.EXTRA_ERROR, throwable));
+    }
+
+}
Index: timeline/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/proguard-rules.pro	(revision )
+++ timeline/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\Devolopment\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: mylib/src/main/res/layout/sample_common_list_footer_network_error.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/sample_common_list_footer_network_error.xml	(revision )
+++ mylib/src/main/res/layout/sample_common_list_footer_network_error.xml	(revision )
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center"
+    android:orientation="horizontal">
+
+    <ImageView
+        android:layout_width="@dimen/dp_22"
+        android:layout_height="@dimen/dp_22"
+        android:layout_marginRight="@dimen/dp_4"
+        android:src="@drawable/sample_footer_error" />
+
+    <TextView
+        android:id="@+id/loading_text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginLeft="@dimen/dp_4"
+        android:text="@string/list_footer_network_error"
+        android:textColor="@color/sample_common_list_bottom_text_color"
+        android:textSize="@dimen/sp_14" />
+</LinearLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/io/StringCodingUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/StringCodingUtils.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/StringCodingUtils.java	(revision )
@@ -0,0 +1,27 @@
+package com.scene.common.common.io;
+
+import android.os.Build;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+
+/**
+ * @author MaTianyu
+ * @date 2014-12-05
+ */
+public class StringCodingUtils {
+
+    public static byte[] getBytes(String src, Charset charSet) {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+            try {
+                return src.getBytes(charSet.name());
+            } catch (UnsupportedEncodingException e) {
+                e.printStackTrace();
+            }
+            return null;
+        } else {
+            return src.getBytes(charSet);
+        }
+    }
+
+}
Index: ucrop/src/main/res/layout/ucrop_layout_aspect_ratio.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/layout/ucrop_layout_aspect_ratio.xml	(revision )
+++ ucrop/src/main/res/layout/ucrop_layout_aspect_ratio.xml	(revision )
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center"
+    android:orientation="horizontal"
+    tools:ignore="HardcodedText"
+    tools:showIn="@layout/ucrop_activity_photobox"
+    tools:visibility="gone">
+
+    <FrameLayout
+        android:id="@+id/crop_aspect_ratio_1_1"
+        style="@style/ucrop_WrapperIconState">
+
+        <com.yalantis.ucrop.view.widget.AspectRatioTextView
+            style="@style/ucrop_TextViewCropAspectRatio"
+            app:ucrop_artv_ratio_x="1"
+            app:ucrop_artv_ratio_y="1"/>
+
+    </FrameLayout>
+
+    <FrameLayout
+        android:id="@+id/crop_aspect_ratio_3_4"
+        style="@style/ucrop_WrapperIconState">
+
+        <com.yalantis.ucrop.view.widget.AspectRatioTextView
+            style="@style/ucrop_TextViewCropAspectRatio"
+            app:ucrop_artv_ratio_x="4"
+            app:ucrop_artv_ratio_y="3"/>
+
+    </FrameLayout>
+
+    <FrameLayout
+        android:id="@+id/crop_aspect_ratio_original"
+        style="@style/ucrop_WrapperIconState">
+
+        <com.yalantis.ucrop.view.widget.AspectRatioTextView
+            style="@style/ucrop_TextViewCropAspectRatio"
+            android:textAllCaps="true"
+            app:ucrop_artv_ratio_title="@string/ucrop_label_original"/>
+
+    </FrameLayout>
+
+    <FrameLayout
+        android:id="@+id/crop_aspect_ratio_3_2"
+        style="@style/ucrop_WrapperIconState">
+
+        <com.yalantis.ucrop.view.widget.AspectRatioTextView
+            style="@style/ucrop_TextViewCropAspectRatio"
+            app:ucrop_artv_ratio_x="3"
+            app:ucrop_artv_ratio_y="2"/>
+
+    </FrameLayout>
+
+    <FrameLayout
+        android:id="@+id/crop_aspect_ratio_16_9"
+        style="@style/ucrop_WrapperIconState">
+
+        <com.yalantis.ucrop.view.widget.AspectRatioTextView
+            style="@style/ucrop_TextViewCropAspectRatio"
+            app:ucrop_artv_ratio_x="16"
+            app:ucrop_artv_ratio_y="9"/>
+
+    </FrameLayout>
+
+
+</LinearLayout>
\ No newline at end of file
Index: .idea/inspectionProfiles/Project_Default.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/inspectionProfiles/Project_Default.xml	(revision )
+++ .idea/inspectionProfiles/Project_Default.xml	(revision )
@@ -0,0 +1,10 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="Deprecation" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="LoggerInitializedWithForeignClass" enabled="false" level="WARNING" enabled_by_default="false">
+      <option name="loggerClassName" value="org.apache.log4j.Logger,org.slf4j.LoggerFactory,org.apache.commons.logging.LogFactory,java.util.logging.Logger" />
+      <option name="loggerFactoryMethodName" value="getLogger,getLogger,getLog,getLogger" />
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
Index: common/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/res/values/strings.xml	(revision )
+++ common/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">Common</string>
+</resources>
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/FirstFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/FirstFragment.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/FirstFragment.java	(revision )
@@ -0,0 +1,88 @@
+package com.scene.sceneandroiddemo.ui.fragments;
+
+import android.content.Intent;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+
+import com.scene.common.common.assist.Check;
+import com.scene.mylib.view.recyclerview.OnRecyclerViewItemClickListener;
+import com.scene.sceneandroiddemo.BaseFragment;
+import com.scene.sceneandroiddemo.R;
+import com.scene.sceneandroiddemo.adapter.MainAdapter;
+import com.scene.sceneandroiddemo.entity.TypeInfo;
+import com.scene.sceneandroiddemo.ui.activity.LoadmoreActivity;
+import com.scene.sceneandroiddemo.ui.activity.SelectAndCropImageActivity;
+import com.scene.sceneandroiddemo.ui.activity.CustomRatingBarActivity;
+import com.scene.sceneandroiddemo.ui.activity.WebViewDemo;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import butterknife.Bind;
+
+public class FirstFragment extends BaseFragment implements OnRecyclerViewItemClickListener {
+    @Bind(R.id.recyclerView)
+    RecyclerView recyclerView;
+
+    private MainAdapter adapter;
+    private List<TypeInfo> dataList;
+
+    public static FirstFragment instance() {
+        FirstFragment view = new FirstFragment();
+        return view;
+    }
+
+    @Override
+    public int setLayoutResId() {
+        return R.layout.fragment1;
+    }
+
+
+    @Override
+    public void init() {
+        bindRecyclerView();
+    }
+
+
+    private void bindRecyclerView() {
+        dataList = new ArrayList<>();
+        adapter = new MainAdapter(getActivity(), dataList);
+        LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity());
+        recyclerView.setLayoutManager(layoutManager);
+        adapter.setListener(this);
+        recyclerView.setAdapter(adapter);
+        loadData();
+    }
+
+    private void loadData() {
+        TypeInfo info1 = new TypeInfo(0, "RecyclerView下拉上滑");
+        TypeInfo info2 = new TypeInfo(1, "图片选择与裁剪");
+        TypeInfo info3 = new TypeInfo(2, "自定义评星条");
+        TypeInfo info4 = new TypeInfo(3, "自定义评星条");
+        dataList.add(info1);
+        dataList.add(info2);
+        dataList.add(info3);
+        dataList.add(info4);
+        adapter.notifyDataSetChanged();
+    }
+
+    @Override
+    public void onRecyclerViewItemClick(int position) {
+        switch (position) {
+            case 0://RecyclerView下拉上滑
+                startActivity(new Intent(getActivity(), LoadmoreActivity.class));
+                break;
+            case 1://图片选择与裁剪
+                startActivity(new Intent(getActivity(), SelectAndCropImageActivity.class));
+                break;
+            case 2://自定义评星条
+                startActivity(new Intent(getActivity(), CustomRatingBarActivity.class));
+                break;
+            case 3://webView
+                startActivity(new Intent(getActivity(), WebViewDemo.class));
+                break;
+        }
+    }
+
+
+}
Index: common/src/main/java/com/scene/common/common/utils/NotificationUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/NotificationUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/NotificationUtil.java	(revision )
@@ -0,0 +1,180 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Color;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+
+import com.scene.common.android.log.Log;
+
+import java.util.ArrayList;
+
+/**
+ * @author MaTianyu
+ * @date 2014-11-19
+ */
+public class NotificationUtil {
+    private static int LedID = 0;
+    private static final String TAG = NotificationUtil.class.getSimpleName();
+
+    public static void notification(Context context, Uri uri,
+                                    int icon, String ticker, String title, String msg) {
+        Log.i(TAG, "notiry uri :" + uri);
+        // 设置通知的事件消息
+        Intent intent = new Intent();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT) {
+            intent.setPackage(context.getPackageName());
+        }
+        intent.setData(uri);
+        notification(context, intent, 0, icon, ticker, title, msg);
+    }
+
+    public static void notification(Context context, String activityClass, Bundle bundle,
+                                    int icon, String ticker, String title, String msg) {
+        // 设置通知的事件消息
+        Intent intent = new Intent();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT) {
+            intent.setPackage(context.getPackageName());
+        }
+        intent.putExtras(bundle);
+        intent.setComponent(new ComponentName(context.getPackageName(), activityClass));
+        notification(context, intent, 0, icon, ticker, title, msg);
+    }
+
+    public static void notification(Context context, Intent intent, int id,
+                                    int icon, String ticker, String title, String msg) {
+        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        notification(context, pendingIntent, id, icon, ticker, title, msg);
+    }
+
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    public static void notification(Context context, PendingIntent pendingIntent, int id,
+                                    int icon, String ticker, String title, String msg) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            Notification.Builder builder = new Notification.Builder(context);
+            builder.setSmallIcon(icon);
+
+            builder.setContentTitle(title);
+            builder.setTicker(ticker);
+            builder.setContentText(msg);
+
+            builder.setDefaults(Notification.DEFAULT_SOUND);
+            builder.setLights(0xFFFFFF00, 0, 2000);
+            builder.setVibrate(new long[]{0, 100, 300});
+            builder.setAutoCancel(true);
+            builder.setContentIntent(pendingIntent);
+            Notification baseNF;
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                baseNF = builder.getNotification();
+            } else {
+                baseNF = builder.build();
+            }
+            //发出状态栏通知
+            NotificationManager nm = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);
+            nm.notify(id, baseNF);
+        } else {
+            // 创建一个NotificationManager的引用
+            NotificationManager notificationManager = (NotificationManager) context
+                    .getSystemService(Context.NOTIFICATION_SERVICE);
+            // 定义Notification的各种属性
+            Notification notification = null;
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+                // 低于API Level 11
+                // notification.setLatestEventInfo(context, title, msg, pendingIntent);
+            } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+                //高于API Level 11，低于API Level 16
+                Notification.Builder builder = new Notification.Builder(context)
+                        .setContentTitle(title)
+                        .setContentText(msg)
+                        .setContentIntent(pendingIntent);
+                notification = builder.getNotification();
+                notification.flags |= Notification.FLAG_ONGOING_EVENT | Notification.FLAG_SHOW_LIGHTS;
+                notification.defaults = Notification.DEFAULT_ALL;
+                notification.ledARGB = Color.GREEN;
+                notification.ledOnMS = 5000; //闪光时间，毫秒
+                notification.tickerText = ticker;
+            } else {
+                //高于API Level 16
+                notification = new Notification.Builder(context)
+                        .setContentTitle(title)
+                        .setContentText(msg)
+                        .setContentIntent(pendingIntent)
+                        .build();
+                notification.flags |= Notification.FLAG_ONGOING_EVENT | Notification.FLAG_SHOW_LIGHTS;
+                notification.defaults = Notification.DEFAULT_ALL;
+                notification.ledARGB = Color.GREEN;
+                notification.ledOnMS = 5000; //闪光时间，毫秒
+                notification.tickerText = ticker;
+
+            }
+            // 把Notification传递给NotificationManager
+            if (notification != null) {
+                notificationManager.notify(id, notification);
+            }
+        }
+    }
+
+    public static void lightLed(Context context, int colorOx, int durationMS) {
+        lightLed(context, colorOx, 0, durationMS);
+    }
+
+    public static void lightLed(Context context, int colorOx, int startOffMS, int durationMS) {
+        NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        Notification notification = new Notification();
+        notification.ledARGB = colorOx;
+        notification.ledOffMS = startOffMS;
+        notification.ledOnMS = durationMS;
+        notification.flags = Notification.FLAG_SHOW_LIGHTS;
+        LedID++;
+        nm.notify(LedID, notification);
+        nm.cancel(LedID);
+    }
+
+    public static void lightLed(final Context context, final int colorOx, final int startOffMS, final int durationMS,
+                                int repeat) {
+        if (repeat < 1) {
+            repeat = 1;
+        }
+        Handler handler = new Handler(Looper.getMainLooper());
+        for (int i = 0; i < repeat; i++) {
+            handler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    lightLed(context, colorOx, startOffMS, durationMS);
+                }
+            }, (startOffMS + durationMS) * i);
+        }
+    }
+
+    public static void lightLed(Context context, ArrayList<LightPattern> patterns) {
+        if (patterns == null) {
+            return;
+        }
+        for (LightPattern lp : patterns) {
+            lightLed(context, lp.argb, lp.startOffMS, lp.durationMS);
+        }
+    }
+
+    public static class LightPattern {
+        public int argb = 0;
+        public int startOffMS = 0;
+        public int durationMS = 0;
+
+        public LightPattern(int argb, int startOffMS, int durationMS) {
+            this.argb = argb;
+            this.startOffMS = startOffMS;
+            this.durationMS = durationMS;
+        }
+    }
+
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/entity/TypeInfo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/entity/TypeInfo.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/entity/TypeInfo.java	(revision )
@@ -0,0 +1,35 @@
+package com.scene.sceneandroiddemo.entity;
+
+import java.io.Serializable;
+
+/**
+ * Created by scene on 16/01/26.
+ */
+public class TypeInfo implements Serializable {
+    int id;
+    String type;
+
+    public TypeInfo() {
+    }
+
+    public TypeInfo(int id, String type) {
+        this.id = id;
+        this.type = type;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/UCrop.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/UCrop.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/UCrop.java	(revision )
@@ -0,0 +1,277 @@
+package com.yalantis.ucrop;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ * <p/>
+ * Builder class to ease Intent setup.
+ */
+public class UCrop {
+
+    public static final int REQUEST_CROP = 69;
+    public static final int RESULT_ERROR = 96;
+
+    public static final String EXTRA_INPUT_URI = "InputUri";
+    public static final String EXTRA_OUTPUT_URI = "OutputUri";
+    public static final String EXTRA_ERROR = "Error";
+
+    public static final String EXTRA_ASPECT_RATIO_SET = "AspectRatioSet";
+    public static final String EXTRA_ASPECT_RATIO_X = "AspectRatioX";
+    public static final String EXTRA_ASPECT_RATIO_Y = "AspectRatioY";
+
+    public static final String EXTRA_MAX_SIZE_SET = "MaxSizeSet";
+    public static final String EXTRA_MAX_SIZE_X = "MaxSizeX";
+    public static final String EXTRA_MAX_SIZE_Y = "MaxSizeY";
+
+    public static final String EXTRA_OPTIONS = "Options";
+
+    private Intent mCropIntent;
+
+    /**
+     * This method creates new Intent builder and sets both source and destination image URIs.
+     *
+     * @param source      Uri for image to crop
+     * @param destination Uri for saving the cropped image
+     */
+    public static UCrop of(@NonNull Uri source, @NonNull Uri destination) {
+        return new UCrop(source, destination);
+    }
+
+    private UCrop(@NonNull Uri source, @NonNull Uri destination) {
+        mCropIntent = new Intent();
+        mCropIntent.putExtra(EXTRA_INPUT_URI, source);
+        mCropIntent.putExtra(EXTRA_OUTPUT_URI, destination);
+    }
+
+    /**
+     * Set an aspect ratio for crop bounds.
+     * User won't see the menu with other ratios options.
+     *
+     * @param x aspect ratio X
+     * @param y aspect ratio Y
+     */
+    public UCrop withAspectRatio(@IntRange(from = 1) int x, @IntRange(from = 1) int y) {
+        mCropIntent.putExtra(EXTRA_ASPECT_RATIO_SET, true);
+        mCropIntent.putExtra(EXTRA_ASPECT_RATIO_X, x);
+        mCropIntent.putExtra(EXTRA_ASPECT_RATIO_Y, y);
+        return this;
+    }
+
+    /**
+     * Set an aspect ratio for crop bounds that is evaluated from source image width and height.
+     * User won't see the menu with other ratios options.
+     */
+    public UCrop useSourceImageAspectRatio() {
+        mCropIntent.putExtra(EXTRA_ASPECT_RATIO_SET, true);
+        mCropIntent.putExtra(EXTRA_ASPECT_RATIO_X, 0);
+        mCropIntent.putExtra(EXTRA_ASPECT_RATIO_Y, 0);
+        return this;
+    }
+
+    /**
+     * Set maximum size for result cropped image.
+     *
+     * @param width  max cropped image width
+     * @param height max cropped image height
+     */
+    public UCrop withMaxResultSize(@IntRange(from = 100) int width, @IntRange(from = 100) int height) {
+        mCropIntent.putExtra(EXTRA_MAX_SIZE_SET, true);
+        mCropIntent.putExtra(EXTRA_MAX_SIZE_X, width);
+        mCropIntent.putExtra(EXTRA_MAX_SIZE_Y, height);
+        return this;
+    }
+
+    public UCrop withOptions(@NonNull Options options) {
+        mCropIntent.putExtra(EXTRA_OPTIONS, options);
+        return this;
+    }
+
+    /**
+     * Send the crop Intent from an Activity
+     *
+     * @param activity Activity to receive result
+     */
+    public void start(@NonNull Activity activity) {
+        start(activity, REQUEST_CROP);
+    }
+
+    /**
+     * Send the crop Intent from an Activity with a custom request code
+     *
+     * @param activity    Activity to receive result
+     * @param requestCode requestCode for result
+     */
+    public void start(@NonNull Activity activity, int requestCode) {
+        activity.startActivityForResult(getIntent(activity), requestCode);
+    }
+
+    /**
+     * Send the crop Intent from a Fragment
+     *
+     * @param fragment Fragment to receive result
+     */
+    public void start(@NonNull Context context, @NonNull Fragment fragment) {
+        start(context, fragment, REQUEST_CROP);
+    }
+
+    /**
+     * Send the crop Intent from a support library Fragment
+     *
+     * @param fragment Fragment to receive result
+     */
+    public void start(@NonNull Context context, @NonNull android.support.v4.app.Fragment fragment) {
+        start(context, fragment, REQUEST_CROP);
+    }
+
+    /**
+     * Send the crop Intent with a custom request code
+     *
+     * @param fragment    Fragment to receive result
+     * @param requestCode requestCode for result
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public void start(@NonNull Context context, @NonNull Fragment fragment, int requestCode) {
+        fragment.startActivityForResult(getIntent(context), requestCode);
+    }
+
+    /**
+     * Send the crop Intent with a custom request code
+     *
+     * @param fragment    Fragment to receive result
+     * @param requestCode requestCode for result
+     */
+    public void start(@NonNull Context context, @NonNull android.support.v4.app.Fragment fragment, int requestCode) {
+        fragment.startActivityForResult(getIntent(context), requestCode);
+    }
+
+    /**
+     * Get Intent to start {@link UCropActivity}
+     *
+     * @return Intent for {@link UCropActivity}
+     */
+    public Intent getIntent(@NonNull Context context) {
+        mCropIntent.setClass(context, UCropActivity.class);
+        return mCropIntent;
+    }
+
+    /**
+     * Retrieve cropped image Uri from the result Intent
+     *
+     * @param intent crop result intent
+     */
+    @Nullable
+    public static Uri getOutput(@NonNull Intent intent) {
+        return intent.getParcelableExtra(EXTRA_OUTPUT_URI);
+    }
+
+    /**
+     * Method retrieves error from the result intent.
+     *
+     * @param result crop result Intent
+     * @return Throwable that could happen while image processing
+     */
+    @Nullable
+    public static Throwable getError(@NonNull Intent result) {
+        return (Throwable) result.getSerializableExtra(EXTRA_ERROR);
+    }
+
+
+    /**
+     * Class that helps to setup advanced configs that are not commonly used.
+     * Use it with method {@link #withOptions(Options)}
+     */
+    public static class Options implements Parcelable {
+
+        private int mMaxBitmapSize;
+        private String mCompressionFormatName;
+        private int mCompressionQuality;
+        private boolean mGesturesAlwaysEnabled;
+
+        public Options() {
+            // Set default values
+            mMaxBitmapSize = 0;
+            mCompressionFormatName = UCropActivity.DEFAULT_COMPRESS_FORMAT.name();
+            mCompressionQuality = UCropActivity.DEFAULT_COMPRESS_QUALITY;
+            mGesturesAlwaysEnabled = false;
+        }
+
+        public void setMaxBitmapSize(@IntRange(from = 100) int maxBitmapSize) {
+            mMaxBitmapSize = maxBitmapSize;
+        }
+
+        public void setCompressionFormat(@NonNull Bitmap.CompressFormat format) {
+            mCompressionFormatName = format.name();
+        }
+
+        public void setCompressionQuality(@IntRange(from = 1) int compressQuality) {
+            mCompressionQuality = compressQuality;
+        }
+
+        public void setGesturesAlwaysEnabled(boolean gesturesAlwaysEnabled) {
+            mGesturesAlwaysEnabled = gesturesAlwaysEnabled;
+        }
+
+        public int getMaxBitmapSize() {
+            return mMaxBitmapSize;
+        }
+
+        public String getCompressionFormatName() {
+            return mCompressionFormatName;
+        }
+
+        public int getCompressionQuality() {
+            return mCompressionQuality;
+        }
+
+        public boolean isGesturesAlwaysEnabled() {
+            return mGesturesAlwaysEnabled;
+        }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mMaxBitmapSize);
+            dest.writeString(mCompressionFormatName);
+            dest.writeInt(mCompressionQuality);
+            dest.writeByte((byte) (mGesturesAlwaysEnabled ? 1 : 0));
+        }
+
+        protected Options(Parcel in) {
+            mMaxBitmapSize = in.readInt();
+            mCompressionFormatName = in.readString();
+            mCompressionQuality = in.readInt();
+            mGesturesAlwaysEnabled = in.readByte() != 0;
+        }
+
+        public static final Creator<Options> CREATOR = new Creator<Options>() {
+            @Override
+            public Options createFromParcel(Parcel in) {
+                return new Options(in);
+            }
+
+            @Override
+            public Options[] newArray(int size) {
+                return new Options[size];
+            }
+        };
+
+    }
+
+}
\ No newline at end of file
Index: ucrop/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/.gitignore	(revision )
+++ ucrop/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/util/Attributes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/util/Attributes.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/util/Attributes.java	(revision )
@@ -0,0 +1,9 @@
+package com.scene.mylib.view.swipelayout.util;
+
+
+public class Attributes {
+
+    public enum Mode {
+        Single, Multiple
+    }
+}
Index: customfresco/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/proguard-rules.pro	(revision )
+++ customfresco/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\Devolopment\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: gradlew
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradlew	(revision )
+++ gradlew	(revision )
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/FourthFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/FourthFragment.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/FourthFragment.java	(revision )
@@ -0,0 +1,42 @@
+package com.scene.sceneandroiddemo.ui.fragments;
+
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+
+import com.scene.sceneandroiddemo.BaseFragment;
+import com.scene.sceneandroiddemo.R;
+import com.scene.sceneandroiddemo.adapter.TimeLineAdapter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import butterknife.Bind;
+
+
+public class FourthFragment extends BaseFragment {
+
+    @Bind(R.id.recyclerView)
+    RecyclerView recyclerView;
+
+    public static FourthFragment instance() {
+        FourthFragment view = new FourthFragment();
+        return view;
+    }
+
+    @Override
+    public int setLayoutResId() {
+        return R.layout.fragment4;
+    }
+
+    @Override
+    public void init() {
+        List<String> mList = new ArrayList<>();
+        for (int i = 0; i < 10; i++) {
+            mList.add("这是第" + (i + 1) + "条");
+        }
+        TimeLineAdapter adapter=new TimeLineAdapter(getActivity(),mList);
+        LinearLayoutManager layoutManager=new LinearLayoutManager(getActivity());
+        recyclerView.setLayoutManager(layoutManager);
+        recyclerView.setAdapter(adapter);
+    }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/loadstateview/LoadStateView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/loadstateview/LoadStateView.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/loadstateview/LoadStateView.java	(revision )
@@ -0,0 +1,496 @@
+package com.scene.mylib.view.loadstateview;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.scene.mylib.R;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * @author Vlonjat Gashi (vlonjatg)
+ */
+public class LoadStateView extends RelativeLayout {
+
+    private static final String TAG_LOADING = "ProgressActivity.TAG_LOADING";
+    private static final String TAG_EMPTY = "ProgressActivity.TAG_EMPTY";
+    private static final String TAG_ERROR = "ProgressActivity.TAG_ERROR";
+
+    final String CONTENT = "type_content";
+    final String LOADING = "type_loading";
+    final String EMPTY = "type_empty";
+    final String ERROR = "type_error";
+
+    LayoutInflater inflater;
+    View view;
+    LayoutParams layoutParams;
+    Drawable currentBackground;
+
+    List<View> contentViews = new ArrayList<>();
+
+    RelativeLayout loadingStateRelativeLayout;
+    ProgressBar loadingStateProgressBar;
+
+    RelativeLayout emptyStateRelativeLayout;
+    ImageView emptyStateImageView;
+    TextView emptyStateTitleTextView;
+    TextView emptyStateContentTextView;
+
+    RelativeLayout errorStateRelativeLayout;
+    ImageView errorStateImageView;
+    TextView errorStateTitleTextView;
+    TextView errorStateContentTextView;
+    Button errorStateButton;
+
+    int loadingStateProgressBarWidth;
+    int loadingStateProgressBarHeight;
+    int loadingStateBackgroundColor;
+
+    int emptyStateImageWidth;
+    int emptyStateImageHeight;
+    int emptyStateTitleTextSize;
+    int emptyStateContentTextSize;
+    int emptyStateTitleTextColor;
+    int emptyStateContentTextColor;
+    int emptyStateBackgroundColor;
+
+    int errorStateImageWidth;
+    int errorStateImageHeight;
+    int errorStateTitleTextSize;
+    int errorStateContentTextSize;
+    int errorStateTitleTextColor;
+    int errorStateContentTextColor;
+    int errorStateButtonTextColor;
+    int errorStateBackgroundColor;
+
+    private String state = CONTENT;
+
+    public LoadStateView(Context context) {
+        super(context);
+    }
+
+    public LoadStateView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(attrs);
+    }
+
+    public LoadStateView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(attrs);
+    }
+
+    private void init(AttributeSet attrs) {
+        inflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+        TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.LoadStateView);
+
+        //Loading state attrs
+        loadingStateProgressBarWidth =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_loadingProgressBarWidth, 108);
+
+        loadingStateProgressBarHeight =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_loadingProgressBarHeight, 108);
+
+        loadingStateBackgroundColor =
+                typedArray.getColor(R.styleable.LoadStateView_loadingBackgroundColor, Color.TRANSPARENT);
+
+        //Empty state attrs
+        emptyStateImageWidth =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_emptyImageWidth, 308);
+
+        emptyStateImageHeight =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_emptyImageHeight, 308);
+
+        emptyStateTitleTextSize =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_emptyTitleTextSize, 15);
+
+        emptyStateContentTextSize =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_emptyContentTextSize, 14);
+
+        emptyStateTitleTextColor =
+                typedArray.getColor(R.styleable.LoadStateView_emptyTitleTextColor, Color.BLACK);
+
+        emptyStateContentTextColor =
+                typedArray.getColor(R.styleable.LoadStateView_emptyContentTextColor, Color.BLACK);
+
+        emptyStateBackgroundColor =
+                typedArray.getColor(R.styleable.LoadStateView_emptyBackgroundColor, Color.TRANSPARENT);
+
+        //Error state attrs
+        errorStateImageWidth =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_errorImageWidth, 308);
+
+        errorStateImageHeight =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_errorImageHeight, 308);
+
+        errorStateTitleTextSize =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_errorTitleTextSize, 15);
+
+        errorStateContentTextSize =
+                typedArray.getDimensionPixelSize(R.styleable.LoadStateView_errorContentTextSize, 14);
+
+        errorStateTitleTextColor =
+                typedArray.getColor(R.styleable.LoadStateView_errorTitleTextColor, Color.BLACK);
+
+        errorStateContentTextColor =
+                typedArray.getColor(R.styleable.LoadStateView_errorContentTextColor, Color.BLACK);
+
+        errorStateButtonTextColor =
+                typedArray.getColor(R.styleable.LoadStateView_errorButtonTextColor, Color.BLACK);
+
+        errorStateBackgroundColor =
+                typedArray.getColor(R.styleable.LoadStateView_errorBackgroundColor, Color.TRANSPARENT);
+
+        typedArray.recycle();
+
+        currentBackground = this.getBackground();
+    }
+
+    @Override
+    public void addView(@NonNull View child, int index, ViewGroup.LayoutParams params) {
+        super.addView(child, index, params);
+
+        if (child.getTag() == null || (!child.getTag().equals(TAG_LOADING) &&
+                !child.getTag().equals(TAG_EMPTY) && !child.getTag().equals(TAG_ERROR))) {
+
+            contentViews.add(child);
+        }
+    }
+
+    /**
+     * Hide all other states and show content
+     */
+    public void showContent() {
+        switchState(CONTENT, null, null, null, null, null, Collections.<Integer>emptyList());
+    }
+
+    /**
+     * Hide all other states and show content
+     *
+     * @param skipIds Ids of views not to show
+     */
+    public void showContent(List<Integer> skipIds) {
+        switchState(CONTENT, null, null, null, null, null, skipIds);
+    }
+
+    /**
+     * Hide content and show the progress bar
+     */
+    public void showLoading() {
+        switchState(LOADING, null, null, null, null, null, Collections.<Integer>emptyList());
+    }
+
+    /**
+     * Hide content and show the progress bar
+     *
+     * @param skipIds Ids of views to not hide
+     */
+    public void showLoading(List<Integer> skipIds) {
+        switchState(LOADING, null, null, null, null, null, skipIds);
+    }
+
+    /**
+     * Show empty view when there are not data to show
+     *
+     * @param emptyImageDrawable Drawable to show
+     * @param emptyTextTitle     Title of the empty view to show
+     * @param emptyTextContent   Content of the empty view to show
+     */
+    public void showEmpty(Drawable emptyImageDrawable, String emptyTextTitle, String emptyTextContent) {
+        switchState(EMPTY, emptyImageDrawable, emptyTextTitle, emptyTextContent, null, null, Collections.<Integer>emptyList());
+    }
+
+    public void showEmpty(int emptyImageDrawableRes, String emptyTextTitle, String emptyTextContent) {
+        switchState(EMPTY, getResources().getDrawable(emptyImageDrawableRes), emptyTextTitle, emptyTextContent, null, null, Collections.<Integer>emptyList());
+    }
+
+    /**
+     * Show empty view when there are not data to show
+     *
+     * @param emptyImageDrawable Drawable to show
+     * @param emptyTextTitle     Title of the empty view to show
+     * @param emptyTextContent   Content of the empty view to show
+     * @param skipIds            Ids of views to not hide
+     */
+    public void showEmpty(Drawable emptyImageDrawable, String emptyTextTitle, String emptyTextContent, List<Integer> skipIds) {
+        switchState(EMPTY, emptyImageDrawable, emptyTextTitle, emptyTextContent, null, null, skipIds);
+    }
+
+    /**
+     * Show error view with a button when something goes wrong and prompting the user to try again
+     *
+     * @param errorImageDrawable Drawable to show
+     * @param errorTextTitle     Title of the error view to show
+     * @param errorTextContent   Content of the error view to show
+     * @param errorButtonText    Text on the error view button to show
+     * @param onClickListener    Listener of the error view button
+     */
+    public void showError(Drawable errorImageDrawable, String errorTextTitle, String errorTextContent, String errorButtonText, View.OnClickListener onClickListener) {
+        switchState(ERROR, errorImageDrawable, errorTextTitle, errorTextContent, errorButtonText, onClickListener, Collections.<Integer>emptyList());
+    }
+
+    public void showError(int errorImageDrawableRes, String errorTextTitle, String errorTextContent, String errorButtonText, View.OnClickListener onClickListener) {
+        switchState(ERROR, getResources().getDrawable(errorImageDrawableRes), errorTextTitle, errorTextContent, errorButtonText, onClickListener, Collections.<Integer>emptyList());
+    }
+
+    /**
+     * Show error view with a button when something goes wrong and prompting the user to try again
+     *
+     * @param errorImageDrawable Drawable to show
+     * @param errorTextTitle     Title of the error view to show
+     * @param errorTextContent   Content of the error view to show
+     * @param errorButtonText    Text on the error view button to show
+     * @param onClickListener    Listener of the error view button
+     * @param skipIds            Ids of views to not hide
+     */
+    public void showError(Drawable errorImageDrawable, String errorTextTitle, String errorTextContent, String errorButtonText, View.OnClickListener onClickListener, List<Integer> skipIds) {
+        switchState(ERROR, errorImageDrawable, errorTextTitle, errorTextContent, errorButtonText, onClickListener, skipIds);
+    }
+
+    /**
+     * Get which state is set
+     *
+     * @return State
+     */
+    public String getState() {
+        return state;
+    }
+
+    /**
+     * Check if content is shown
+     *
+     * @return boolean
+     */
+    public boolean isContent() {
+        return state.equals(CONTENT);
+    }
+
+    /**
+     * Check if loading state is shown
+     *
+     * @return boolean
+     */
+    public boolean isLoading() {
+        return state.equals(LOADING);
+    }
+
+    /**
+     * Check if empty state is shown
+     *
+     * @return boolean
+     */
+    public boolean isEmpty() {
+        return state.equals(EMPTY);
+    }
+
+    /**
+     * Check if error state is shown
+     *
+     * @return boolean
+     */
+    public boolean isError() {
+        return state.equals(ERROR);
+    }
+
+    private void switchState(String state, Drawable drawable, String errorText, String errorTextContent,
+                             String errorButtonText, View.OnClickListener onClickListener, List<Integer> skipIds) {
+        this.state = state;
+
+        switch (state) {
+            case CONTENT:
+                //Hide all state views to display content
+                hideLoadingView();
+                hideEmptyView();
+                hideErrorView();
+
+                setContentVisibility(true, skipIds);
+                break;
+            case LOADING:
+                hideEmptyView();
+                hideErrorView();
+
+                setLoadingView();
+                setContentVisibility(false, skipIds);
+                break;
+            case EMPTY:
+                hideLoadingView();
+                hideErrorView();
+
+                setEmptyView();
+                emptyStateImageView.setImageDrawable(drawable);
+                emptyStateTitleTextView.setText(errorText);
+                emptyStateContentTextView.setText(errorTextContent);
+                setContentVisibility(false, skipIds);
+                break;
+            case ERROR:
+                hideLoadingView();
+                hideEmptyView();
+
+                setErrorView();
+                errorStateImageView.setImageDrawable(drawable);
+                errorStateTitleTextView.setText(errorText);
+                errorStateContentTextView.setText(errorTextContent);
+                errorStateButton.setText(errorButtonText);
+                errorStateButton.setOnClickListener(onClickListener);
+                setContentVisibility(false, skipIds);
+                break;
+        }
+    }
+
+    private void setLoadingView() {
+        if (loadingStateRelativeLayout == null) {
+            view = inflater.inflate(R.layout.layout_load_state_view_load, null);
+            loadingStateRelativeLayout = (RelativeLayout) view.findViewById(R.id.loadingStateRelativeLayout);
+            loadingStateRelativeLayout.setTag(TAG_LOADING);
+
+            loadingStateProgressBar = (ProgressBar) view.findViewById(R.id.loadingStateProgressBar);
+
+            loadingStateProgressBar.getLayoutParams().width = loadingStateProgressBarWidth;
+            loadingStateProgressBar.getLayoutParams().height = loadingStateProgressBarHeight;
+            loadingStateProgressBar.requestLayout();
+
+            //Set background color if not TRANSPARENT
+            if (loadingStateBackgroundColor != Color.TRANSPARENT) {
+                this.setBackgroundColor(loadingStateBackgroundColor);
+            }
+
+            layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                    ViewGroup.LayoutParams.MATCH_PARENT);
+            layoutParams.addRule(CENTER_IN_PARENT);
+
+            addView(loadingStateRelativeLayout, layoutParams);
+        } else {
+            loadingStateRelativeLayout.setVisibility(VISIBLE);
+        }
+    }
+
+    private void setEmptyView() {
+        if (emptyStateRelativeLayout == null) {
+            view = inflater.inflate(R.layout.layout_load_state_view_empty, null);
+            emptyStateRelativeLayout = (RelativeLayout) view.findViewById(R.id.emptyStateRelativeLayout);
+            emptyStateRelativeLayout.setTag(TAG_EMPTY);
+
+            emptyStateImageView = (ImageView) view.findViewById(R.id.emptyStateImageView);
+            emptyStateTitleTextView = (TextView) view.findViewById(R.id.emptyStateTitleTextView);
+            emptyStateContentTextView = (TextView) view.findViewById(R.id.emptyStateContentTextView);
+
+            //Set empty state image width and height
+            emptyStateImageView.getLayoutParams().width = emptyStateImageWidth;
+            emptyStateImageView.getLayoutParams().height = emptyStateImageHeight;
+            emptyStateImageView.requestLayout();
+
+            emptyStateTitleTextView.setTextSize(emptyStateTitleTextSize);
+            emptyStateContentTextView.setTextSize(emptyStateContentTextSize);
+            emptyStateTitleTextView.setTextColor(emptyStateTitleTextColor);
+            emptyStateContentTextView.setTextColor(emptyStateContentTextColor);
+
+            //Set background color if not TRANSPARENT
+            if (emptyStateBackgroundColor != Color.TRANSPARENT) {
+                this.setBackgroundColor(emptyStateBackgroundColor);
+            }
+
+            layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                    ViewGroup.LayoutParams.MATCH_PARENT);
+            layoutParams.addRule(CENTER_IN_PARENT);
+
+            addView(emptyStateRelativeLayout, layoutParams);
+        } else {
+            emptyStateRelativeLayout.setVisibility(VISIBLE);
+        }
+    }
+
+    private void setErrorView() {
+        if (errorStateRelativeLayout == null) {
+            view = inflater.inflate(R.layout.layout_load_state_view_error, null);
+            errorStateRelativeLayout = (RelativeLayout) view.findViewById(R.id.errorStateRelativeLayout);
+            errorStateRelativeLayout.setTag(TAG_ERROR);
+
+            errorStateImageView = (ImageView) view.findViewById(R.id.errorStateImageView);
+            errorStateTitleTextView = (TextView) view.findViewById(R.id.errorStateTitleTextView);
+            errorStateContentTextView = (TextView) view.findViewById(R.id.errorStateContentTextView);
+            errorStateButton = (Button) view.findViewById(R.id.errorStateButton);
+
+            //Set error state image width and height
+            errorStateImageView.getLayoutParams().width = errorStateImageWidth;
+            errorStateImageView.getLayoutParams().height = errorStateImageHeight;
+            errorStateImageView.requestLayout();
+
+            errorStateTitleTextView.setTextSize(errorStateTitleTextSize);
+            errorStateContentTextView.setTextSize(errorStateContentTextSize);
+            errorStateTitleTextView.setTextColor(errorStateTitleTextColor);
+            errorStateContentTextView.setTextColor(errorStateContentTextColor);
+            errorStateButton.setTextColor(errorStateButtonTextColor);
+
+            //Set background color if not TRANSPARENT
+            if (errorStateBackgroundColor != Color.TRANSPARENT) {
+                this.setBackgroundColor(errorStateBackgroundColor);
+            }
+
+            layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                    ViewGroup.LayoutParams.MATCH_PARENT);
+            layoutParams.addRule(CENTER_IN_PARENT);
+
+            addView(errorStateRelativeLayout, layoutParams);
+        } else {
+            errorStateRelativeLayout.setVisibility(VISIBLE);
+        }
+    }
+
+    private void setContentVisibility(boolean visible, List<Integer> skipIds) {
+        for (View v : contentViews) {
+            if (!skipIds.contains(v.getId())) {
+                v.setVisibility(visible ? View.VISIBLE : View.GONE);
+            }
+        }
+    }
+
+    private void hideLoadingView() {
+        if (loadingStateRelativeLayout != null) {
+            loadingStateRelativeLayout.setVisibility(GONE);
+
+            //Restore the background color if not TRANSPARENT
+            if (loadingStateBackgroundColor != Color.TRANSPARENT) {
+                this.setBackgroundDrawable(currentBackground);
+            }
+        }
+    }
+
+    private void hideEmptyView() {
+        if (emptyStateRelativeLayout != null) {
+            emptyStateRelativeLayout.setVisibility(GONE);
+
+            //Restore the background color if not TRANSPARENT
+            if (emptyStateBackgroundColor != Color.TRANSPARENT) {
+                this.setBackgroundDrawable(currentBackground);
+                ;
+            }
+        }
+    }
+
+    private void hideErrorView() {
+        if (errorStateRelativeLayout != null) {
+            errorStateRelativeLayout.setVisibility(GONE);
+
+            //Restore the background color if not TRANSPARENT
+            if (errorStateBackgroundColor != Color.TRANSPARENT) {
+                this.setBackgroundDrawable(currentBackground);
+                ;
+            }
+
+        }
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/ClipboardUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/ClipboardUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/ClipboardUtil.java	(revision )
@@ -0,0 +1,59 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.Context;
+import android.os.Build;
+
+/**
+ * @author MaTianyu @http://litesuits.com
+ * @date 2015-08-25
+ */
+public class ClipboardUtil {
+
+    public static void copyToClipboardSupport(Context context, String text) {
+        android.text.ClipboardManager clipboard = (android.text.ClipboardManager) context
+                .getSystemService(Context.CLIPBOARD_SERVICE);
+        clipboard.setText(text);
+    }
+
+    public static void getLatestTextSupport(Context context) {
+        android.text.ClipboardManager clipboard = (android.text.ClipboardManager) context
+                .getSystemService(Context.CLIPBOARD_SERVICE);
+        clipboard.getText();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static void copyToClipboard(Context context, String text) {
+        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
+        clipboard.setPrimaryClip(ClipData.newPlainText(null, text));
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static int getItemCount(Context context) {
+        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
+        ClipData data = clipboard.getPrimaryClip();
+        return data.getItemCount();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static String getText(Context context, int index) {
+        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
+        ClipData clip = clipboard.getPrimaryClip();
+        if (clip != null && clip.getItemCount() > index) {
+            return String.valueOf(clip.getItemAt(0).coerceToText(context));
+        }
+        return null;
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static String getLatestText(Context context) {
+        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
+        ClipData clip = clipboard.getPrimaryClip();
+        if (clip != null && clip.getItemCount() > 0) {
+            return String.valueOf(clip.getItemAt(0).coerceToText(context));
+        }
+        return null;
+    }
+}
Index: common/src/main/java/com/scene/common/common/data/cipher/Base64Cipher.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/data/cipher/Base64Cipher.java	(revision )
+++ common/src/main/java/com/scene/common/common/data/cipher/Base64Cipher.java	(revision )
@@ -0,0 +1,31 @@
+package com.scene.common.common.data.cipher;
+
+
+import com.scene.common.common.assist.Base64;
+
+/**
+ * @author MaTianyu
+ * @date 14-7-31
+ */
+public class Base64Cipher extends Cipher {
+    private Cipher cipher;
+
+    public Base64Cipher() {
+    }
+
+    public Base64Cipher(Cipher cipher) {
+        this.cipher = cipher;
+    }
+
+    @Override
+    public byte[] decrypt(byte[] res) {
+        if(cipher != null) res = cipher.decrypt(res);
+        return Base64.decode(res, Base64.DEFAULT);
+    }
+
+    @Override
+    public byte[] encrypt(byte[] res) {
+        if(cipher != null) res = cipher.encrypt(res);
+        return Base64.encode(res, Base64.DEFAULT);
+    }
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/view/CropImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/view/CropImageView.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/view/CropImageView.java	(revision )
@@ -0,0 +1,714 @@
+package com.yalantis.ucrop.view;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+
+import com.yalantis.ucrop.R;
+import com.yalantis.ucrop.util.CubicEasing;
+import com.yalantis.ucrop.util.RectUtils;
+
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ * <p/>
+ * This class adds crop feature, methods to draw crop guidelines, and keep image in correct state.
+ * Also it extends parent class methods to add checks for scale; animating zoom in/out.
+ */
+public abstract class CropImageView extends TransformImageView {
+
+    public static final float SOURCE_IMAGE_ASPECT_RATIO = 0f;
+
+    private static final boolean DEFAULT_SHOW_CROP_FRAME = false;
+    private static final boolean DEFAULT_SHOW_CROP_GRID = true;
+    private static final int DEFAULT_CROP_GRID_ROW_COUNT = 3;
+    private static final int DEFAULT_CROP_GRID_COLUMN_COUNT = 3;
+    private static final int DEFAULT_IMAGE_TO_CROP_BOUNDS_ANIM_DURATION = 777;
+
+    private static final float DEFAULT_ASPECT_RATIO = SOURCE_IMAGE_ASPECT_RATIO;
+
+    private static final float DEFAULT_MAX_SCALE_MULTIPLIER = 10.0f;
+
+    private final RectF mCropRect = new RectF();
+    private final RectF mCropViewRect = new RectF();
+
+    private final Matrix mTempMatrix = new Matrix();
+
+    private int mCropGridRowCount, mCropGridColumnCount;
+    private float mTargetAspectRatio;
+    private float[] mGridPoints = null;
+    private boolean mShowCropFrame, mShowCropGrid;
+    private Paint mDimmedPaint, mGridInnerLinePaint, mGridOuterLinePaint;
+    private float mMaxScaleMultiplier;
+
+    private Runnable mWrapCropBoundsRunnable, mZoomImageToPositionRunnable = null;
+
+    private float mMaxScale, mMinScale;
+    private int mMaxResultImageSizeX = 0, mMaxResultImageSizeY = 0;
+    private long mImageToWrapCropBoundsAnimDuration = DEFAULT_IMAGE_TO_CROP_BOUNDS_ANIM_DURATION;
+
+    public CropImageView(Context context) {
+        this(context, null);
+    }
+
+    public CropImageView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public CropImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context, attrs, defStyle);
+    }
+
+    /**
+     * This method crops part of image that fills the crop bounds.
+     * <p/>
+     * First image is downscaled if max size was set and if resulting image is larger that max size.
+     * Then image is rotated accordingly.
+     * Finally new Bitmap object is created and returned.
+     *
+     * @return - cropped Bitmap object or null if any error occurs.
+     */
+    @Nullable
+    public Bitmap cropImage() throws Exception {
+        Bitmap viewBitmap = getViewBitmap();
+        if (viewBitmap == null) {
+            return null;
+        }
+
+        cancelAllAnimations();
+        setImageToWrapCropBounds(false);
+
+        RectF currentImageRect = RectUtils.trapToRect(mCurrentImageCorners);
+        if (currentImageRect.isEmpty()) {
+            return null;
+        }
+
+        float currentScale = getCurrentScale();
+        float currentAngle = getCurrentAngle();
+
+        if (mMaxResultImageSizeX > 0 && mMaxResultImageSizeY > 0) {
+            float cropWidth = mCropRect.width() / currentScale;
+            float cropHeight = mCropRect.height() / currentScale;
+
+            if (cropWidth > mMaxResultImageSizeX || cropHeight > mMaxResultImageSizeY) {
+
+                float scaleX = mMaxResultImageSizeX / cropWidth;
+                float scaleY = mMaxResultImageSizeY / cropHeight;
+                float resizeScale = Math.min(scaleX, scaleY);
+
+                Bitmap resizedBitmap = Bitmap.createScaledBitmap(viewBitmap,
+                        (int) (viewBitmap.getWidth() * resizeScale),
+                        (int) (viewBitmap.getHeight() * resizeScale), false);
+                viewBitmap.recycle();
+                viewBitmap = resizedBitmap;
+
+                currentScale /= resizeScale;
+            }
+        }
+
+        if (currentAngle != 0) {
+            mTempMatrix.reset();
+            mTempMatrix.setRotate(currentAngle, viewBitmap.getWidth() / 2, viewBitmap.getHeight() / 2);
+
+            Bitmap rotatedBitmap = Bitmap.createBitmap(viewBitmap, 0, 0, viewBitmap.getWidth(), viewBitmap.getHeight(),
+                    mTempMatrix, true);
+            viewBitmap.recycle();
+            viewBitmap = rotatedBitmap;
+        }
+
+        int top = (int) ((mCropRect.top - currentImageRect.top) / currentScale);
+        int left = (int) ((mCropRect.left - currentImageRect.left) / currentScale);
+        int width = (int) (mCropRect.width() / currentScale);
+        int height = (int) (mCropRect.height() / currentScale);
+
+        return Bitmap.createBitmap(viewBitmap, left, top, width, height);
+    }
+
+    /**
+     * @return - maximum scale value for current image and crop ratio
+     */
+    public float getMaxScale() {
+        return mMaxScale;
+    }
+
+    /**
+     * @return - minimum scale value for current image and crop ratio
+     */
+    public float getMinScale() {
+        return mMinScale;
+    }
+
+    /**
+     * @return - aspect ratio for crop bounds
+     */
+    public float getTargetAspectRatio() {
+        return mTargetAspectRatio;
+    }
+
+    /**
+     * This method sets aspect ratio for crop bounds.
+     * If {@link #SOURCE_IMAGE_ASPECT_RATIO} value is passed - aspect ratio is calculated
+     * based on current image width and height.
+     *
+     * @param targetAspectRatio - aspect ratio for image crop (e.g. 1.77(7) for 16:9)
+     */
+    public void setTargetAspectRatio(float targetAspectRatio) {
+        final Drawable drawable = getDrawable();
+        if (drawable == null) {
+            mTargetAspectRatio = targetAspectRatio;
+            return;
+        }
+
+        if (targetAspectRatio == SOURCE_IMAGE_ASPECT_RATIO) {
+            mTargetAspectRatio = drawable.getIntrinsicWidth() / (float) drawable.getIntrinsicHeight();
+        } else {
+            mTargetAspectRatio = targetAspectRatio;
+        }
+
+        setupCropBounds();
+        mGridPoints = null;
+
+        postInvalidate();
+    }
+
+    /**
+     * This method sets maximum width for resulting cropped image
+     *
+     * @param maxResultImageSizeX - size in pixels
+     */
+    public void setMaxResultImageSizeX(@IntRange(from = 10) int maxResultImageSizeX) {
+        mMaxResultImageSizeX = maxResultImageSizeX;
+    }
+
+    /**
+     * This method sets maximum width for resulting cropped image
+     *
+     * @param maxResultImageSizeY - size in pixels
+     */
+    public void setMaxResultImageSizeY(@IntRange(from = 10) int maxResultImageSizeY) {
+        mMaxResultImageSizeY = maxResultImageSizeY;
+    }
+
+    /**
+     * This method sets animation duration for image to wrap the crop bounds
+     *
+     * @param imageToWrapCropBoundsAnimDuration - duration in milliseconds
+     */
+    public void setImageToWrapCropBoundsAnimDuration(@IntRange(from = 100) long imageToWrapCropBoundsAnimDuration) {
+        if (imageToWrapCropBoundsAnimDuration > 0) {
+            mImageToWrapCropBoundsAnimDuration = imageToWrapCropBoundsAnimDuration;
+        } else {
+            throw new IllegalArgumentException("Animation duration cannot be negative value.");
+        }
+    }
+
+    /**
+     * This method scales image down for given value related to image center.
+     */
+    public void zoomOutImage(float deltaScale) {
+        zoomOutImage(deltaScale, mCropRect.centerX(), mCropRect.centerY());
+    }
+
+    /**
+     * This method scales image down for given value related given coords (x, y).
+     */
+    public void zoomOutImage(float scale, float centerX, float centerY) {
+        if (scale >= getMinScale()) {
+            postScale(scale / getCurrentScale(), centerX, centerY);
+        }
+    }
+
+    /**
+     * This method scales image up for given value related to image center.
+     */
+    public void zoomInImage(float deltaScale) {
+        zoomInImage(deltaScale, mCropRect.centerX(), mCropRect.centerY());
+    }
+
+    /**
+     * This method scales image up for given value related to given coords (x, y).
+     */
+    public void zoomInImage(float scale, float centerX, float centerY) {
+        if (scale <= getMaxScale()) {
+            postScale(scale / getCurrentScale(), centerX, centerY);
+        }
+    }
+
+    /**
+     * This method changes image scale for given value related to point (px, py) but only if
+     * resulting scale is in min/max bounds.
+     *
+     * @param deltaScale - scale value
+     * @param px         - scale center X
+     * @param py         - scale center Y
+     */
+    public void postScale(float deltaScale, float px, float py) {
+        if (deltaScale > 1 && getCurrentScale() * deltaScale <= getMaxScale()) {
+            super.postScale(deltaScale, px, py);
+        } else if (deltaScale < 1 && getCurrentScale() * deltaScale >= getMinScale()) {
+            super.postScale(deltaScale, px, py);
+        }
+    }
+
+    /**
+     * This method rotates image for given angle related to the image center.
+     *
+     * @param deltaAngle - angle to rotate
+     */
+    public void postRotate(float deltaAngle) {
+        postRotate(deltaAngle, mCropRect.centerX(), mCropRect.centerY());
+    }
+
+    /**
+     * This method cancels all current Runnable objects that represent animations.
+     */
+    public void cancelAllAnimations() {
+        removeCallbacks(mWrapCropBoundsRunnable);
+        removeCallbacks(mZoomImageToPositionRunnable);
+    }
+
+    public void setImageToWrapCropBounds() {
+        setImageToWrapCropBounds(true);
+    }
+
+    /**
+     * If image doesn't fill the crop bounds it must be translated and scaled properly to fill those.
+     * <p/>
+     * Therefore this method calculates delta X, Y and scale values and passes them to the
+     * {@link WrapCropBoundsRunnable} which animates image.
+     * Scale value must be calculated only if image won't fill the crop bounds after it's translated to the
+     * crop bounds rectangle center. Using temporary variables this method checks this case.
+     */
+    public void setImageToWrapCropBounds(boolean animate) {
+        if (!isImageWrapCropBounds()) {
+
+            float currentX = mCurrentImageCenter[0];
+            float currentY = mCurrentImageCenter[1];
+            float currentScale = getCurrentScale();
+
+            float deltaX = mCropRect.centerX() - currentX;
+            float deltaY = mCropRect.centerY() - currentY;
+            float deltaScale = 0;
+
+            mTempMatrix.reset();
+            mTempMatrix.setTranslate(deltaX, deltaY);
+
+            float[] tempCurrentImageCorners = Arrays.copyOf(mCurrentImageCorners, mCurrentImageCorners.length);
+            mTempMatrix.mapPoints(tempCurrentImageCorners);
+
+            boolean willImageWrapCropBoundsAfterTranslate = isImageWrapCropBounds(tempCurrentImageCorners);
+
+            if (!willImageWrapCropBoundsAfterTranslate) {
+                RectF tempCropRect = new RectF(mCropRect);
+                mTempMatrix.reset();
+                mTempMatrix.setRotate(getCurrentAngle());
+                mTempMatrix.mapRect(tempCropRect);
+
+                float[] currentImageSides = RectUtils.getRectSidesFromCorners(mCurrentImageCorners);
+
+                deltaScale = Math.max(tempCropRect.width() / currentImageSides[0],
+                        tempCropRect.height() / currentImageSides[1]);
+                // Ugly but there are always couple pixels that want to hide because of all these calculations
+                deltaScale *= 1.01;
+                deltaScale = deltaScale * currentScale - currentScale;
+            }
+
+            if (animate) {
+                post(mWrapCropBoundsRunnable = new WrapCropBoundsRunnable(
+                        CropImageView.this, mImageToWrapCropBoundsAnimDuration, currentX, currentY, deltaX, deltaY,
+                        currentScale, deltaScale, willImageWrapCropBoundsAfterTranslate));
+            } else {
+                postTranslate(deltaX, deltaY);
+                if (!willImageWrapCropBoundsAfterTranslate) {
+                    zoomInImage(currentScale + deltaScale, mCropRect.centerX(), mCropRect.centerY());
+                }
+            }
+        }
+    }
+
+    protected void init(Context context, AttributeSet attrs, int defStyle) {
+        super.init(context, attrs, defStyle);
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ucrop_CropImageView);
+        processStyledAttributes(a);
+        a.recycle();
+    }
+
+    /**
+     * Along with image there are dimmed layer, crop bounds and crop guidelines that must be drawn.
+     */
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        drawDimmedLayer(canvas);
+        drawCropGrid(canvas);
+    }
+
+    /**
+     * Could use
+     * <p/>
+     * canvas.save();
+     * canvas.clipRect(mCropViewRect, Region.Op.DIFFERENCE);
+     * canvas.drawColor(mOverlayColor);
+     * canvas.restore();
+     * <p/>
+     * but this won't properly work on number of devices with HW acceleration enabled.
+     * So lets just draw rectangles...
+     *
+     * @param canvas - current canvas
+     */
+    protected void drawDimmedLayer(@NonNull Canvas canvas) {
+        canvas.drawRect(0, mCropViewRect.top, mCropViewRect.left, mCropViewRect.bottom, mDimmedPaint);
+        canvas.drawRect(0, 0, canvas.getWidth(), mCropViewRect.top, mDimmedPaint);
+        canvas.drawRect(mCropViewRect.right, mCropViewRect.top, canvas.getWidth(), mCropViewRect.bottom, mDimmedPaint);
+        canvas.drawRect(0, mCropViewRect.bottom, canvas.getWidth(), canvas.getHeight(), mDimmedPaint);
+    }
+
+    /**
+     * This method draws crop bounds (empty rectangle)
+     * and crop guidelines (vertical and horizontal lines inside the crop bounds) if needed.
+     *
+     * @param canvas - valid canvas object
+     */
+    protected void drawCropGrid(@NonNull Canvas canvas) {
+        if (mShowCropGrid) {
+            if (mGridPoints == null && !mCropViewRect.isEmpty()) {
+
+                mGridPoints = new float[(mCropGridRowCount - 1) * 4 + (mCropGridColumnCount - 1) * 4];
+
+                int index = 0;
+                for (int i = 0; i < mCropGridRowCount - 1; i++) {
+                    mGridPoints[index++] = mCropViewRect.left;
+                    mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) mCropGridRowCount)) + mCropViewRect.top;
+                    mGridPoints[index++] = mCropViewRect.right;
+                    mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) mCropGridRowCount)) + mCropViewRect.top;
+                }
+
+                for (int i = 0; i < mCropGridColumnCount - 1; i++) {
+                    mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) mCropGridColumnCount)) + mCropViewRect.left;
+                    mGridPoints[index++] = mCropViewRect.top;
+                    mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) mCropGridColumnCount)) + mCropViewRect.left;
+                    mGridPoints[index++] = mCropViewRect.bottom;
+                }
+            }
+
+            if (mGridPoints != null) {
+                canvas.drawLines(mGridPoints, mGridInnerLinePaint);
+            }
+        }
+
+        if (mShowCropFrame) {
+            canvas.drawRect(mCropViewRect, mGridOuterLinePaint);
+        }
+    }
+
+    /**
+     * When image is laid out it must be centered properly to fit current crop bounds.
+     */
+    @Override
+    protected void onImageLaidOut() {
+        super.onImageLaidOut();
+        final Drawable drawable = getDrawable();
+        if (drawable == null) {
+            return;
+        }
+
+        float drawableWidth = drawable.getIntrinsicWidth();
+        float drawableHeight = drawable.getIntrinsicHeight();
+
+        if (mTargetAspectRatio == SOURCE_IMAGE_ASPECT_RATIO) {
+            mTargetAspectRatio = drawableWidth / drawableHeight;
+        }
+
+        setupCropBounds();
+        setupInitialImagePosition(drawableWidth, drawableHeight);
+        setImageMatrix(mCurrentImageMatrix);
+
+        if (mTransformImageListener != null) {
+            mTransformImageListener.onScale(getCurrentScale());
+            mTransformImageListener.onRotate(getCurrentAngle());
+        }
+    }
+
+    /**
+     * This method checks whether current image fills the crop bounds.
+     */
+    protected boolean isImageWrapCropBounds() {
+        return isImageWrapCropBounds(mCurrentImageCorners);
+    }
+
+    /**
+     * This methods checks whether a rectangle that is represented as 4 corner points (8 floats)
+     * fills the crop bounds rectangle.
+     *
+     * @param imageCorners - corners of a rectangle
+     * @return - true if it wraps crop bounds, false - otherwise
+     */
+    protected boolean isImageWrapCropBounds(float[] imageCorners) {
+        mTempMatrix.reset();
+        mTempMatrix.setRotate(-getCurrentAngle());
+
+        float[] unrotatedImageCorners = Arrays.copyOf(imageCorners, imageCorners.length);
+        mTempMatrix.mapPoints(unrotatedImageCorners);
+
+        float[] unrotatedCropBoundsCorners = RectUtils.getCornersFromRect(mCropRect);
+        mTempMatrix.mapPoints(unrotatedCropBoundsCorners);
+
+        return RectUtils.trapToRect(unrotatedImageCorners).contains(RectUtils.trapToRect(unrotatedCropBoundsCorners));
+    }
+
+    /**
+     * This method changes image scale (animating zoom for given duration), related to given center (x,y).
+     *
+     * @param scale      - target scale
+     * @param centerX    - scale center X
+     * @param centerY    - scale center Y
+     * @param durationMs - zoom animation duration
+     */
+    protected void zoomImageToPosition(float scale, float centerX, float centerY, long durationMs) {
+        if (scale > getMaxScale()) {
+            scale = getMaxScale();
+        }
+
+        final float oldScale = getCurrentScale();
+        final float deltaScale = scale - oldScale;
+
+        post(mZoomImageToPositionRunnable = new ZoomImageToPosition(CropImageView.this,
+                durationMs, oldScale, deltaScale, centerX, centerY));
+    }
+
+    /**
+     * This method calculates initial image position so it fits the crop bounds properly.
+     * Then it sets those values to the current image matrix.
+     *
+     * @param drawableWidth  - original image width
+     * @param drawableHeight - original image height
+     */
+    private void setupInitialImagePosition(float drawableWidth, float drawableHeight) {
+        float cropRectWidth = mCropRect.width();
+        float cropRectHeight = mCropRect.height();
+
+        float widthScale = cropRectWidth / drawableWidth;
+        float heightScale = cropRectHeight / drawableHeight;
+
+        mMinScale = Math.max(widthScale, heightScale);
+        mMaxScale = mMinScale * mMaxScaleMultiplier;
+
+        float tw = (cropRectWidth - drawableWidth * mMinScale) / 2.0f + mCropRect.left;
+        float th = (cropRectHeight - drawableHeight * mMinScale) / 2.0f + mCropRect.top;
+
+        mCurrentImageMatrix.reset();
+        mCurrentImageMatrix.postScale(mMinScale, mMinScale);
+        mCurrentImageMatrix.postTranslate(tw, th);
+    }
+
+    /**
+     * This method extracts all needed values from the styled attributes.
+     * Those are used to configure the view.
+     */
+    @SuppressWarnings("deprecation")
+    private void processStyledAttributes(@NonNull TypedArray a) {
+        float targetAspectRatioX = Math.abs(a.getFloat(R.styleable.ucrop_CropImageView_ucrop_aspect_ratio_x, DEFAULT_ASPECT_RATIO));
+        float targetAspectRatioY = Math.abs(a.getFloat(R.styleable.ucrop_CropImageView_ucrop_aspect_ratio_y, DEFAULT_ASPECT_RATIO));
+
+        if (targetAspectRatioX == SOURCE_IMAGE_ASPECT_RATIO || targetAspectRatioY == SOURCE_IMAGE_ASPECT_RATIO) {
+            mTargetAspectRatio = SOURCE_IMAGE_ASPECT_RATIO;
+        } else {
+            mTargetAspectRatio = targetAspectRatioX / targetAspectRatioY;
+        }
+
+        mMaxScaleMultiplier = a.getFloat(R.styleable.ucrop_CropImageView_ucrop_max_scale_multiplier, DEFAULT_MAX_SCALE_MULTIPLIER);
+
+        int overlayColor = a.getColor(R.styleable.ucrop_CropImageView_ucrop_overlay_color,
+                getResources().getColor(R.color.ucrop_color_default_overlay));
+        mDimmedPaint = new Paint();
+        mDimmedPaint.setColor(overlayColor);
+        mDimmedPaint.setStyle(Paint.Style.FILL);
+
+        initCropFrameStyle(a);
+        mShowCropFrame = a.getBoolean(R.styleable.ucrop_CropImageView_ucrop_show_frame, DEFAULT_SHOW_CROP_FRAME);
+
+        initCropGridStyle(a);
+        mShowCropGrid = a.getBoolean(R.styleable.ucrop_CropImageView_ucrop_show_grid, DEFAULT_SHOW_CROP_GRID);
+    }
+
+    /**
+     * This method setups Paint object for the crop bounds.
+     */
+    @SuppressWarnings("deprecation")
+    private void initCropFrameStyle(@NonNull TypedArray a) {
+        int cropFrameStrokeSize = a.getDimensionPixelSize(R.styleable.ucrop_CropImageView_ucrop_frame_stroke_size,
+                getResources().getDimensionPixelSize(R.dimen.ucrop_default_crop_frame_stoke_size));
+        int cropFrameColor = a.getColor(R.styleable.ucrop_CropImageView_ucrop_frame_color,
+                getResources().getColor(R.color.ucrop_color_default_crop_frame));
+        mGridOuterLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mGridOuterLinePaint.setStrokeWidth(cropFrameStrokeSize);
+        mGridOuterLinePaint.setColor(cropFrameColor);
+        mGridOuterLinePaint.setStyle(Paint.Style.STROKE);
+    }
+
+    /**
+     * This method setups Paint object for the crop guidelines.
+     */
+    @SuppressWarnings("deprecation")
+    private void initCropGridStyle(@NonNull TypedArray a) {
+        int cropGridStrokeSize = a.getDimensionPixelSize(R.styleable.ucrop_CropImageView_ucrop_grid_stroke_size,
+                getResources().getDimensionPixelSize(R.dimen.ucrop_default_crop_grid_stoke_size));
+        int cropGridColor = a.getColor(R.styleable.ucrop_CropImageView_ucrop_grid_color,
+                getResources().getColor(R.color.ucrop_color_default_crop_grid));
+        mGridInnerLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mGridInnerLinePaint.setStrokeWidth(cropGridStrokeSize);
+        mGridInnerLinePaint.setColor(cropGridColor);
+
+        mCropGridRowCount = a.getInt(R.styleable.ucrop_CropImageView_ucrop_grid_row_count, DEFAULT_CROP_GRID_ROW_COUNT);
+        mCropGridColumnCount = a.getInt(R.styleable.ucrop_CropImageView_ucrop_grid_column_count, DEFAULT_CROP_GRID_COLUMN_COUNT);
+    }
+
+    /**
+     * This method setups crop bounds rectangles for given aspect ratio and view size.
+     * {@link #mCropViewRect} is used to draw crop bounds - uses padding.
+     * {@link #mCropRect} is used for crop calculations - doesn't use padding.
+     */
+    private void setupCropBounds() {
+        int height = (int) (mThisWidth / mTargetAspectRatio);
+        if (height > mThisHeight) {
+            int width = (int) (mThisHeight * mTargetAspectRatio);
+            int halfDiff = (mThisWidth - width) / 2;
+            mCropRect.set(halfDiff, 0, width + halfDiff, mThisHeight);
+            mCropViewRect.set(getPaddingLeft() + halfDiff, getPaddingTop(),
+                    getPaddingLeft() + width + halfDiff, getPaddingTop() + mThisHeight);
+        } else {
+            int halfDiff = (mThisHeight - height) / 2;
+            mCropRect.set(0, halfDiff, mThisWidth, height + halfDiff);
+            mCropViewRect.set(getPaddingLeft(), getPaddingTop() + halfDiff,
+                    getPaddingLeft() + mThisWidth, getPaddingTop() + height + halfDiff);
+        }
+    }
+
+    /**
+     * This Runnable is used to animate an image so it fills the crop bounds entirely.
+     * Given values are interpolated during the animation time.
+     * Runnable can be terminated either vie {@link #cancelAllAnimations()} method
+     * or when certain conditions inside {@link WrapCropBoundsRunnable#run()} method are triggered.
+     */
+    private static class WrapCropBoundsRunnable implements Runnable {
+
+        private final WeakReference<CropImageView> mCropImageView;
+
+        private final long mDurationMs, mStartTime;
+        private final float mOldX, mOldY;
+        private final float mCenterDiffX, mCenterDiffY;
+        private final float mOldScale;
+        private final float mDeltaScale;
+        private final boolean mWillBeImageInBoundsAfterTranslate;
+
+        public WrapCropBoundsRunnable(CropImageView cropImageView,
+                                      long durationMs,
+                                      float oldX, float oldY,
+                                      float centerDiffX, float centerDiffY,
+                                      float oldScale, float deltaScale,
+                                      boolean willBeImageInBoundsAfterTranslate) {
+
+            mCropImageView = new WeakReference<>(cropImageView);
+
+            mDurationMs = durationMs;
+            mStartTime = System.currentTimeMillis();
+            mOldX = oldX;
+            mOldY = oldY;
+            mCenterDiffX = centerDiffX;
+            mCenterDiffY = centerDiffY;
+            mOldScale = oldScale;
+            mDeltaScale = deltaScale;
+            mWillBeImageInBoundsAfterTranslate = willBeImageInBoundsAfterTranslate;
+        }
+
+        @Override
+        public void run() {
+            CropImageView cropImageView = mCropImageView.get();
+            if (cropImageView == null) {
+                return;
+            }
+
+            long now = System.currentTimeMillis();
+            float currentMs = Math.min(mDurationMs, now - mStartTime);
+
+            float newX = CubicEasing.easeOut(currentMs, 0, mCenterDiffX, mDurationMs);
+            float newY = CubicEasing.easeOut(currentMs, 0, mCenterDiffY, mDurationMs);
+            float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs);
+
+            if (currentMs < mDurationMs) {
+                cropImageView.postTranslate(newX - (cropImageView.mCurrentImageCenter[0] - mOldX), newY - (cropImageView.mCurrentImageCenter[1] - mOldY));
+                if (!mWillBeImageInBoundsAfterTranslate) {
+                    cropImageView.zoomInImage(mOldScale + newScale, cropImageView.mCropRect.centerX(), cropImageView.mCropRect.centerY());
+                }
+                if (!cropImageView.isImageWrapCropBounds()) {
+                    cropImageView.post(this);
+                }
+            }
+        }
+    }
+
+    /**
+     * This Runnable is used to animate an image zoom.
+     * Given values are interpolated during the animation time.
+     * Runnable can be terminated either vie {@link #cancelAllAnimations()} method
+     * or when certain conditions inside {@link ZoomImageToPosition#run()} method are triggered.
+     */
+    private static class ZoomImageToPosition implements Runnable {
+
+        private final WeakReference<CropImageView> mCropImageView;
+
+        private final long mDurationMs, mStartTime;
+        private final float mOldScale;
+        private final float mDeltaScale;
+        private final float mDestX;
+        private final float mDestY;
+
+        public ZoomImageToPosition(CropImageView cropImageView,
+                                   long durationMs,
+                                   float oldScale, float deltaScale,
+                                   float destX, float destY) {
+
+            mCropImageView = new WeakReference<>(cropImageView);
+
+            mStartTime = System.currentTimeMillis();
+            mDurationMs = durationMs;
+            mOldScale = oldScale;
+            mDeltaScale = deltaScale;
+            mDestX = destX;
+            mDestY = destY;
+        }
+
+        @Override
+        public void run() {
+            CropImageView cropImageView = mCropImageView.get();
+            if (cropImageView == null) {
+                return;
+            }
+
+            long now = System.currentTimeMillis();
+            float currentMs = Math.min(mDurationMs, now - mStartTime);
+            float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs);
+
+            if (currentMs < mDurationMs) {
+                cropImageView.zoomInImage(mOldScale + newScale, mDestX, mDestY);
+                cropImageView.post(this);
+            } else {
+                cropImageView.setImageToWrapCropBounds();
+            }
+        }
+
+    }
+
+}
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/RotateBitmap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/RotateBitmap.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/RotateBitmap.java	(revision )
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.chooseimagelib.simplecropimage;
+
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+
+public class RotateBitmap {
+
+    public static final String TAG = "RotateBitmap";
+    private Bitmap mBitmap;
+    private int    mRotation;
+
+    public RotateBitmap(Bitmap bitmap) {
+
+        mBitmap = bitmap;
+        mRotation = 0;
+    }
+
+    public RotateBitmap(Bitmap bitmap, int rotation) {
+
+        mBitmap = bitmap;
+        mRotation = rotation % 360;
+    }
+
+    public void setRotation(int rotation) {
+
+        mRotation = rotation;
+    }
+
+    public int getRotation() {
+
+        return mRotation;
+    }
+
+    public Bitmap getBitmap() {
+
+        return mBitmap;
+    }
+
+    public void setBitmap(Bitmap bitmap) {
+
+        mBitmap = bitmap;
+    }
+
+    public Matrix getRotateMatrix() {
+        // By default this is an identity matrix.
+        Matrix matrix = new Matrix();
+        if (mRotation != 0) {
+            // We want to do the rotation at origin, but since the bounding
+            // rectangle will be changed after rotation, so the delta values
+            // are based on old & new width/height respectively.
+            int cx = mBitmap.getWidth() / 2;
+            int cy = mBitmap.getHeight() / 2;
+            matrix.preTranslate(-cx, -cy);
+            matrix.postRotate(mRotation);
+            matrix.postTranslate(getWidth() / 2, getHeight() / 2);
+        }
+        return matrix;
+    }
+
+    public boolean isOrientationChanged() {
+
+        return (mRotation / 90) % 2 != 0;
+    }
+
+    public int getHeight() {
+
+        if (isOrientationChanged()) {
+            return mBitmap.getWidth();
+        } else {
+            return mBitmap.getHeight();
+        }
+    }
+
+    public int getWidth() {
+
+        if (isOrientationChanged()) {
+            return mBitmap.getHeight();
+        } else {
+            return mBitmap.getWidth();
+        }
+    }
+
+    public void recycle() {
+
+        if (mBitmap != null) {
+            mBitmap.recycle();
+            mBitmap = null;
+        }
+    }
+}
+
Index: customfresco/src/main/java/com/scene/customfresco/custom/CustomProgressBar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/custom/CustomProgressBar.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/custom/CustomProgressBar.java	(revision )
@@ -0,0 +1,107 @@
+package com.scene.customfresco.custom;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+
+import com.facebook.drawee.drawable.DrawableUtils;
+
+public class CustomProgressBar extends Drawable {
+
+    private Paint mRingBackgroundPaint;
+    private int mRingBackgroundColor;
+    // 画圆环的画笔
+    private Paint mRingPaint;
+    // 圆环颜色
+    private int mRingColor;
+    // 半径
+    private float mRadius;
+    // 圆环半径
+    private float mRingRadius;
+    // 圆环宽度
+    private float mStrokeWidth;
+    // 圆心x坐标
+    private int mXCenter;
+    // 圆心y坐标
+    private int mYCenter;
+    // 总进度
+    private int mTotalProgress = 10000;
+    // 当前进度
+    private int mProgress;
+
+    public CustomProgressBar() {
+        initAttrs();
+    }
+
+    private void initAttrs() {
+        mRadius = 40;
+        mStrokeWidth = 4;
+        mRingBackgroundColor = 0xFFadadad;
+        mRingColor = 0xFF0EB6D2;
+        mRingRadius = mRadius + mStrokeWidth / 2;
+        initVariable();
+    }
+
+    private void initVariable() {
+        mRingBackgroundPaint = new Paint();
+        mRingBackgroundPaint.setAntiAlias(true);
+        mRingBackgroundPaint.setColor(mRingBackgroundColor);
+        mRingBackgroundPaint.setStyle(Paint.Style.STROKE);
+        mRingBackgroundPaint.setStrokeWidth(mStrokeWidth);
+
+        mRingPaint = new Paint();
+        mRingPaint.setAntiAlias(true);
+        mRingPaint.setColor(mRingColor);
+        mRingPaint.setStyle(Paint.Style.STROKE);
+        mRingPaint.setStrokeWidth(mStrokeWidth);
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        drawBar(canvas, mTotalProgress, mRingBackgroundPaint);
+        drawBar(canvas, mProgress, mRingPaint);
+    }
+
+    private void drawBar(Canvas canvas, int level, Paint paint) {
+        if (level > 0) {
+            Rect bound = getBounds();
+            mXCenter = bound.centerX();
+            mYCenter = bound.centerY();
+            RectF oval = new RectF();
+            oval.left = (mXCenter - mRingRadius);
+            oval.top = (mYCenter - mRingRadius);
+            oval.right = mRingRadius * 2 + (mXCenter - mRingRadius);
+            oval.bottom = mRingRadius * 2 + (mYCenter - mRingRadius);
+            canvas.drawArc(oval, -90, ((float) level / mTotalProgress) * 360, false, paint);
+        }
+    }
+
+    @Override
+    protected boolean onLevelChange(int level) {
+        mProgress = level;
+        if (level > 0 && level < 10000) {
+            invalidateSelf();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mRingPaint.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mRingPaint.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return DrawableUtils.getOpacityFromColor(this.mRingPaint.getColor());
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/ShellUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/ShellUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/ShellUtil.java	(revision )
@@ -0,0 +1,137 @@
+package com.scene.common.common.utils;
+
+import java.io.BufferedReader;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.List;
+
+/**
+ * modified form Trinea
+ *  @author trinea
+ * @date 2014-12-10
+ */
+public class ShellUtil {
+
+    /**
+     * check whether has root permission
+     */
+    public static boolean hasRootPermission() {
+        return execCommand("echo root", true, false).result == 0;
+    }
+
+    public static CommandResult execCommand(String command, boolean isRoot) {
+        return execCommand(new String[] {command}, isRoot, true);
+    }
+
+    public static CommandResult execCommand(String command, boolean isRoot, boolean isNeedResultMsg) {
+        return execCommand(new String[]{command}, isRoot, isNeedResultMsg);
+    }
+
+    public static CommandResult execCommand(List<String> commands, boolean isRoot, boolean isNeedResultMsg) {
+        return execCommand(commands == null ? null : commands.toArray(new String[]{}), isRoot, isNeedResultMsg);
+    }
+
+    /**
+     * execute shell commands
+     * {@link CommandResult#result} is -1, there maybe some excepiton.
+     *
+     * @param commands     command array
+     * @param isRoot       whether need to run with root
+     * @param needResponse whether need result msg
+     */
+    public static CommandResult execCommand(String[] commands, boolean isRoot, boolean needResponse) {
+        int result = -1;
+        if (commands == null || commands.length == 0) {
+            return new CommandResult(result, null, "空命令");
+        }
+
+        Process process = null;
+        BufferedReader successResult = null;
+        BufferedReader errorResult = null;
+        StringBuilder successMsg = null;
+        StringBuilder errorMsg = null;
+
+        DataOutputStream os = null;
+        try {
+            process = Runtime.getRuntime().exec(isRoot ? COMMAND_SU : COMMAND_SH);
+            os = new DataOutputStream(process.getOutputStream());
+            for (String command : commands) {
+                if (command == null) {
+                    continue;
+                }
+
+                // donnot use os.writeBytes(commmand), avoid chinese charset error
+                os.write(command.getBytes());
+                os.writeBytes(COMMAND_LINE_END);
+                os.flush();
+            }
+            os.writeBytes(COMMAND_EXIT);
+            os.flush();
+
+            result = process.waitFor();
+            if (needResponse) {
+                successMsg = new StringBuilder();
+                errorMsg = new StringBuilder();
+                successResult = new BufferedReader(new InputStreamReader(process.getInputStream()));
+                errorResult = new BufferedReader(new InputStreamReader(process.getErrorStream()));
+                String s;
+                while ((s = successResult.readLine()) != null) {
+                    successMsg.append(s);
+                }
+                while ((s = errorResult.readLine()) != null) {
+                    errorMsg.append(s);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                if (errorResult != null) {
+                    errorResult.close();
+                }
+                if (successResult != null) {
+                    successResult.close();
+                }
+                if (os != null) {
+                    os.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            } finally {
+                if (process != null) {
+                    process.destroy();
+                }
+            }
+
+        }
+        return new CommandResult(result, successMsg == null ? null : successMsg.toString(), errorMsg == null ? null
+                : errorMsg.toString());
+    }
+
+    public static class CommandResult {
+
+        public int    result;
+        public String responseMsg;
+        public String errorMsg;
+
+        public CommandResult(int result) {
+            this.result = result;
+        }
+
+        public CommandResult(int result, String responseMsg, String errorMsg) {
+            this.result = result;
+            this.responseMsg = responseMsg;
+            this.errorMsg = errorMsg;
+        }
+    }
+
+    public static final String COMMAND_SU       = "su";
+    public static final String COMMAND_SH       = "sh";
+    public static final String COMMAND_EXIT     = "exit\n";
+    public static final String COMMAND_LINE_END = "\n";
+
+
+}
Index: mylib/src/main/res/drawable/apsts_tips.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/drawable/apsts_tips.xml	(revision )
+++ mylib/src/main/res/drawable/apsts_tips.xml	(revision )
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <!--<solid android:color="@color/red" />-->
+    <padding
+        android:left="4dp"
+        android:right="4dp"/>
+    <corners
+        android:radius="360dp"
+        />
+    <solid
+        android:color="#E43F3E" />
+    <!--<stroke-->
+        <!--android:width="1dp"-->
+        <!--android:color="@android:color/white" />-->
+    <!--<size android:width="15dp"-->
+        <!--android:height="15dp" />-->
+</shape>
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/PermissionConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/PermissionConfig.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/PermissionConfig.java	(revision )
@@ -0,0 +1,14 @@
+package com.scene.sceneandroiddemo;
+
+/**
+ * Created by Administrator on 16/01/27.
+ */
+public class PermissionConfig {
+    //相机权限
+    public static final int RC_CAMERA_PERM = 101;
+    public static final int RC_Storage_PERM = 102;
+    //权限type暂定3个如果不过可以自己加
+    public static final int TYPE_PERMISSION_1 = 20001;
+    public static final int TYPE_PERMISSION_2 = 20002;
+    public static final int TYPE_PERMISSION_3 = 20003;
+}
Index: common/src/main/java/com/scene/common/common/receiver/PhoneReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/receiver/PhoneReceiver.java	(revision )
+++ common/src/main/java/com/scene/common/common/receiver/PhoneReceiver.java	(revision )
@@ -0,0 +1,152 @@
+package com.scene.common.common.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import com.scene.common.android.log.Log;
+import com.scene.common.common.assist.Check;
+
+/**
+ * <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
+ * <uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" />
+ * <p/>
+ * action: android.intent.action.PHONE_STATE;  android.intent.action.NEW_OUTGOING_CALL;
+ * <p/>
+ * 去电时：
+ * 未接：phone_state=OFFHOOK;
+ * 挂断：phone_state=IDLE
+ * 来电时:
+ * 未接：phone_state=RINGING
+ * 已接：phone_state=OFFHOOK;
+ * 挂断：phone_state=IDLE
+ *
+ * @author MaTianyu
+ * @date 2015-03-09
+ */
+public class PhoneReceiver extends BroadcastReceiver {
+
+    private static final String TAG = "PhoneReceiver";
+
+    private static final String RINGING = "RINGING";
+    private static final String OFFHOOK = "OFFHOOK";
+    private static final String IDLE = "IDLE";
+
+    private static final String PHONE_STATE = "android.intent.action.PHONE_STATE";
+    private static final String NEW_OUTGOING_CALL = "android.intent.action.NEW_OUTGOING_CALL";
+    private static final String INTENT_STATE = "state";
+    private static final String INTENT_INCOMING_NUMBER = "incoming_number";
+    private PhoneListener phoneListener;
+    private boolean isDialOut;
+    private String number;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (Log.isPrint) {
+            Log.i(TAG, "action: " + intent.getAction());
+            Log.d(TAG, "intent : ");
+            Bundle bundle = intent.getExtras();
+            for (String key : bundle.keySet()) {
+                Log.d(TAG, key + " : " + bundle.get(key));
+            }
+        }
+        if (NEW_OUTGOING_CALL.equals(intent.getAction())) {
+            isDialOut = true;
+            String outNumber = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+            if (!Check.isEmpty(outNumber)) {
+                this.number = outNumber;
+            }
+            if (phoneListener != null) {
+                phoneListener.onPhoneStateChanged(CallState.Outgoing, number);
+            }
+        } else if (PHONE_STATE.equals(intent.getAction())) {
+            String state = intent.getStringExtra(INTENT_STATE);
+            String inNumber = intent.getStringExtra(INTENT_INCOMING_NUMBER);
+            if (!Check.isEmpty(inNumber)) {
+                this.number = inNumber;
+            }
+            if (RINGING.equals(state)) {
+                isDialOut = false;
+                if (phoneListener != null) {
+                    phoneListener.onPhoneStateChanged(CallState.IncomingRing, number);
+                }
+            } else if (OFFHOOK.equals(state)) {
+                if (!isDialOut && phoneListener != null) {
+                    phoneListener.onPhoneStateChanged(CallState.Incoming, number);
+                }
+            } else if (IDLE.equals(state)) {
+                if (isDialOut) {
+                    if (phoneListener != null) {
+                        phoneListener.onPhoneStateChanged(CallState.OutgoingEnd, number);
+                    }
+                } else {
+                    if (phoneListener != null) {
+                        phoneListener.onPhoneStateChanged(CallState.IncomingEnd, number);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * 去电时：
+     * 未接：phone_state=OFFHOOK;
+     * 挂断：phone_state=IDLE
+     * 来电时:
+     * 未接：phone_state=RINGING
+     * 已接：phone_state=OFFHOOK;
+     * 挂断：phone_state=IDLE
+     */
+    //public void registerCallStateListener(Context context, PhoneStateListener listener) {
+    //    try {
+    //        //获取电话通讯服务
+    //        TelephonyManager tpm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+    //        tpm.listen(listener, PhoneStateListener.LISTEN_CALL_STATE);
+    //    } catch (Exception e) {
+    //        e.printStackTrace();
+    //    }
+    //}
+    public void registerReceiver(Context context, PhoneListener phoneListener) {
+        try {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction("android.intent.action.PHONE_STATE");
+            filter.addAction("android.intent.action.NEW_OUTGOING_CALL");
+            filter.setPriority(Integer.MAX_VALUE);
+            context.registerReceiver(this, filter);
+            this.phoneListener = phoneListener;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void unRegisterReceiver(Context context) {
+        try {
+            context.unregisterReceiver(this);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public interface PhoneListener {
+        void onPhoneStateChanged(CallState state, String number);
+    }
+
+    /**
+     * 分别是：
+     * <p/>
+     * 播出电话
+     * 播出电话结束
+     * 接入电话铃响
+     * 接入通话中
+     * 接入通话完毕
+     */
+    public enum CallState {
+        Outgoing,
+        OutgoingEnd,
+        IncomingRing,
+        Incoming,
+        IncomingEnd
+    }
+
+}
Index: common/src/main/java/com/scene/common/common/data/DataKeeper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/data/DataKeeper.java	(revision )
+++ common/src/main/java/com/scene/common/common/data/DataKeeper.java	(revision )
@@ -0,0 +1,113 @@
+package com.scene.common.common.data;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import com.scene.common.android.log.Log;
+import com.scene.common.common.data.cipher.Cipher;
+import com.scene.common.common.utils.ByteUtil;
+import com.scene.common.common.utils.HexUtil;
+
+/**
+ * @author MaTianyu
+ * @date 14-7-10
+ */
+public class DataKeeper {
+    private SharedPreferences sp;
+    public static final  String KEY_PK_HOME = "msg_pk_home";
+    public static final  String KEY_PK_NEW  = "msg_pk_new";
+    private static final String TAG         = DataKeeper.class.getSimpleName();
+
+    public DataKeeper(Context context, String fileName) {
+        sp = context.getSharedPreferences(fileName, Context.MODE_PRIVATE);
+    }
+
+    /**
+     * *************** get ******************
+     */
+
+    public String get(String key, String defValue) {
+        return sp.getString(key, defValue);
+    }
+
+    public boolean get(String key, boolean defValue) {
+        return sp.getBoolean(key, defValue);
+    }
+
+    public float get(String key, float defValue) {
+        return sp.getFloat(key, defValue);
+    }
+
+    public int getInt(String key, int defValue) {
+        return sp.getInt(key, defValue);
+    }
+
+    public long get(String key, long defValue) {
+        return sp.getLong(key, defValue);
+    }
+
+    public Object get(String key) {
+        return get(key, (Cipher) null);
+    }
+
+    public Object get(String key, Cipher cipher) {
+        try {
+            String hex = get(key, (String) null);
+            if (hex == null) return null;
+            byte[] bytes = HexUtil.decodeHex(hex.toCharArray());
+            if (cipher != null) bytes = cipher.decrypt(bytes);
+            Object obj = ByteUtil.byteToObject(bytes);
+            Log.i(TAG, key + " get: " + obj);
+            return obj;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    /**
+     * *************** put ******************
+     */
+    public void put(String key, Object ser) {
+        put(key, ser, null);
+    }
+
+    public void put(String key, Object ser, Cipher cipher) {
+        try {
+            Log.i(TAG, key + " put: " + ser);
+            if (ser == null) {
+                sp.edit().remove(key).commit();
+            } else {
+                byte[] bytes = ByteUtil.objectToByte(ser);
+                if (cipher != null) bytes = cipher.encrypt(bytes);
+                put(key, HexUtil.encodeHexStr(bytes));
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void put(String key, String value) {
+        if (value == null) {
+            sp.edit().remove(key).commit();
+        } else {
+            sp.edit().putString(key, value).commit();
+        }
+    }
+
+    public void put(String key, boolean value) {
+        sp.edit().putBoolean(key, value).commit();
+    }
+
+    public void put(String key, float value) {
+        sp.edit().putFloat(key, value).commit();
+    }
+
+    public void put(String key, long value) {
+        sp.edit().putLong(key, value).commit();
+    }
+
+    public void putInt(String key, int value) {
+        sp.edit().putInt(key, value).commit();
+    }
+
+}
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/HeaderSpanSizeLookup.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/HeaderSpanSizeLookup.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/HeaderSpanSizeLookup.java	(revision )
@@ -0,0 +1,25 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.support.v7.widget.GridLayoutManager;
+
+/**
+ * Created by scene on 2015/10/23.
+ * <p/>
+ * RecyclerView为GridLayoutManager时，设置了HeaderView，就会用到这个SpanSizeLookup
+ */
+public class HeaderSpanSizeLookup extends GridLayoutManager.SpanSizeLookup {
+
+    private HeaderAndFooterRecyclerViewAdapter adapter;
+    private int mSpanSize = 1;
+
+    public HeaderSpanSizeLookup(HeaderAndFooterRecyclerViewAdapter adapter, int spanSize) {
+        this.adapter = adapter;
+        this.mSpanSize = spanSize;
+    }
+
+    @Override
+    public int getSpanSize(int position) {
+        boolean isHeaderOrFooter = adapter.isHeader(position) || adapter.isFooter(position);
+        return isHeaderOrFooter ? mSpanSize : 1;
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/ClassUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/ClassUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/ClassUtil.java	(revision )
@@ -0,0 +1,71 @@
+package com.scene.common.common.utils;
+
+import java.lang.reflect.Constructor;
+import java.util.Collection;
+import java.util.Date;
+
+/**
+ * 类工具
+ * 
+ * @author mty
+ * @date 2013-6-10下午8:00:46
+ */
+public class ClassUtil {
+
+	/**
+	 * 判断类是否是基础数据类型
+	 * 目前支持11种
+	 *
+	 * @param clazz
+	 * @return
+	 */
+	public static boolean isBaseDataType(Class<?> clazz) {
+		return clazz.isPrimitive() || clazz.equals(String.class) || clazz.equals(Boolean.class)
+				|| clazz.equals(Integer.class) || clazz.equals(Long.class) || clazz.equals(Float.class)
+				|| clazz.equals(Double.class) || clazz.equals(Byte.class) || clazz.equals(Character.class)
+				|| clazz.equals(Short.class) || clazz.equals(Date.class) || clazz.equals(byte[].class)
+				|| clazz.equals(Byte[].class);
+	}
+
+    /**
+     * 根据类获取对象：不再必须一个无参构造
+     *
+     * @param claxx
+     * @return
+     * @throws Exception
+     */
+    public static <T> T newInstance(Class<T> claxx) throws Exception {
+        Constructor<?>[] cons = claxx.getDeclaredConstructors();
+        for (Constructor<?> c : cons) {
+            Class[] cls = c.getParameterTypes();
+            if (cls.length == 0) {
+                c.setAccessible(true);
+                return (T) c.newInstance();
+            } else {
+                Object[] objs = new Object[cls.length];
+                for (int i = 0; i < cls.length; i++) {
+                    objs[i] = getDefaultPrimiticeValue(cls[i]);
+                }
+                c.setAccessible(true);
+                return (T) c.newInstance(objs);
+            }
+        }
+        return null;
+    }
+
+    public static Object getDefaultPrimiticeValue(Class clazz) {
+        if (clazz.isPrimitive()) {
+            return clazz == boolean.class ? false : 0;
+        }
+        return null;
+    }
+
+    public static boolean isCollection(Class claxx) {
+        return Collection.class.isAssignableFrom(claxx);
+    }
+
+    public static boolean isArray(Class claxx) {
+        return claxx.isArray();
+    }
+
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/view/TransformImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/view/TransformImageView.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/view/TransformImageView.java	(revision )
@@ -0,0 +1,321 @@
+package com.yalantis.ucrop.view;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.graphics.Point;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.Display;
+import android.view.WindowManager;
+import android.widget.ImageView;
+
+import com.yalantis.ucrop.util.BitmapLoadUtils;
+import com.yalantis.ucrop.util.FastBitmapDrawable;
+import com.yalantis.ucrop.util.RectUtils;
+
+/**
+ * Created by Oleksii Shliama (https://github.com/shliama).
+ * <p/>
+ * This class provides base logic to setup the image, transform it with matrix (move, scale, rotate),
+ * and methods to get current matrix state.
+ */
+public class TransformImageView extends ImageView {
+
+    private static final String TAG = "TransformImageView";
+
+    private static final int RECT_CORNER_POINTS_COORDS = 8;
+    private static final int RECT_CENTER_POINT_COORDS = 2;
+    private static final int MATRIX_VALUES_COUNT = 9;
+
+    protected final float[] mCurrentImageCorners = new float[RECT_CORNER_POINTS_COORDS];
+    protected final float[] mCurrentImageCenter = new float[RECT_CENTER_POINT_COORDS];
+
+    private final float[] mMatrixValues = new float[MATRIX_VALUES_COUNT];
+
+    protected Matrix mCurrentImageMatrix = new Matrix();
+    protected int mThisWidth, mThisHeight;
+
+    protected TransformImageListener mTransformImageListener;
+
+    private float[] mInitialImageCorners;
+    private float[] mInitialImageCenter;
+
+    private int mMaxBitmapSize = 0;
+    private Uri mImageUri;
+
+    public TransformImageView(Context context) {
+        this(context, null);
+    }
+
+    public TransformImageView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public TransformImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context, attrs, defStyle);
+    }
+
+    public void setTransformImageListener(TransformImageListener transformImageListener) {
+        mTransformImageListener = transformImageListener;
+    }
+
+    @Override
+    public void setScaleType(ScaleType scaleType) {
+        if (scaleType == ScaleType.MATRIX) {
+            super.setScaleType(scaleType);
+        } else {
+            Log.w(TAG, "Invalid ScaleType. Only ScaleType.MATRIX can be used");
+        }
+    }
+
+    /**
+     * Setter for {@link #mMaxBitmapSize} value.
+     * Be sure to call it before {@link #setImageURI(Uri)} or other image setters.
+     *
+     * @param maxBitmapSize - max size for both width and height of bitmap that will be used in the view.
+     */
+    public void setMaxBitmapSize(int maxBitmapSize) {
+        mMaxBitmapSize = maxBitmapSize;
+    }
+
+    public int getMaxBitmapSize() {
+        if (mMaxBitmapSize <= 0) {
+            mMaxBitmapSize = calculateMaxBitmapSize();
+        }
+        return mMaxBitmapSize;
+    }
+
+    @Override
+    public void setImageBitmap(final Bitmap bitmap) {
+        setImageDrawable(new FastBitmapDrawable(bitmap));
+    }
+
+    @Nullable
+    public Uri getImageUri() {
+        return mImageUri;
+    }
+
+    /**
+     * This method takes an Uri as a parameter, then calls method to decode it into Bitmap with specified size.
+     *
+     * @param imageUri - image Uri
+     * @throws Exception - can throw exception if having problems with decoding Uri or OOM.
+     */
+    public void setImageUri(@NonNull Uri imageUri) throws Exception {
+        mImageUri = imageUri;
+        int maxBitmapSize = getMaxBitmapSize();
+        setImageBitmap(BitmapLoadUtils.decode(getContext(), imageUri, maxBitmapSize, maxBitmapSize));
+    }
+
+    /**
+     * @return - current image scale value.
+     * [1.0f - for original image, 2.0f - for 200% scaled image, etc.]
+     */
+    public float getCurrentScale() {
+        return getMatrixScale(mCurrentImageMatrix);
+    }
+
+    /**
+     * This method calculates scale value for given Matrix object.
+     */
+    public float getMatrixScale(@NonNull Matrix matrix) {
+        return (float) Math.sqrt(Math.pow(getMatrixValue(matrix, Matrix.MSCALE_X), 2)
+                + Math.pow(getMatrixValue(matrix, Matrix.MSKEW_Y), 2));
+    }
+
+    /**
+     * @return - current image rotation angle.
+     */
+    public float getCurrentAngle() {
+        return getMatrixAngle(mCurrentImageMatrix);
+    }
+
+    /**
+     * This method calculates rotation angle for given Matrix object.
+     */
+    public float getMatrixAngle(@NonNull Matrix matrix) {
+        return (float) -(Math.atan2(getMatrixValue(matrix, Matrix.MSKEW_X),
+                getMatrixValue(matrix, Matrix.MSCALE_X)) * (180 / Math.PI));
+    }
+
+    @Override
+    public void setImageMatrix(Matrix matrix) {
+        super.setImageMatrix(matrix);
+        updateCurrentImagePoints();
+    }
+
+    @Nullable
+    public Bitmap getViewBitmap() {
+        if (getDrawable() == null || !(getDrawable() instanceof FastBitmapDrawable)) {
+            return null;
+        } else {
+            return ((FastBitmapDrawable) getDrawable()).getBitmap();
+        }
+    }
+
+    /**
+     * This method translates current image.
+     *
+     * @param deltaX - horizontal shift
+     * @param deltaY - vertical shift
+     */
+    public void postTranslate(float deltaX, float deltaY) {
+        if (deltaX != 0 || deltaY != 0) {
+            mCurrentImageMatrix.postTranslate(deltaX, deltaY);
+            setImageMatrix(mCurrentImageMatrix);
+        }
+    }
+
+    /**
+     * This method scales current image.
+     *
+     * @param deltaScale - scale value
+     * @param px         - scale center X
+     * @param py         - scale center Y
+     */
+    public void postScale(float deltaScale, float px, float py) {
+        if (deltaScale != 0) {
+            mCurrentImageMatrix.postScale(deltaScale, deltaScale, px, py);
+            setImageMatrix(mCurrentImageMatrix);
+            if (mTransformImageListener != null) {
+                mTransformImageListener.onScale(getMatrixScale(mCurrentImageMatrix));
+            }
+        }
+    }
+
+    /**
+     * This method rotates current image.
+     *
+     * @param deltaAngle - rotation angle
+     * @param px         - rotation center X
+     * @param py         - rotation center Y
+     */
+    public void postRotate(float deltaAngle, float px, float py) {
+        if (deltaAngle != 0) {
+            mCurrentImageMatrix.postRotate(deltaAngle, px, py);
+            setImageMatrix(mCurrentImageMatrix);
+            if (mTransformImageListener != null) {
+                mTransformImageListener.onRotate(getMatrixAngle(mCurrentImageMatrix));
+            }
+        }
+    }
+
+    protected void init(Context context, AttributeSet attrs, int defStyle) {
+        setScaleType(ScaleType.MATRIX);
+    }
+
+    /**
+     * This method calculates maximum size of both width and height of bitmap.
+     * It is the device screen diagonal for default implementation.
+     *
+     * @return - max bitmap size in pixels.
+     */
+    @SuppressWarnings({"SuspiciousNameCombination", "deprecation"})
+    protected int calculateMaxBitmapSize() {
+        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+
+        Point size = new Point();
+        int width, height;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            display.getSize(size);
+            width = size.x;
+            height = size.y;
+        } else {
+            width = display.getWidth();
+            height = display.getHeight();
+        }
+        return (int) Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        if (changed) {
+            left = getPaddingLeft();
+            top = getPaddingTop();
+            right = getWidth() - getPaddingRight();
+            bottom = getHeight() - getPaddingBottom();
+            mThisWidth = right - left;
+            mThisHeight = bottom - top;
+
+            onImageLaidOut();
+        }
+    }
+
+    /**
+     * When image is laid out {@link #mInitialImageCenter} and {@link #mInitialImageCenter}
+     * must be set.
+     */
+    protected void onImageLaidOut() {
+        final Drawable drawable = getDrawable();
+        if (drawable == null) {
+            return;
+        }
+
+        float w = drawable.getIntrinsicWidth();
+        float h = drawable.getIntrinsicHeight();
+
+        Log.d(TAG, String.format("Image size: [%d:%d]", (int) w, (int) h));
+
+        RectF initialImageRect = new RectF(0, 0, w, h);
+        mInitialImageCorners = RectUtils.getCornersFromRect(initialImageRect);
+        mInitialImageCenter = RectUtils.getCenterFromRect(initialImageRect);
+    }
+
+    /**
+     * This method returns Matrix value for given index.
+     *
+     * @param matrix     - valid Matrix object
+     * @param valueIndex - index of needed value. See {@link Matrix#MSCALE_X} and others.
+     * @return - matrix value for index
+     */
+    protected float getMatrixValue(@NonNull Matrix matrix, @IntRange(from = 0, to = MATRIX_VALUES_COUNT) int valueIndex) {
+        matrix.getValues(mMatrixValues);
+        return mMatrixValues[valueIndex];
+    }
+
+    /**
+     * This method logs given matrix X, Y, scale, and angle values.
+     * Can be used for debug.
+     */
+    @SuppressWarnings("unused")
+    protected void printMatrix(@NonNull String logPrefix, @NonNull Matrix matrix) {
+        float x = getMatrixValue(matrix, Matrix.MTRANS_X);
+        float y = getMatrixValue(matrix, Matrix.MTRANS_Y);
+        float rScale = getMatrixScale(matrix);
+        float rAngle = getMatrixAngle(matrix);
+        Log.d(TAG, logPrefix + ": matrix: { x: " + x + ", y: " + y + ", scale: " + rScale + ", angle: " + rAngle + " }");
+    }
+
+    /**
+     * This method updates current image corners and center points that are stored in
+     * {@link #mCurrentImageCorners} and {@link #mCurrentImageCenter} arrays.
+     * Those are used for several calculations.
+     */
+    private void updateCurrentImagePoints() {
+        mCurrentImageMatrix.mapPoints(mCurrentImageCorners, mInitialImageCorners);
+        mCurrentImageMatrix.mapPoints(mCurrentImageCenter, mInitialImageCenter);
+    }
+
+    /**
+     * Interface for rotation and scale change notifying.
+     */
+    public interface TransformImageListener {
+
+        void onRotate(float currentAngle);
+
+        void onScale(float currentScale);
+
+    }
+
+}
Index: common/src/main/java/com/scene/common/common/data/cipher/Encrypt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/data/cipher/Encrypt.java	(revision )
+++ common/src/main/java/com/scene/common/common/data/cipher/Encrypt.java	(revision )
@@ -0,0 +1,9 @@
+package com.scene.common.common.data.cipher;
+
+/**
+ * @author MaTianyu
+ * @date 14-7-31
+ */
+public interface Encrypt {
+    public byte[] encrypt(byte[] res);
+}
Index: common/src/main/java/com/scene/common/common/utils/PollingUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/PollingUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/PollingUtil.java	(revision )
@@ -0,0 +1,59 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.os.SystemClock;
+
+/**
+ * @author MaTianyu
+ * @date 2015-03-26
+ */
+public class PollingUtil {
+
+    /**
+     * 开启轮询
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void startPolling(Context context, int mills, PendingIntent pendingIntent) {
+        AlarmManager manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+        manager.setRepeating(AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime(),
+                mills, pendingIntent);
+    }
+
+    /**
+     * 停止轮询
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void stopPolling(Context context, PendingIntent pendingIntent) {
+        AlarmManager manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+        manager.cancel(pendingIntent);
+    }
+
+    /**
+     * 开启轮询服务
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void startPollingService(Context context, int mills, Class<?> cls, String action) {
+        Intent intent = new Intent(context, cls);
+        intent.setAction(action);
+        PendingIntent pendingIntent = PendingIntent.getService(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        startPolling(context, mills, pendingIntent);
+    }
+
+    /**
+     * 停止启轮询服务
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void stopPollingService(Context context, Class<?> cls, String action) {
+        Intent intent = new Intent(context, cls);
+        intent.setAction(action);
+        PendingIntent pendingIntent = PendingIntent.getService(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        stopPolling(context, pendingIntent);
+    }
+
+
+}
Index: common/src/main/java/com/scene/common/common/assist/Toastor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/Toastor.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/Toastor.java	(revision )
@@ -0,0 +1,105 @@
+package com.scene.common.common.assist;
+
+import android.content.Context;
+import android.widget.Toast;
+
+/**
+ * @author MaTianyu
+ * @date 2014-07-31
+ */
+public class Toastor {
+
+    private Toast   mToast;
+    private Context context;
+
+    public Toastor(Context context) {
+        this.context = context.getApplicationContext();
+    }
+
+    public Toast getSingletonToast(int resId) {
+        if (mToast == null) {
+            mToast = Toast.makeText(context, resId, Toast.LENGTH_SHORT);
+        }else{
+            mToast.setText(resId);
+        }
+        return mToast;
+    }
+
+    public Toast getSingletonToast(String text) {
+        if (mToast == null) {
+            mToast = Toast.makeText(context, text, Toast.LENGTH_SHORT);
+        }else{
+            mToast.setText(text);
+        }
+        return mToast;
+    }
+
+    public Toast getSingleLongToast(int resId) {
+        if (mToast == null) {
+            mToast = Toast.makeText(context, resId, Toast.LENGTH_LONG);
+        }else{
+            mToast.setText(resId);
+        }
+        return mToast;
+    }
+
+    public Toast getSingleLongToast(String text) {
+        if (mToast == null) {
+            mToast = Toast.makeText(context, text, Toast.LENGTH_LONG);
+        }else{
+            mToast.setText(text);
+        }
+        return mToast;
+    }
+
+    public Toast getToast(int resId) {
+        return Toast.makeText(context, resId, Toast.LENGTH_SHORT);
+    }
+
+    public Toast getToast(String text) {
+        return Toast.makeText(context, text, Toast.LENGTH_SHORT);
+    }
+
+    public Toast getLongToast(int resId) {
+        return Toast.makeText(context, resId, Toast.LENGTH_LONG);
+    }
+
+    public Toast getLongToast(String text) {
+        return Toast.makeText(context, text, Toast.LENGTH_LONG);
+    }
+
+    public void showSingletonToast(int resId) {
+        getSingletonToast(resId).show();
+    }
+
+
+    public void showSingletonToast(String text) {
+        getSingletonToast(text).show();
+    }
+
+    public void showSingleLongToast(int resId) {
+        getSingleLongToast(resId).show();
+    }
+
+
+    public void showSingleLongToast(String text) {
+        getSingleLongToast(text).show();
+    }
+
+    public void showToast(int resId) {
+        getToast(resId).show();
+    }
+
+    public void showToast(String text) {
+        getToast(text).show();
+    }
+
+    public void showLongToast(int resId) {
+        getLongToast(resId).show();
+    }
+
+    public void showLongToast(String text) {
+        getLongToast(text).show();
+    }
+
+}
Index: common/src/main/java/com/scene/common/common/utils/VibrateUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/VibrateUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/VibrateUtil.java	(revision )
@@ -0,0 +1,52 @@
+package com.scene.common.common.utils;
+
+import android.content.Context;
+import android.os.Vibrator;
+
+/**
+ * <p>All methods requires the caller to hold the permission
+ * {@link android.Manifest.permission#VIBRATE}.
+ *
+ * @author MaTianyu
+ * @date 2014-11-21
+ */
+public class VibrateUtil {
+
+    /**
+     * Vibrate constantly for the specified period of time.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#VIBRATE}.
+     *
+     * @param milliseconds The number of milliseconds to vibrate.
+     */
+    public static void vibrate(Context context, long milliseconds) {
+        Vibrator vibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
+        vibrator.vibrate(milliseconds);
+    }
+
+    /**
+     * Vibrate with a given pattern.
+     * <p/>
+     * <p>
+     * Pass in an array of ints that are the durations for which to turn on or off
+     * the vibrator in milliseconds.  The first value indicates the number of milliseconds
+     * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
+     * for which to keep the vibrator on before turning it off.  Subsequent values alternate
+     * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
+     * </p><p>
+     * To cause the pattern to repeat, pass the index into the pattern array at which
+     * to start the repeat, or -1 to disable repeating.
+     * </p>
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#VIBRATE}.
+     *
+     * @param pattern an array of longs of times for which to turn the vibrator on or off.
+     * @param repeat  the index into pattern at which to repeat, or -1 if
+     *                you don't want to repeat.
+     */
+    public static void vibrate(Context context, long[] pattern, int repeat) {
+        Vibrator vibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
+        vibrator.vibrate(pattern, repeat);
+    }
+
+}
Index: mylib/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/build.gradle	(revision )
+++ mylib/build.gradle	(revision )
@@ -0,0 +1,29 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(include: ['*.jar'], dir: 'libs')
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+    compile 'com.android.support:cardview-v7:23.1.0'
+    compile 'com.android.support:design:23.1.0'
+    compile 'com.android.support:recyclerview-v7:23.1.0'
+    compile files('libs/glide-3.7.0.jar')
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/adapter/LoadMoreAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/adapter/LoadMoreAdapter.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/adapter/LoadMoreAdapter.java	(revision )
@@ -0,0 +1,66 @@
+package com.scene.sceneandroiddemo.adapter;
+
+import android.content.Context;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.scene.mylib.view.recyclerview.OnRecyclerViewItemClickListener;
+import com.scene.mylib.view.recyclerview.RecyclerViewUtils;
+import com.scene.sceneandroiddemo.R;
+import com.scene.sceneandroiddemo.viewholder.MainViewHoder;
+
+import java.util.List;
+
+/**
+ * Created by Administrator on 16/01/26.
+ */
+public class LoadMoreAdapter extends RecyclerView.Adapter {
+    private LayoutInflater mLayoutInflater;
+
+    private Context mContext;
+    private List<String> dataList;
+    private RecyclerView recyclerView;
+    private OnRecyclerViewItemClickListener listener;
+
+    public LoadMoreAdapter(Context mContext, List<String> dataList, RecyclerView recyclerView) {
+        this.mContext = mContext;
+        this.dataList = dataList;
+        this.recyclerView = recyclerView;
+        mLayoutInflater = LayoutInflater.from(mContext);
+    }
+
+    public void setOnRecyclerViewItemClickListener(OnRecyclerViewItemClickListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        return new MainViewHoder(mLayoutInflater.inflate(R.layout.main_item, parent, false));
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+        final MainViewHoder viewHoder = (MainViewHoder) holder;
+        viewHoder.type.setText(dataList.get(position));
+        viewHoder.itemView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                /**
+                 *  处理如果有headerview或者footerview时候的点击事件
+                 *  需要重新计算item的位置
+                 */
+                if (listener != null) {
+                    listener.onRecyclerViewItemClick(RecyclerViewUtils.getAdapterPosition(recyclerView, viewHoder));
+                }
+            }
+        });
+    }
+
+    @Override
+    public int getItemCount() {
+        return dataList != null ? dataList.size() : 0;
+    }
+
+}
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .gitignore	(revision )
+++ .gitignore	(revision )
@@ -0,0 +1,8 @@
+*.iml
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
+/captures
Index: app/src/androidTest/java/com/scene/sceneandroiddemo/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/androidTest/java/com/scene/sceneandroiddemo/ApplicationTest.java	(revision )
+++ app/src/androidTest/java/com/scene/sceneandroiddemo/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.scene.sceneandroiddemo;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/MainTabActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/MainTabActivity.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/MainTabActivity.java	(revision )
@@ -0,0 +1,194 @@
+package com.scene.sceneandroiddemo;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentStatePagerAdapter;
+import android.support.v4.view.ViewPager;
+import android.support.v7.widget.Toolbar;
+import android.view.View;
+
+import com.scene.mylib.view.tab.APSTSViewPager;
+import com.scene.mylib.view.tab.AdvancedPagerSlidingTabStrip;
+import com.scene.sceneandroiddemo.ui.fragments.FirstFragment;
+import com.scene.sceneandroiddemo.ui.fragments.FourthFragment;
+import com.scene.sceneandroiddemo.ui.fragments.SecondFragment;
+import com.scene.sceneandroiddemo.ui.fragments.ThirdFragment;
+
+import butterknife.Bind;
+
+/**
+ * 主tab
+ */
+public class MainTabActivity extends BaseActivity implements ViewPager.OnPageChangeListener {
+    @Bind(R.id.toolbar)
+    Toolbar toolbar;
+    @Bind(R.id.tabs)
+    AdvancedPagerSlidingTabStrip mAPSTS;
+    @Bind(R.id.vp_main)
+    public APSTSViewPager mVP;
+    //viewpager标识
+    public static final int VIEW_FIRST = 0;
+    public static final int VIEW_SECOND = 1;
+    public static final int VIEW_THIRD = 2;
+    public static final int VIEW_FOURTH = 3;
+    //viewpager总页数
+    private static final int VIEW_SIZE = 4;
+    //fragment实例
+    private FirstFragment mFirstFragment = null;
+    private SecondFragment mSecondFragment = null;
+    private ThirdFragment mThirdFragment = null;
+    private FourthFragment mFourthFragment = null;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        init();
+        initToolBar();
+    }
+
+    @Override
+    protected int setLayoutResId() {
+        return R.layout.activity_main_tab;
+    }
+
+    private void initToolBar() {
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+        }
+    }
+
+    private void init() {
+        mVP.setOffscreenPageLimit(VIEW_SIZE);
+        FragmentAdapter adapter = new FragmentAdapter(getSupportFragmentManager());
+
+        mVP.setAdapter(new FragmentAdapter(getSupportFragmentManager()));
+        //禁用viewpager滑动
+        mVP.setNoFocus(true);
+        adapter.notifyDataSetChanged();
+        mAPSTS.setViewPager(mVP);
+        mAPSTS.setOnPageChangeListener(this);
+        mVP.setCurrentItem(VIEW_FIRST);
+        //设置圆点显示
+        //mAPSTS.showDot(VIEW_FIRST, "99+");
+    }
+
+    @Override
+    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+
+    }
+
+    @Override
+    public void onPageSelected(int position) {
+
+    }
+
+    @Override
+    public void onPageScrollStateChanged(int state) {
+
+    }
+
+
+    public class FragmentAdapter extends FragmentStatePagerAdapter implements AdvancedPagerSlidingTabStrip.IconTabProvider {
+
+        public FragmentAdapter(FragmentManager fm) {
+            super(fm);
+        }
+
+        @Override
+        public Fragment getItem(int position) {
+            if (position >= 0 && position < VIEW_SIZE) {
+                switch (position) {
+                    case VIEW_FIRST:
+                        if (null == mFirstFragment)
+                            mFirstFragment = FirstFragment.instance();
+                        return mFirstFragment;
+
+                    case VIEW_SECOND:
+                        if (null == mSecondFragment)
+                            mSecondFragment = SecondFragment.instance();
+                        return mSecondFragment;
+
+                    case VIEW_THIRD:
+                        if (null == mThirdFragment)
+                            mThirdFragment = ThirdFragment.instance();
+                        return mThirdFragment;
+
+                    case VIEW_FOURTH:
+                        if (null == mFourthFragment)
+                            mFourthFragment = FourthFragment.instance();
+                        return mFourthFragment;
+                    default:
+                        break;
+                }
+            }
+            return null;
+        }
+
+        @Override
+        public int getCount() {
+            return VIEW_SIZE;
+        }
+
+        @Override
+        public String getPageIconText(int position) {
+            if (position >= 0 && position < VIEW_SIZE) {
+                switch (position) {
+                    case VIEW_FIRST:
+                        return "first1";
+                    case VIEW_SECOND:
+                        return "second2";
+                    case VIEW_THIRD:
+                        return "third3";
+                    case VIEW_FOURTH:
+                        return "fourth4";
+                    default:
+                        break;
+                }
+            }
+            return null;
+        }
+
+        @Override
+        public Integer getPageIcon(int index) {
+            if (index >= 0 && index < VIEW_SIZE) {
+                switch (index) {
+                    case VIEW_FIRST:
+                        return R.mipmap.home_main_icon_n;
+                    case VIEW_SECOND:
+                        return R.mipmap.home_categry_icon_n;
+                    case VIEW_THIRD:
+                        return R.mipmap.home_live_icon_n;
+                    case VIEW_FOURTH:
+                        return R.mipmap.home_mine_icon_n;
+                    default:
+                        break;
+                }
+            }
+            return 0;
+        }
+
+        @Override
+        public Integer getPageSelectIcon(int index) {
+            if (index >= 0 && index < VIEW_SIZE) {
+                switch (index) {
+                    case VIEW_FIRST:
+                        toolbar.setTitle("1111");
+                        return R.mipmap.home_main_icon_f_n;
+                    case VIEW_SECOND:
+                        toolbar.setTitle("2222");
+                        return R.mipmap.home_categry_icon_f_n;
+                    case VIEW_THIRD:
+                        toolbar.setTitle("3333");
+                        return R.mipmap.home_live_icon_f_n;
+                    case VIEW_FOURTH:
+                        toolbar.setTitle("4444");
+                        return R.mipmap.home_mine_icon_f_n;
+                    default:
+                        break;
+                }
+            }
+            return 0;
+        }
+    }
+}
Index: common/src/main/java/com/scene/common/common/utils/MD5Util.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/MD5Util.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/MD5Util.java	(revision )
@@ -0,0 +1,49 @@
+package com.scene.common.common.utils;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * MS5
+ */
+public class MD5Util {
+    private static final String TAG                  = MD5Util.class.getSimpleName();
+    private static final int    STREAM_BUFFER_LENGTH = 1024;
+
+    public static MessageDigest getDigest(final String algorithm) throws NoSuchAlgorithmException {
+        return MessageDigest.getInstance(algorithm);
+    }
+
+    public static byte[] md5(String txt) {
+        return md5(txt.getBytes());
+    }
+
+    public static byte[] md5(byte[] bytes) {
+        try {
+            MessageDigest digest = getDigest("MD5");
+            digest.update(bytes);
+            return digest.digest();
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static byte[] md5(InputStream is) throws NoSuchAlgorithmException, IOException {
+        return updateDigest(getDigest("MD5"), is).digest();
+    }
+
+    public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {
+        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];
+        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);
+
+        while (read > -1) {
+            digest.update(buffer, 0, read);
+            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);
+        }
+
+        return digest;
+    }
+}
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/OnRecyclerViewItemClickListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/OnRecyclerViewItemClickListener.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/OnRecyclerViewItemClickListener.java	(revision )
@@ -0,0 +1,9 @@
+package com.scene.mylib.view.recyclerview;
+
+/**
+ * RecyclerViewItem点击事件
+ * Created by scene on 16/01/08.
+ */
+public interface OnRecyclerViewItemClickListener {
+    void onRecyclerViewItemClick(int position);
+}
Index: chooseimagelib/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/AndroidManifest.xml	(revision )
+++ chooseimagelib/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,15 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.scene.chooseimagelib">
+
+    <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.CAMERA" />
+
+    <application
+        android:allowBackup="true"
+        android:supportsRtl="true">
+        <activity android:name="com.scene.chooseimagelib.simplecropimage.CropImage" />
+    </application>
+
+</manifest>
Index: ucrop/src/main/res/color/ucrop_scale_text_view_selector.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/color/ucrop_scale_text_view_selector.xml	(revision )
+++ ucrop/src/main/res/color/ucrop_scale_text_view_selector.xml	(revision )
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_selected="true" android:color="@color/ucrop_color_widget_active" />
+    <item android:color="@android:color/black" />
+</selector>
Index: timeline/src/main/java/com/scene/timeline/TimelineView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/main/java/com/scene/timeline/TimelineView.java	(revision )
+++ timeline/src/main/java/com/scene/timeline/TimelineView.java	(revision )
@@ -0,0 +1,165 @@
+package com.scene.timeline;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.view.View;
+
+/**
+ * Created by scene on 05-12-2015.
+ */
+public class TimelineView extends View {
+
+    private Drawable mMarker;
+    private Drawable mStartLine;
+    private Drawable mEndLine;
+    private int mMarkerSize;
+    private int mLineSize;
+
+    private Rect mBounds;
+    private Context mContext;
+
+
+    public TimelineView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mContext = context;
+        init(attrs);
+    }
+
+    private void init(AttributeSet attrs) {
+        TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.timeline_style);
+        mMarker = typedArray.getDrawable(R.styleable.timeline_style_marker);
+        mStartLine = typedArray.getDrawable(R.styleable.timeline_style_line);
+        mEndLine = typedArray.getDrawable(R.styleable.timeline_style_line);
+        mMarkerSize = typedArray.getDimensionPixelSize(R.styleable.timeline_style_marker_size, 25);
+        mLineSize = typedArray.getDimensionPixelSize(R.styleable.timeline_style_line_size, 2);
+        typedArray.recycle();
+
+        if (mMarker == null) {
+            mMarker = mContext.getResources().getDrawable(R.drawable.marker);
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        //Width measurements of the width and height and the inside view of child controls
+        int w = mMarkerSize + getPaddingLeft() + getPaddingRight();
+        int h = mMarkerSize + getPaddingTop() + getPaddingBottom();
+
+        // Width and height to determine the final view through a systematic approach to decision-making
+        int widthSize = resolveSizeAndState(w, widthMeasureSpec, 0);
+        int heightSize = resolveSizeAndState(h, heightMeasureSpec, 0);
+
+        setMeasuredDimension(widthSize, heightSize);
+        initDrawable();
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        // When the view is displayed when the callback
+        // Positioning Drawable coordinates, then draw
+        initDrawable();
+    }
+
+    private void initDrawable() {
+        int pLeft = getPaddingLeft();
+        int pRight = getPaddingRight();
+        int pTop = getPaddingTop();
+        int pBottom = getPaddingBottom();
+
+        int width = getWidth();// Width of current custom view
+        int height = getHeight();
+
+        int cWidth = width - pLeft - pRight;// Circle width
+        int cHeight = height - pTop - pBottom;
+
+        int markSize = Math.min(mMarkerSize, Math.min(cWidth, cHeight));
+
+        if (mMarker != null) {
+            mMarker.setBounds(pLeft, pTop, pLeft + markSize, pTop + markSize);
+            mBounds = mMarker.getBounds();
+        }
+
+        int centerX = mBounds.centerX();
+        int lineLeft = centerX - (mLineSize >> 1);
+        if (mStartLine != null) {
+            mStartLine.setBounds(lineLeft, 0, mLineSize + lineLeft, mBounds.top);
+        }
+
+        if (mEndLine != null) {
+            mEndLine.setBounds(lineLeft, mBounds.bottom, mLineSize + lineLeft, height);
+        }
+
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        if (mMarker != null) {
+            mMarker.draw(canvas);
+        }
+
+        if (mStartLine != null) {
+            mStartLine.draw(canvas);
+        }
+        if (mEndLine != null) {
+            mEndLine.draw(canvas);
+        }
+    }
+
+    public void setMarker(Drawable marker) {
+        mMarker = marker;
+        initDrawable();
+    }
+
+    public void setStartLine(Drawable startline) {
+        mStartLine = startline;
+        initDrawable();
+    }
+
+    public void setEndLine(Drawable endLine) {
+        mEndLine = endLine;
+        initDrawable();
+    }
+
+    public void setMarkerSize(int markerSize) {
+        mMarkerSize = markerSize;
+        initDrawable();
+    }
+
+    public void setLineSize(int lineSize) {
+        mLineSize = lineSize;
+        initDrawable();
+    }
+
+    public void initLine(int viewType) {
+
+        if (viewType == LineType.BEGIN) {
+            setStartLine(null);
+        } else if (viewType == LineType.END) {
+            setEndLine(null);
+        } else if (viewType == LineType.ONLYONE) {
+            setStartLine(null);
+            setEndLine(null);
+        }
+
+        initDrawable();
+    }
+
+    public static int getTimeLineViewType(int position, int total_size) {
+        if (position == 0) {
+            return LineType.BEGIN;
+        } else if (position == total_size - 1) {
+            return LineType.END;
+        } else if (total_size == 1) {
+            return LineType.ONLYONE;
+        } else {
+            return LineType.NORMAL;
+        }
+    }
+}
Index: ucrop/src/main/java/com/yalantis/ucrop/util/RectUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/util/RectUtils.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/util/RectUtils.java	(revision )
@@ -0,0 +1,72 @@
+package com.yalantis.ucrop.util;
+
+import android.graphics.RectF;
+
+public class RectUtils {
+
+    /**
+     * Gets a float array of the 2D coordinates representing a rectangles
+     * corners.
+     * The order of the corners in the float array is:
+     * 0------->1
+     * ^        |
+     * |        |
+     * |        v
+     * 3<-------2
+     *
+     * @param r the rectangle to get the corners of
+     * @return the float array of corners (8 floats)
+     */
+    public static float[] getCornersFromRect(RectF r) {
+        return new float[]{
+                r.left, r.top,
+                r.right, r.top,
+                r.right, r.bottom,
+                r.left, r.bottom
+        };
+    }
+
+    /**
+     * Gets a float array of two lengths representing a rectangles width and height
+     * The order of the corners in the input float array is:
+     * 0------->1
+     * ^        |
+     * |        |
+     * |        v
+     * 3<-------2
+     *
+     * @param corners the float array of corners (8 floats)
+     * @return the float array of width and height (2 floats)
+     */
+    public static float[] getRectSidesFromCorners(float[] corners) {
+        return new float[]{(float) Math.sqrt(Math.pow(corners[0] - corners[2], 2) + Math.pow(corners[1] - corners[3], 2)),
+                (float) Math.sqrt(Math.pow(corners[2] - corners[4], 2) + Math.pow(corners[3] - corners[5], 2))};
+    }
+
+    public static float[] getCenterFromRect(RectF r) {
+        return new float[]{r.centerX(), r.centerY()};
+    }
+
+    /**
+     * Takes an array of 2D coordinates representing corners and returns the
+     * smallest rectangle containing those coordinates.
+     *
+     * @param array array of 2D coordinates
+     * @return smallest rectangle containing coordinates
+     */
+    public static RectF trapToRect(float[] array) {
+        RectF r = new RectF(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY,
+                Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);
+        for (int i = 1; i < array.length; i += 2) {
+            float x = array[i - 1];
+            float y = array[i];
+            r.left = (x < r.left) ? x : r.left;
+            r.top = (y < r.top) ? y : r.top;
+            r.right = (x > r.right) ? x : r.right;
+            r.bottom = (y > r.bottom) ? y : r.bottom;
+        }
+        r.sort();
+        return r;
+    }
+
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/assist/Network.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/Network.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/Network.java	(revision )
@@ -0,0 +1,323 @@
+package com.scene.common.common.assist;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.telephony.TelephonyManager;
+
+import com.scene.common.android.log.Log;
+
+import java.lang.reflect.Method;
+
+/**
+ * assist us in sensing state of the networks.
+ * <p>
+ * need  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+ * <p>
+ * 半夜了，研究了一下Android的Network方面，发现网上有些文章理解的是不对的。
+ * 以下方法是我研究得出的结论和方法，如有误也感谢指出。
+ *
+ * @author MaTianyu
+ *         2014-1-8上午 00:33:11
+ */
+public class Network {
+    private static final String TAG = Network.class.getSimpleName();
+
+    public enum NetType {
+        None(1),
+        Mobile(2),
+        Wifi(4),
+        Other(8);
+
+        NetType(int value) {
+            this.value = value;
+        }
+
+        public int value;
+    }
+
+    public enum NetWorkType {
+        UnKnown(-1),
+        Wifi(1),
+        Net2G(2),
+        Net3G(3),
+        Net4G(4);
+
+        NetWorkType(int value) {
+            this.value = value;
+        }
+
+        public int value;
+    }
+    //
+    //public enum NetSubType {
+    //    None(1),
+    //    Mobile(2),
+    //    Wifi(4),
+    //    Other(8);
+    //
+    //    NetType(int value) {
+    //        this.value = value;
+    //    }
+    //
+    //    public int value;
+    //}
+
+    /**
+     * 获取ConnectivityManager
+     */
+    public static ConnectivityManager getConnectivityManager(Context context) {
+        return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+    }
+
+    /**
+     * 获取ConnectivityManager
+     */
+    public static TelephonyManager getTelephonyManager(Context context) {
+        return (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+    }
+
+    /**
+     * 判断网络连接是否有效（此时可传输数据）。
+     *
+     * @return boolean 不管wifi，还是mobile net，只有当前在连接状态（可有效传输数据）才返回true,反之false。
+     */
+    public static boolean isConnected(Context context) {
+        NetworkInfo net = getConnectivityManager(context).getActiveNetworkInfo();
+        return net != null && net.isConnected();
+    }
+
+    /**
+     * 判断有无网络正在连接中（查找网络、校验、获取IP等）。
+     *
+     * @return boolean 不管wifi，还是mobile net，只有当前在连接状态（可有效传输数据）才返回true,反之false。
+     */
+    public static boolean isConnectedOrConnecting(Context context) {
+        NetworkInfo[] nets = getConnectivityManager(context).getAllNetworkInfo();
+        if (nets != null) {
+            for (NetworkInfo net : nets) {
+                if (net.isConnectedOrConnecting()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public static NetType getConnectedType(Context context) {
+        NetworkInfo net = getConnectivityManager(context).getActiveNetworkInfo();
+        if (net != null) {
+            switch (net.getType()) {
+                case ConnectivityManager.TYPE_WIFI:
+                    return NetType.Wifi;
+                case ConnectivityManager.TYPE_MOBILE:
+                    return NetType.Mobile;
+                default:
+                    return NetType.Other;
+            }
+        }
+        return NetType.None;
+    }
+
+    /**
+     * 是否存在有效的WIFI连接
+     */
+    public static boolean isWifiConnected(Context context) {
+        NetworkInfo net = getConnectivityManager(context).getActiveNetworkInfo();
+        return net != null && net.getType() == ConnectivityManager.TYPE_WIFI && net.isConnected();
+    }
+
+    /**
+     * 是否存在有效的移动连接
+     *
+     * @return boolean
+     */
+    public static boolean isMobileConnected(Context context) {
+        NetworkInfo net = getConnectivityManager(context).getActiveNetworkInfo();
+        return net != null && net.getType() == ConnectivityManager.TYPE_MOBILE && net.isConnected();
+    }
+
+    /**
+     * 检测网络是否为可用状态
+     */
+    public static boolean isAvailable(Context context) {
+        return isWifiAvailable(context) || (isMobileAvailable(context) && isMobileEnabled(context));
+    }
+
+    /**
+     * 判断是否有可用状态的Wifi，以下情况返回false：
+     * 1. 设备wifi开关关掉;
+     * 2. 已经打开飞行模式；
+     * 3. 设备所在区域没有信号覆盖；
+     * 4. 设备在漫游区域，且关闭了网络漫游。
+     *
+     * @return boolean wifi为可用状态（不一定成功连接，即Connected）即返回ture
+     */
+    public static boolean isWifiAvailable(Context context) {
+        NetworkInfo[] nets = getConnectivityManager(context).getAllNetworkInfo();
+        if (nets != null) {
+            for (NetworkInfo net : nets) {
+                if (net.getType() == ConnectivityManager.TYPE_WIFI) {
+                    return net.isAvailable();
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * 判断有无可用状态的移动网络，注意关掉设备移动网络直接不影响此函数。
+     * 也就是即使关掉移动网络，那么移动网络也可能是可用的(彩信等服务)，即返回true。
+     * 以下情况它是不可用的，将返回false：
+     * 1. 设备打开飞行模式；
+     * 2. 设备所在区域没有信号覆盖；
+     * 3. 设备在漫游区域，且关闭了网络漫游。
+     *
+     * @return boolean
+     */
+    public static boolean isMobileAvailable(Context context) {
+        NetworkInfo[] nets = getConnectivityManager(context).getAllNetworkInfo();
+        if (nets != null) {
+            for (NetworkInfo net : nets) {
+                if (net.getType() == ConnectivityManager.TYPE_MOBILE) {
+                    return net.isAvailable();
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * 设备是否打开移动网络开关
+     *
+     * @return boolean 打开移动网络返回true，反之false
+     */
+    public static boolean isMobileEnabled(Context context) {
+        try {
+            Method getMobileDataEnabledMethod = ConnectivityManager.class.getDeclaredMethod("getMobileDataEnabled");
+            getMobileDataEnabledMethod.setAccessible(true);
+            return (Boolean) getMobileDataEnabledMethod.invoke(getConnectivityManager(context));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        // 反射失败，默认开启
+        return true;
+    }
+
+    /**
+     * 打印当前各种网络状态
+     *
+     * @return boolean
+     */
+    public static boolean printNetworkInfo(Context context) {
+        ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        if (connectivity != null) {
+            NetworkInfo in = connectivity.getActiveNetworkInfo();
+            Log.i(TAG, "-------------$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------");
+            Log.i(TAG, "getActiveNetworkInfo: " + in);
+            NetworkInfo[] info = connectivity.getAllNetworkInfo();
+            if (info != null) {
+                for (int i = 0; i < info.length; i++) {
+                    // if (info[i].getType() == ConnectivityManager.TYPE_WIFI) {
+                    Log.i(TAG, "NetworkInfo[" + i + "]isAvailable : " + info[i].isAvailable());
+                    Log.i(TAG, "NetworkInfo[" + i + "]isConnected : " + info[i].isConnected());
+                    Log.i(TAG, "NetworkInfo[" + i + "]isConnectedOrConnecting : " + info[i].isConnectedOrConnecting());
+                    Log.i(TAG, "NetworkInfo[" + i + "]: " + info[i]);
+                    // }
+                }
+                Log.i(TAG, "\n");
+            } else {
+                Log.i(TAG, "getAllNetworkInfo is null");
+            }
+        }
+        return false;
+    }
+
+    /**
+     * get connected network type by {@link ConnectivityManager}
+     * <p>
+     * such as WIFI, MOBILE, ETHERNET, BLUETOOTH, etc.
+     *
+     * @return {@link ConnectivityManager#TYPE_WIFI}, {@link ConnectivityManager#TYPE_MOBILE},
+     * {@link ConnectivityManager#TYPE_ETHERNET}...
+     */
+    public static int getConnectedTypeINT(Context context) {
+        NetworkInfo net = getConnectivityManager(context).getActiveNetworkInfo();
+        if (net != null) {
+            if (Log.isPrint) {
+                Log.i(TAG, "NetworkInfo: " + net.toString());
+            }
+            return net.getType();
+        }
+        return -1;
+    }
+
+    /**
+     * get network type by {@link TelephonyManager}
+     * <p>
+     * such as 2G, 3G, 4G, etc.
+     *
+     * @return {@link TelephonyManager#NETWORK_TYPE_CDMA}, {@link TelephonyManager#NETWORK_TYPE_GPRS},
+     * {@link TelephonyManager#NETWORK_TYPE_LTE}...
+     */
+    public static int getTelNetworkTypeINT(Context context) {
+        return getTelephonyManager(context).getNetworkType();
+    }
+
+    /**
+     * GPRS    2G(2.5) General Packet Radia Service 114kbps
+     * EDGE    2G(2.75G) Enhanced Data Rate for GSM Evolution 384kbps
+     * UMTS    3G WCDMA 联通3G Universal Mobile Telecommunication System 完整的3G移动通信技术标准
+     * CDMA    2G 电信 Code Division Multiple Access 码分多址
+     * EVDO_0  3G (EVDO 全程 CDMA2000 1xEV-DO) Evolution - Data Only (Data Optimized) 153.6kps - 2.4mbps 属于3G
+     * EVDO_A  3G 1.8mbps - 3.1mbps 属于3G过渡，3.5G
+     * 1xRTT   2G CDMA2000 1xRTT (RTT - 无线电传输技术) 144kbps 2G的过渡,
+     * HSDPA   3.5G 高速下行分组接入 3.5G WCDMA High Speed Downlink Packet Access 14.4mbps
+     * HSUPA   3.5G High Speed Uplink Packet Access 高速上行链路分组接入 1.4 - 5.8 mbps
+     * HSPA    3G (分HSDPA,HSUPA) High Speed Packet Access
+     * IDEN    2G Integrated Dispatch Enhanced Networks 集成数字增强型网络 （属于2G，来自维基百科）
+     * EVDO_B  3G EV-DO Rev.B 14.7Mbps 下行 3.5G
+     * LTE     4G Long Term Evolution FDD-LTE 和 TDD-LTE , 3G过渡，升级版 LTE Advanced 才是4G
+     * EHRPD   3G CDMA2000向LTE 4G的中间产物 Evolved High Rate Packet Data HRPD的升级
+     * HSPAP   3G HSPAP 比 HSDPA 快些
+     *
+     * @return {@link  NetWorkType}
+     */
+    public static NetWorkType getNetworkType(Context context) {
+        int type = getConnectedTypeINT(context);
+        switch (type) {
+            case ConnectivityManager.TYPE_WIFI:
+                return NetWorkType.Wifi;
+            case ConnectivityManager.TYPE_MOBILE:
+            case ConnectivityManager.TYPE_MOBILE_DUN:
+            case ConnectivityManager.TYPE_MOBILE_HIPRI:
+            case ConnectivityManager.TYPE_MOBILE_MMS:
+            case ConnectivityManager.TYPE_MOBILE_SUPL:
+                int teleType = getTelephonyManager(context).getNetworkType();
+                switch (teleType) {
+                    case TelephonyManager.NETWORK_TYPE_GPRS:
+                    case TelephonyManager.NETWORK_TYPE_EDGE:
+                    case TelephonyManager.NETWORK_TYPE_CDMA:
+                    case TelephonyManager.NETWORK_TYPE_1xRTT:
+                    case TelephonyManager.NETWORK_TYPE_IDEN:
+                        return NetWorkType.Net2G;
+                    case TelephonyManager.NETWORK_TYPE_UMTS:
+                    case TelephonyManager.NETWORK_TYPE_EVDO_0:
+                    case TelephonyManager.NETWORK_TYPE_EVDO_A:
+                    case TelephonyManager.NETWORK_TYPE_HSDPA:
+                    case TelephonyManager.NETWORK_TYPE_HSUPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPA:
+                    case TelephonyManager.NETWORK_TYPE_EVDO_B:
+                    case TelephonyManager.NETWORK_TYPE_EHRPD:
+                    case TelephonyManager.NETWORK_TYPE_HSPAP:
+                        return NetWorkType.Net3G;
+                    case TelephonyManager.NETWORK_TYPE_LTE:
+                        return NetWorkType.Net4G;
+                    default:
+                        return NetWorkType.UnKnown;
+                }
+            default:
+                return NetWorkType.UnKnown;
+        }
+    }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/ratingbar/ProperRatingBar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/ratingbar/ProperRatingBar.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/ratingbar/ProperRatingBar.java	(revision )
@@ -0,0 +1,308 @@
+package com.scene.mylib.view.ratingbar;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.scene.mylib.R;
+
+/*
+    The MIT License (MIT)
+    Copyright (c) 2015 Techery (http://techery.io/)
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+    The above copyright notice and this permission notice shall be included in
+    all copies or substantial portions of the Software.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+    THE SOFTWARE.
+ */
+
+
+public class ProperRatingBar extends LinearLayout {
+
+    private static final int DF_TOTAL_TICKS = 5;
+    private static final int DF_DEFAULT_TICKS = 3;
+    private static final boolean DF_CLICKABLE = false;
+    //private static final int DF_SYMBOLIC_TICK_RES = R.string.prb_default_symbolic_string;
+    private static final int DF_SYMBOLIC_TEXT_SIZE_RES = R.dimen.prb_symbolic_tick_default_text_size;
+    private static final int DF_SYMBOLIC_TEXT_STYLE = Typeface.NORMAL;
+    private static final int DF_SYMBOLIC_TEXT_NORMAL_COLOR = Color.BLACK;
+    private static final int DF_SYMBOLIC_TEXT_SELECTED_COLOR = Color.GRAY;
+    private static final int DF_TICK_SPACING_RES = R.dimen.prb_drawable_tick_default_spacing;
+
+    private int totalTicks;
+    private int lastSelectedTickIndex;
+    private boolean isClickable;
+    private String symbolicTick;
+    private int customTextSize;
+    private int customTextStyle;
+    private int customTextNormalColor;
+    private int customTextSelectedColor;
+    private Drawable tickNormalDrawable;
+    private Drawable tickSelectedDrawable;
+    private int tickSpacing;
+
+    private boolean useSymbolicTick = false;
+    private int rating;
+    private RatingListener listener = null;
+
+    public ProperRatingBar(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context, attrs);
+    }
+
+    private void init(Context context, AttributeSet attrs) {
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ProperRatingBar);
+        //
+        totalTicks = a.getInt(R.styleable.ProperRatingBar_prb_totalTicks, DF_TOTAL_TICKS);
+        rating = a.getInt(R.styleable.ProperRatingBar_prb_defaultRating, DF_DEFAULT_TICKS);
+        //
+        isClickable = a.getBoolean(R.styleable.ProperRatingBar_prb_clickable, DF_CLICKABLE);
+        //
+        symbolicTick = a.getString(R.styleable.ProperRatingBar_prb_symbolicTick);
+        if (symbolicTick == null) symbolicTick = "★";
+        //
+        customTextSize = a.getDimensionPixelSize(R.styleable.ProperRatingBar_android_textSize,
+                context.getResources().getDimensionPixelOffset(DF_SYMBOLIC_TEXT_SIZE_RES));
+        customTextStyle = a.getInt(R.styleable.ProperRatingBar_android_textStyle, DF_SYMBOLIC_TEXT_STYLE);
+        customTextNormalColor = a.getColor(R.styleable.ProperRatingBar_prb_symbolicTickNormalColor,
+                DF_SYMBOLIC_TEXT_NORMAL_COLOR);
+        customTextSelectedColor = a.getColor(R.styleable.ProperRatingBar_prb_symbolicTickSelectedColor,
+                DF_SYMBOLIC_TEXT_SELECTED_COLOR);
+        //
+        tickNormalDrawable = a.getDrawable(R.styleable.ProperRatingBar_prb_tickNormalDrawable);
+        tickSelectedDrawable = a.getDrawable(R.styleable.ProperRatingBar_prb_tickSelectedDrawable);
+        tickSpacing = a.getDimensionPixelOffset(R.styleable.ProperRatingBar_prb_tickSpacing,
+                context.getResources().getDimensionPixelOffset(DF_TICK_SPACING_RES));
+        //
+        afterInit();
+        //
+        a.recycle();
+    }
+
+    private void afterInit() {
+        if (rating > totalTicks) rating = totalTicks;
+        lastSelectedTickIndex = rating - 1;
+        //
+        if (tickNormalDrawable == null || tickSelectedDrawable == null) {
+            useSymbolicTick = true;
+        }
+        //
+        addChildren(this.getContext());
+    }
+
+    private void addChildren(Context context) {
+        this.removeAllViews();
+        for (int i = 0; i < totalTicks; i++) {
+            addChild(context, i);
+        }
+        redrawChildren();
+    }
+
+    private void addChild(Context context, int position) {
+        if (useSymbolicTick) {
+            addSymbolicChild(context, position);
+        } else {
+            addDrawableChild(context, position);
+        }
+    }
+
+    private void addSymbolicChild(Context context, int position) {
+        TextView tv = new TextView(context);
+        tv.setText(symbolicTick);
+        tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, customTextSize);
+        if (customTextStyle != 0) {
+            tv.setTypeface(Typeface.DEFAULT, customTextStyle);
+        }
+        if (isClickable) {
+            tv.setTag(R.id.prb_child_tag_id, position);
+            tv.setOnClickListener(mTickClickedListener);
+        }
+        this.addView(tv);
+    }
+
+    private void addDrawableChild(Context context, int position) {
+        ImageView iv = new ImageView(context);
+        iv.setPadding(tickSpacing, tickSpacing, tickSpacing, tickSpacing);
+        if (isClickable) {
+            iv.setTag(R.id.prb_child_tag_id, position);
+            iv.setOnClickListener(mTickClickedListener);
+        }
+        this.addView(iv);
+    }
+
+    private View.OnClickListener mTickClickedListener = new OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            lastSelectedTickIndex = (int) v.getTag(R.id.prb_child_tag_id);
+            rating = lastSelectedTickIndex + 1;
+            redrawChildren();
+            if (listener != null) listener.onRatePicked(ProperRatingBar.this);
+        }
+    };
+
+    private void redrawChildren() {
+        for (int i = 0; i < totalTicks; i++) {
+            if (useSymbolicTick) {
+                redrawChildSelection((TextView) ProperRatingBar.this.getChildAt(i), i <= lastSelectedTickIndex);
+            } else {
+                redrawChildSelection((ImageView) ProperRatingBar.this.getChildAt(i), i <= lastSelectedTickIndex);
+            }
+        }
+    }
+
+    private void redrawChildSelection(ImageView child, boolean isSelected) {
+        if (isSelected) {
+            child.setImageDrawable(tickSelectedDrawable);
+        } else {
+            child.setImageDrawable(tickNormalDrawable);
+        }
+    }
+
+    private void redrawChildSelection(TextView child, boolean isSelected) {
+        if (isSelected) {
+            child.setTextColor(customTextSelectedColor);
+        } else {
+            child.setTextColor(customTextNormalColor);
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Saving and restoring state
+    ///////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        SavedState savedState = new SavedState(super.onSaveInstanceState());
+        savedState.rating = rating;
+
+        return savedState;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        if (!(state instanceof SavedState)) {
+            super.onRestoreInstanceState(state);
+            return;
+        }
+
+        SavedState savedState = (SavedState) state;
+        super.onRestoreInstanceState(savedState.getSuperState());
+
+        setRating(savedState.rating);
+    }
+
+    static class SavedState extends BaseSavedState {
+
+        int rating;
+
+        SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        private SavedState(Parcel in) {
+            super(in);
+            this.rating = in.readInt();
+        }
+
+        @Override
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeInt(this.rating);
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Them getter and setter methods
+    ///////////////////////////////////////////////////////////////////////////
+
+    /**
+     * Get the attached {@link RatingListener}
+     *
+     * @return listener or null if none was set
+     */
+    @Nullable
+    public RatingListener getListener() {
+        return listener;
+    }
+
+    /**
+     * Set the {@link RatingListener} to be called when user taps rating bar's ticks
+     *
+     * @param listener listener to set
+     * @throws IllegalArgumentException if listener is <b>null</b>
+     */
+    public void setListener(RatingListener listener) {
+        if (listener == null) throw new IllegalArgumentException("listener cannot be null!");
+
+        this.listener = listener;
+        this.isClickable = true;
+    }
+
+    /**
+     * Remove listener
+     */
+    public void removeRatingListener() {
+        this.listener = null;
+    }
+
+    /**
+     * Get the current rating shown
+     *
+     * @return rating
+     */
+    public int getRating() {
+        return rating;
+    }
+
+    /**
+     * Set the rating to show
+     *
+     * @param rating new rating value
+     */
+    public void setRating(int rating) {
+        if (rating > this.totalTicks) rating = totalTicks;
+        this.rating = rating;
+        lastSelectedTickIndex = rating - 1;
+        redrawChildren();
+    }
+
+    public void setSymbolicTick(String tick) {
+        this.symbolicTick = tick;
+        afterInit();
+    }
+
+    public String getSymbolicTick() {
+        return this.symbolicTick;
+    }
+}
\ No newline at end of file
Index: chooseimagelib/src/test/java/com/scene/chooseimagelib/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/test/java/com/scene/chooseimagelib/ExampleUnitTest.java	(revision )
+++ chooseimagelib/src/test/java/com/scene/chooseimagelib/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.scene.chooseimagelib;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: .idea/runConfigurations.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/runConfigurations.xml	(revision )
+++ .idea/runConfigurations.xml	(revision )
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RunConfigurationProducerService">
+    <option name="ignoredProducers">
+      <set>
+        <option value="org.jetbrains.plugins.gradle.execution.test.runner.AllInPackageGradleConfigurationProducer" />
+        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestClassGradleConfigurationProducer" />
+        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestMethodGradleConfigurationProducer" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: mylib/src/main/res/layout/layout_load_state_view_error.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/layout_load_state_view_error.xml	(revision )
+++ mylib/src/main/res/layout/layout_load_state_view_error.xml	(revision )
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/errorStateRelativeLayout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:id="@+id/errorViewRelativeLayout"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:orientation="vertical">
+
+        <ImageView
+            android:id="@+id/errorStateImageView"
+            android:layout_width="108dp"
+            android:layout_height="108dp"
+            android:layout_gravity="center_horizontal"
+            tools:background="#000000"
+            tools:ignore="ContentDescription" />
+
+        <TextView
+            android:id="@+id/errorStateTitleTextView"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginLeft="16dp"
+            android:layout_marginRight="16dp"
+            android:layout_marginTop="20dp"
+            android:textSize="15sp"
+            android:textStyle="bold"
+            tools:text="错误提示标题" />
+
+        <TextView
+            android:id="@+id/errorStateContentTextView"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginBottom="16dp"
+            android:layout_marginLeft="56dp"
+            android:layout_marginRight="56dp"
+            android:layout_marginTop="10dp"
+            android:gravity="center"
+            android:lineSpacingExtra="5.5dp"
+            tools:text="错误提示内容" />
+
+        <Button
+            android:id="@+id/errorStateButton"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:text="点击重试" />
+
+    </LinearLayout>
+
+</RelativeLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/ByteUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/ByteUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/ByteUtil.java	(revision )
@@ -0,0 +1,59 @@
+package com.scene.common.common.utils;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+/**
+ * @author MaTianyu
+ * @date 14-7-31
+ */
+public class ByteUtil {
+    /**
+     * byte[] 转为 对象
+     *
+     * @param bytes
+     * @return
+     */
+    public static Object byteToObject(byte[] bytes) throws Exception {
+        ObjectInputStream ois = null;
+        try {
+            ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
+            return ois.readObject();
+        } finally {
+            if (ois != null) ois.close();
+        }
+    }
+
+    /**
+     * 对象 转为 byte[]
+     *
+     * @param obj
+     * @return
+     */
+    public static byte[] objectToByte(Object obj) throws Exception {
+        ObjectOutputStream oos = null;
+        try {
+            ByteArrayOutputStream bos = new ByteArrayOutputStream();
+            oos = new ObjectOutputStream(bos);
+            oos.writeObject(obj);
+            return bos.toByteArray();
+        } finally {
+            if (oos != null) oos.close();
+        }
+    }
+
+    public static void byteToBit(byte[] bytes, StringBuilder sb) {
+        for (int i = 0; i < Byte.SIZE * bytes.length; i++)
+            sb.append((bytes[i / Byte.SIZE] << i % Byte.SIZE & 0x80) == 0 ? '0' : '1');
+    }
+
+    public static String byteToBit(byte[] bytes) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < Byte.SIZE * bytes.length; i++)
+            sb.append((bytes[i / Byte.SIZE] << i % Byte.SIZE & 0x80) == 0 ? '0' : '1');
+        return sb.toString();
+    }
+
+}
Index: mylib/src/main/res/layout/layout_load_state_view_load.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/layout_load_state_view_load.xml	(revision )
+++ mylib/src/main/res/layout/layout_load_state_view_load.xml	(revision )
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/loadingStateRelativeLayout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <ProgressBar
+        android:id="@+id/loadingStateProgressBar"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"/>
+
+</RelativeLayout>
\ No newline at end of file
Index: app/src/main/res/values/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/dimens.xml	(revision )
+++ app/src/main/res/values/dimens.xml	(revision )
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
Index: common/src/main/java/com/scene/common/common/service/NotificationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/service/NotificationService.java	(revision )
+++ common/src/main/java/com/scene/common/common/service/NotificationService.java	(revision )
@@ -0,0 +1,180 @@
+package com.scene.common.common.service;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.Notification;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.os.Bundle;
+import android.provider.Settings;
+import android.service.notification.NotificationListenerService;
+import android.service.notification.StatusBarNotification;
+import android.text.TextUtils;
+import com.scene.common.android.log.Log;
+
+/**
+ * note: VERSION_CODE >= API_18
+ * <p/>
+ * manifest:
+ * <service android:name=".service.NotificationService"
+ *  android:label="@string/app_name"
+ *  android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">
+ *  <intent-filter>
+ *      <action android:name="android.service.notification.NotificationListenerService" />
+ *  </intent-filter>
+ * </service>
+ *
+ * @author MaTianyu
+ * @date 2015-03-09
+ */
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+public class NotificationService extends NotificationListenerService {
+    private static final String TAG = "NotificationService";
+    public static final String ACTION_NOTIFICATION_LISTENER_SETTINGS = "android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS";
+    private static final String ENABLED_NOTIFICATION_LISTENERS = "enabled_notification_listeners";
+    private static NotificationService self;
+    private static NotificationListener notificationListener;
+
+    /*----------------- 静态方法 -----------------*/
+    public synchronized static void startNotificationService(Context context, NotificationListener notificationListener) {
+        NotificationService.notificationListener = notificationListener;
+        context.startService(new Intent(context, NotificationService.class));
+    }
+
+    public synchronized static void stopNotificationService(Context context) {
+        context.stopService(new Intent(context, NotificationService.class));
+    }
+
+
+    public static void startNotificationListenSettings(Context context) {
+        Intent intent = new Intent(ACTION_NOTIFICATION_LISTENER_SETTINGS);
+        if(!(context instanceof Activity)) {
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        }
+        context.startActivity(intent);
+    }
+
+    public static boolean isNotificationListenEnable(Context context) {
+        return isNotificationListenEnable(context, context.getPackageName());
+    }
+
+    public static boolean isNotificationListenEnable(Context context, String pkgName) {
+        final String flat = Settings.Secure.getString(context.getContentResolver(), ENABLED_NOTIFICATION_LISTENERS);
+        if (!TextUtils.isEmpty(flat)) {
+            final String[] names = flat.split(":");
+            for (int i = 0; i < names.length; i++) {
+                final ComponentName cn = ComponentName.unflattenFromString(names[i]);
+                if (cn != null) {
+                    if (TextUtils.equals(pkgName, cn.getPackageName())) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    /*----------------- 生命周期 -----------------*/
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Log.i(TAG, "onCreate..");
+
+        if (notificationListener != null) {
+            notificationListener.onServiceCreated(this);
+        }
+        self = this;
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Log.i(TAG, "onStartCommand..");
+
+        return notificationListener == null ? START_STICKY : notificationListener.onServiceStartCommand(this, intent, flags, startId);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        Log.i(TAG, "onDestroy..");
+
+        if (notificationListener != null) {
+            notificationListener.onServiceDestroy();
+            notificationListener = null;
+        }
+        self = null;
+    }
+
+    /*----------------- 通知回调 -----------------*/
+    @Override
+    public void onNotificationPosted(StatusBarNotification sbn) {
+        if (Log.isPrint) {
+            Log.i(TAG, sbn.toString());
+            Notification notification = sbn.getNotification();
+            Log.i(TAG, "tickerText : " + notification.tickerText);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+                Bundle bundle = notification.extras;
+                for (String key : bundle.keySet()) {
+                    Log.i(TAG, key + ": " + bundle.get(key));
+                }
+            }
+        }
+        if (self != null && notificationListener != null) {
+            notificationListener.onNotificationPosted(sbn);
+        }
+    }
+
+
+    @Override
+    public void onNotificationRemoved(StatusBarNotification sbn) {
+        if (self != null && notificationListener != null) {
+            notificationListener.onNotificationRemoved(sbn);
+        }
+    }
+
+    public void printCurrentNotifications() {
+        StatusBarNotification[] ns = getActiveNotifications();
+        for (StatusBarNotification n : ns) {
+            Log.i(TAG, String.format("%20s",n.getPackageName()) + ": " + n.getNotification().tickerText);
+        }
+    }
+
+
+    public static abstract class NotificationListener {
+        public void onServiceCreated(NotificationService service) {}
+
+        public abstract int onServiceStartCommand(NotificationService service, Intent intent, int flags, int startId);
+
+        public void onServiceDestroy() {}
+
+        /**
+         * Implement this method to learn about new notifications as they are posted by apps.
+         *
+         * @param sbn A data structure encapsulating the original {@link Notification}
+         *            object as well as its identifying information (tag and id) and source
+         *            (package name).
+         */
+        public abstract void onNotificationPosted(StatusBarNotification sbn);
+
+        /**
+         * Implement this method to learn when notifications are removed.
+         * <p/>
+         * This might occur because the user has dismissed the notification using system UI (or another
+         * notification listener) or because the app has withdrawn the notification.
+         * <p/>
+         * NOTE: The {@link StatusBarNotification} object you receive will be "light"; that is, the
+         * result from {@link StatusBarNotification#getNotification} may be missing some heavyweight
+         * fields such as {@link Notification#contentView} and
+         * {@link Notification#largeIcon}. However, all other fields on
+         * {@link StatusBarNotification}, sufficient to match this call with a prior call to
+         * {@link #onNotificationPosted(StatusBarNotification)}, will be intact.
+         *
+         * @param sbn A data structure encapsulating at least the original information (tag and id)
+         *            and source (package name) used to post the {@link Notification} that
+         *            was just removed.
+         */
+        public abstract void onNotificationRemoved(StatusBarNotification sbn);
+    }
+}
Index: customfresco/src/main/java/com/scene/customfresco/gestures/TransformGestureDetector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/gestures/TransformGestureDetector.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/gestures/TransformGestureDetector.java	(revision )
@@ -0,0 +1,157 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.scene.customfresco.gestures;
+
+import android.view.MotionEvent;
+
+/**
+ * Component that detects translation, scale and rotation based on touch events.
+ * <p>
+ * This class notifies its listeners whenever a gesture begins, updates or ends.
+ * The instance of this detector is passed to the listeners, so it can be queried
+ * for pivot, translation, scale or rotation.
+ */
+public class TransformGestureDetector implements MultiPointerGestureDetector.Listener {
+
+  /** The listener for receiving notifications when gestures occur. */
+  public interface Listener {
+    /** Responds to the beginning of a gesture. */
+    public void onGestureBegin(TransformGestureDetector detector);
+
+    /** Responds to the update of a gesture in progress. */
+    public void onGestureUpdate(TransformGestureDetector detector);
+
+    /** Responds to the end of a gesture. */
+    public void onGestureEnd(TransformGestureDetector detector);
+  }
+
+  private final MultiPointerGestureDetector mDetector;
+
+  private Listener mListener = null;
+
+  public TransformGestureDetector(MultiPointerGestureDetector multiPointerGestureDetector) {
+    mDetector = multiPointerGestureDetector;
+    mDetector.setListener(this);
+  }
+
+  /** Factory method that creates a new instance of TransformGestureDetector */
+  public static TransformGestureDetector newInstance() {
+    return new TransformGestureDetector(MultiPointerGestureDetector.newInstance());
+  }
+
+  public void setListener(Listener listener) {
+    mListener = listener;
+  }
+
+  /**
+   * Resets the component to the initial state.
+   */
+  public void reset() {
+    mDetector.reset();
+  }
+
+  public boolean onTouchEvent(final MotionEvent event) {
+    return mDetector.onTouchEvent(event);
+  }
+
+  @Override
+  public void onGestureBegin(MultiPointerGestureDetector detector) {
+    if (mListener != null) {
+      mListener.onGestureBegin(this);
+    }
+  }
+
+  @Override
+  public void onGestureUpdate(MultiPointerGestureDetector detector) {
+    if (mListener != null) {
+      mListener.onGestureUpdate(this);
+    }
+  }
+
+  @Override
+  public void onGestureEnd(MultiPointerGestureDetector detector) {
+    if (mListener != null) {
+      mListener.onGestureEnd(this);
+    }
+  }
+
+  private float calcAverage(float[] arr, int len) {
+    float sum = 0;
+    for (int i = 0; i < len; i++) {
+      sum += arr[i];
+    }
+    return (len > 0) ? sum / len : 0;
+  }
+
+  /** Restarts the current gesture */
+  public void restartGesture() {
+    mDetector.restartGesture();
+  }
+
+  /** Gets whether gesture is in progress or not */
+  public boolean isGestureInProgress() {
+    return mDetector.isGestureInProgress();
+  }
+
+  /** Gets the X coordinate of the pivot point */
+  public float getPivotX() {
+    return calcAverage(mDetector.getStartX(), mDetector.getCount());
+  }
+
+  /** Gets the Y coordinate of the pivot point */
+  public float getPivotY() {
+    return calcAverage(mDetector.getStartY(), mDetector.getCount());
+  }
+
+  /** Gets the X component of the translation */
+  public float getTranslationX() {
+    return calcAverage(mDetector.getCurrentX(), mDetector.getCount()) -
+            calcAverage(mDetector.getStartX(), mDetector.getCount());
+  }
+
+  /** Gets the Y component of the translation */
+  public float getTranslationY() {
+    return calcAverage(mDetector.getCurrentY(), mDetector.getCount()) -
+            calcAverage(mDetector.getStartY(), mDetector.getCount());
+  }
+
+  /** Gets the scale */
+  public float getScale() {
+    if (mDetector.getCount() < 2) {
+      return 1;
+    } else {
+      float startDeltaX = mDetector.getStartX()[1] - mDetector.getStartX()[0];
+      float startDeltaY = mDetector.getStartY()[1] - mDetector.getStartY()[0];
+      float currentDeltaX = mDetector.getCurrentX()[1] - mDetector.getCurrentX()[0];
+      float currentDeltaY = mDetector.getCurrentY()[1] - mDetector.getCurrentY()[0];
+      float startDist = (float) Math.hypot(startDeltaX, startDeltaY);
+      float currentDist = (float) Math.hypot(currentDeltaX, currentDeltaY);
+      return currentDist / startDist;
+    }
+  }
+
+  /** Gets the rotation in radians */
+  public float getRotation() {
+    if (mDetector.getCount() < 2) {
+      return 0;
+    } else {
+      float startDeltaX = mDetector.getStartX()[1] - mDetector.getStartX()[0];
+      float startDeltaY = mDetector.getStartY()[1] - mDetector.getStartY()[0];
+      float currentDeltaX = mDetector.getCurrentX()[1] - mDetector.getCurrentX()[0];
+      float currentDeltaY = mDetector.getCurrentY()[1] - mDetector.getCurrentY()[0];
+      float startAngle = (float) Math.atan2(startDeltaY, startDeltaX);
+      float currentAngle = (float) Math.atan2(currentDeltaY, currentDeltaX);
+      return currentAngle - startAngle;
+    }
+  }
+}
\ No newline at end of file
Index: ucrop/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/AndroidManifest.xml	(revision )
+++ ucrop/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,11 @@
+<manifest package="com.yalantis.ucrop"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:supportsRtl="true">
+        <activity
+            android:name="com.yalantis.ucrop.UCropActivity"
+            android:screenOrientation="portrait"/>
+    </application>
+</manifest>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/DisplayUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/DisplayUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/DisplayUtil.java	(revision )
@@ -0,0 +1,41 @@
+package com.scene.common.common.utils;
+
+import android.content.Context;
+import android.util.DisplayMetrics;
+import com.scene.common.android.log.Log;
+
+/**
+ * @author MaTianyu
+ * @date 2015-04-19
+ */
+public class DisplayUtil {
+    private static final String TAG = DisplayUtil.class.getSimpleName();
+
+    /**
+     * 获取 显示信息
+     */
+    public static DisplayMetrics getDisplayMetrics(Context context) {
+        DisplayMetrics dm = context.getResources().getDisplayMetrics();
+        return dm;
+    }
+
+    /**
+     * 打印 显示信息
+     */
+    public static DisplayMetrics printDisplayInfo(Context context) {
+        DisplayMetrics dm = getDisplayMetrics(context);
+        if (Log.isPrint) {
+            StringBuilder sb = new StringBuilder();
+            sb.append("_______  显示信息:  ");
+            sb.append("\ndensity         :").append(dm.density);
+            sb.append("\ndensityDpi      :").append(dm.densityDpi);
+            sb.append("\nheightPixels    :").append(dm.heightPixels);
+            sb.append("\nwidthPixels     :").append(dm.widthPixels);
+            sb.append("\nscaledDensity   :").append(dm.scaledDensity);
+            sb.append("\nxdpi            :").append(dm.xdpi);
+            sb.append("\nydpi            :").append(dm.ydpi);
+            Log.i(TAG, sb.toString());
+        }
+        return dm;
+    }
+}
Index: customfresco/src/main/java/com/scene/customfresco/gestures/MultiPointerGestureDetector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/gestures/MultiPointerGestureDetector.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/gestures/MultiPointerGestureDetector.java	(revision )
@@ -0,0 +1,220 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.scene.customfresco.gestures;
+import android.view.MotionEvent;
+
+/**
+ * Component that detects and tracks multiple pointers based on touch events.
+ * <p>
+ * Each time a pointer gets pressed or released, the current gesture (if any) will end, and a new
+ * one will be started (if there are still pressed pointers left). It is guaranteed that the number
+ * of pointers within the single gesture will remain the same during the whole gesture.
+ */
+public class MultiPointerGestureDetector {
+
+  /** The listener for receiving notifications when gestures occur. */
+  public interface Listener {
+    /** Responds to the beginning of a gesture. */
+    public void onGestureBegin(MultiPointerGestureDetector detector);
+
+    /** Responds to the update of a gesture in progress. */
+    public void onGestureUpdate(MultiPointerGestureDetector detector);
+
+    /** Responds to the end of a gesture. */
+    public void onGestureEnd(MultiPointerGestureDetector detector);
+  }
+
+  private static final int MAX_POINTERS = 2;
+
+  private boolean mGestureInProgress;
+  private int mCount;
+  private final int mId[] = new int[MAX_POINTERS];
+  private final float mStartX[] = new float[MAX_POINTERS];
+  private final float mStartY[] = new float[MAX_POINTERS];
+  private final float mCurrentX[] = new float[MAX_POINTERS];
+  private final float mCurrentY[] = new float[MAX_POINTERS];
+
+  private Listener mListener = null;
+
+  public MultiPointerGestureDetector() {
+    reset();
+  }
+
+  /** Factory method that creates a new instance of MultiPointerGestureDetector */
+  public static MultiPointerGestureDetector newInstance() {
+    return new MultiPointerGestureDetector();
+  }
+
+  public void setListener(Listener listener) {
+    mListener = listener;
+  }
+
+  /**
+   * Resets the component to the initial state.
+   */
+  public void reset() {
+    mGestureInProgress = false;
+    mCount = 0;
+    for (int i = 0; i < MAX_POINTERS; i++) {
+      mId[i] = MotionEvent.INVALID_POINTER_ID;
+    }
+  }
+
+  protected boolean shouldStartGesture() {
+    return true;
+  }
+
+  private void startGesture() {
+    if (!mGestureInProgress) {
+      mGestureInProgress = true;
+      if (mListener != null) {
+        mListener.onGestureBegin(this);
+      }
+    }
+  }
+
+  private void stopGesture() {
+    if (mGestureInProgress) {
+      mGestureInProgress = false;
+      if (mListener != null) {
+        mListener.onGestureEnd(this);
+      }
+    }
+  }
+
+  private int getPressedPointerIndex(MotionEvent event, int i) {
+    final int count = event.getPointerCount();
+    final int action = event.getActionMasked();
+    final int index = event.getActionIndex();
+    if (action == MotionEvent.ACTION_UP ||
+            action == MotionEvent.ACTION_POINTER_UP) {
+      if (i >= index) {
+        i++;
+      }
+    }
+    return (i < count) ? i : -1;
+  }
+
+  public boolean onTouchEvent(final MotionEvent event) {
+    switch (event.getActionMasked()) {
+      case MotionEvent.ACTION_MOVE: {
+        // update pointers
+        for (int i = 0; i < MAX_POINTERS; i++) {
+          int index = event.findPointerIndex(mId[i]);
+          if (index != -1) {
+            mCurrentX[i] = event.getX(index);
+            mCurrentY[i] = event.getY(index);
+          }
+        }
+        // start a new gesture if not already started
+        if (!mGestureInProgress && shouldStartGesture()) {
+          startGesture();
+        }
+        // notify listener
+        if (mGestureInProgress && mListener != null) {
+          mListener.onGestureUpdate(this);
+        }
+        break;
+      }
+
+      case MotionEvent.ACTION_DOWN:
+      case MotionEvent.ACTION_POINTER_DOWN:
+      case MotionEvent.ACTION_POINTER_UP:
+      case MotionEvent.ACTION_UP: {
+        // we'll restart the current gesture (if any) whenever the number of pointers changes
+        // NOTE: we only restart existing gestures here, new gestures are started in ACTION_MOVE
+        boolean wasGestureInProgress = mGestureInProgress;
+        stopGesture();
+        reset();
+        // update pointers
+        for (int i = 0; i < MAX_POINTERS; i++) {
+          int index = getPressedPointerIndex(event, i);
+          if (index == -1) {
+            break;
+          }
+          mId[i] = event.getPointerId(index);
+          mCurrentX[i] = mStartX[i] = event.getX(index);
+          mCurrentY[i] = mStartY[i] = event.getY(index);
+          mCount++;
+        }
+        // restart the gesture (if any) if there are still pointers left
+        if (wasGestureInProgress && mCount > 0) {
+          startGesture();
+        }
+        break;
+      }
+
+      case MotionEvent.ACTION_CANCEL: {
+        stopGesture();
+        reset();
+        break;
+      }
+    }
+    return true;
+  }
+
+  /** Restarts the current gesture */
+  public void restartGesture() {
+    if (!mGestureInProgress) {
+      return;
+    }
+    stopGesture();
+    for (int i = 0; i < MAX_POINTERS; i++) {
+      mStartX[i] = mCurrentX[i];
+      mStartY[i] = mCurrentY[i];
+    }
+    startGesture();
+  }
+
+  /** Gets whether gesture is in progress or not */
+  public boolean isGestureInProgress() {
+    return mGestureInProgress;
+  }
+
+  /** Gets the number of pointers in the current gesture */
+  public int getCount() {
+    return mCount;
+  }
+
+  /**
+   * Gets the start X coordinates for the all pointers
+   * Mutable array is exposed for performance reasons and is not to be modified by the callers.
+   */
+  public float[] getStartX() {
+    return mStartX;
+  }
+
+  /**
+   * Gets the start Y coordinates for the all pointers
+   * Mutable array is exposed for performance reasons and is not to be modified by the callers.
+   */
+  public float[] getStartY() {
+    return mStartY;
+  }
+
+  /**
+   * Gets the current X coordinates for the all pointers
+   * Mutable array is exposed for performance reasons and is not to be modified by the callers.
+   */
+  public float[] getCurrentX() {
+    return mCurrentX;
+  }
+
+  /**
+   * Gets the current Y coordinates for the all pointers
+   * Mutable array is exposed for performance reasons and is not to be modified by the callers.
+   */
+  public float[] getCurrentY() {
+    return mCurrentY;
+  }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/weight/FullyGridLayoutManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/weight/FullyGridLayoutManager.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/weight/FullyGridLayoutManager.java	(revision )
@@ -0,0 +1,129 @@
+package com.scene.mylib.view.weight;
+ 
+import android.content.Context;
+import android.graphics.Rect;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+ 
+public class FullyGridLayoutManager extends GridLayoutManager {
+    private int mwidth = 0;
+    private int mheight = 0;
+ 
+    public FullyGridLayoutManager(Context context, int spanCount) {
+        super(context, spanCount);
+    }
+ 
+    public FullyGridLayoutManager(Context context, int spanCount,
+            int orientation, boolean reverseLayout) {
+        super(context, spanCount, orientation, reverseLayout);
+    }
+ 
+    private int[] mMeasuredDimension = new int[2];
+ 
+    public int getMwidth() {
+        return mwidth;
+    }
+ 
+    public void setMwidth(int mwidth) {
+        this.mwidth = mwidth;
+    }
+ 
+    public int getMheight() {
+        return mheight;
+    }
+ 
+    public void setMheight(int mheight) {
+        this.mheight = mheight;
+    }
+ 
+    @Override
+    public void onMeasure(RecyclerView.Recycler recycler,
+            RecyclerView.State state, int widthSpec, int heightSpec) {
+        final int widthMode = View.MeasureSpec.getMode(widthSpec);
+        final int heightMode = View.MeasureSpec.getMode(heightSpec);
+        final int widthSize = View.MeasureSpec.getSize(widthSpec);
+        final int heightSize = View.MeasureSpec.getSize(heightSpec);
+ 
+        int width = 0;
+        int height = 0;
+        int count = getItemCount();
+        int span = getSpanCount();
+        for (int i = 0; i < count; i++) {
+            measureScrapChild(recycler, i, View.MeasureSpec.makeMeasureSpec(i,
+                    View.MeasureSpec.UNSPECIFIED),
+                    View.MeasureSpec.makeMeasureSpec(i,
+                            View.MeasureSpec.UNSPECIFIED), mMeasuredDimension);
+ 
+            if (getOrientation() == HORIZONTAL) {
+                if (i % span == 0) {
+                    width = width + mMeasuredDimension[0];
+                }
+                if (i == 0) {
+                    height = mMeasuredDimension[1];
+                }
+            } else {
+                if (i % span == 0) {
+                    height = height + mMeasuredDimension[1];
+                }
+                if (i == 0) {
+                    width = mMeasuredDimension[0];
+                }
+            }
+        }
+ 
+        switch (widthMode) {
+        case View.MeasureSpec.EXACTLY:
+            width = widthSize;
+        case View.MeasureSpec.AT_MOST:
+        case View.MeasureSpec.UNSPECIFIED:
+        }
+ 
+        switch (heightMode) {
+        case View.MeasureSpec.EXACTLY:
+            height = heightSize;
+        case View.MeasureSpec.AT_MOST:
+        case View.MeasureSpec.UNSPECIFIED:
+        }
+        setMheight(height);
+        setMwidth(width);
+        setMeasuredDimension(width, height);
+    }
+ 
+    private void measureScrapChild(RecyclerView.Recycler recycler,
+            int position, int widthSpec, int heightSpec, int[] measuredDimension) {
+        if (position < getItemCount()) {
+            try {
+                View view = recycler.getViewForPosition(0);
+                if (view != null) {
+                    this.measureChild(view, 0, 0);
+                    measuredDimension[0] = this.getDecoratedMeasuredWidth(view);
+                    measuredDimension[1] = this.getDecoratedMeasuredHeight(view);
+                    recycler.recycleView(view);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+     
+    public static class SpacesItemDecoration extends RecyclerView.ItemDecoration {
+          private int space;
+ 
+          public SpacesItemDecoration(int space) {
+            this.space = space;
+          }
+ 
+          @Override
+          public void getItemOffsets(Rect outRect, View view, 
+              RecyclerView parent, RecyclerView.State state) {
+            outRect.left = space;
+            outRect.right = space;
+            outRect.bottom = space;
+            outRect.top = space;
+ 
+            // Add top margin only for the first item to avoid double space between items
+//          if(parent.getChildLayoutPosition(view) == 0)
+          }
+        }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/utils/NetworkUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/utils/NetworkUtil.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/utils/NetworkUtil.java	(revision )
@@ -0,0 +1,43 @@
+
+package com.scene.mylib.view.utils;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
+public class NetworkUtil {
+
+    /** 网络不可用 */
+    public static final int NONETWORK = 0;
+    /** 是wifi连接 */
+    public static final int WIFI = 1;
+    /** 不是wifi连接 */
+    public static final int NOWIFI = 2;
+
+    public static int getNetWorkType(Context context) {
+        if (!isNetWorkAvalible(context)) {
+            return NetworkUtil.NONETWORK;
+        }
+        ConnectivityManager cm = (ConnectivityManager) context
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+        // cm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
+        if (cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI).isConnectedOrConnecting())
+            return NetworkUtil.WIFI;
+        else
+            return NetworkUtil.NOWIFI;
+    }
+
+    public static boolean isNetWorkAvalible(Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+        if (cm == null) {
+            return false;
+        }
+        NetworkInfo ni = cm.getActiveNetworkInfo();
+        if (ni == null || !ni.isAvailable()) {
+            return false;
+        }
+        return true;
+    }
+
+}
Index: customfresco/src/androidTest/java/com/scene/customfresco/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/androidTest/java/com/scene/customfresco/ApplicationTest.java	(revision )
+++ customfresco/src/androidTest/java/com/scene/customfresco/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.scene.customfresco;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/SwipeLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/SwipeLayout.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/SwipeLayout.java	(revision )
@@ -0,0 +1,1659 @@
+package com.scene.mylib.view.swipelayout;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Rect;
+import android.support.annotation.Nullable;
+import android.support.v4.view.GravityCompat;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.widget.ViewDragHelper;
+import android.util.AttributeSet;
+import android.view.GestureDetector;
+import android.view.Gravity;
+import android.view.HapticFeedbackConstants;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+import android.widget.AbsListView;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+
+import com.scene.mylib.R;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+public class SwipeLayout extends FrameLayout {
+    @Deprecated
+    public static final int EMPTY_LAYOUT = -1;
+    private static final int DRAG_LEFT = 1;
+    private static final int DRAG_RIGHT = 2;
+    private static final int DRAG_TOP = 4;
+    private static final int DRAG_BOTTOM = 8;
+    private static final DragEdge DefaultDragEdge = DragEdge.Right;
+
+    private int mTouchSlop;
+
+    private DragEdge mCurrentDragEdge = DefaultDragEdge;
+    private ViewDragHelper mDragHelper;
+
+    private int mDragDistance = 0;
+    private LinkedHashMap<DragEdge, View> mDragEdges = new LinkedHashMap<>();
+    private ShowMode mShowMode;
+
+    private float[] mEdgeSwipesOffset = new float[4];
+
+    private List<SwipeListener> mSwipeListeners = new ArrayList<>();
+    private List<SwipeDenier> mSwipeDeniers = new ArrayList<>();
+    private Map<View, ArrayList<OnRevealListener>> mRevealListeners = new HashMap<>();
+    private Map<View, Boolean> mShowEntirely = new HashMap<>();
+    private Map<View, Rect> mViewBoundCache = new HashMap<>();//save all children's bound, restore in onLayout
+
+    private DoubleClickListener mDoubleClickListener;
+
+    private boolean mSwipeEnabled = true;
+    private boolean[] mSwipesEnabled = new boolean[]{true, true, true, true};
+    private boolean mClickToClose = false;
+    private float mWillOpenPercentAfterOpen = 0.75f;
+    private float mWillOpenPercentAfterClose = 0.25f;
+
+    public enum DragEdge {
+        Left,
+        Top,
+        Right,
+        Bottom
+    }
+
+    public enum ShowMode {
+        LayDown,
+        PullOut
+    }
+
+    public SwipeLayout(Context context) {
+        this(context, null);
+    }
+
+    public SwipeLayout(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public SwipeLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        mDragHelper = ViewDragHelper.create(this, mDragHelperCallback);
+        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
+
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SwipeLayout);
+        int dragEdgeChoices = a.getInt(R.styleable.SwipeLayout_drag_edge, DRAG_RIGHT);
+        mEdgeSwipesOffset[DragEdge.Left.ordinal()] = a.getDimension(R.styleable.SwipeLayout_leftEdgeSwipeOffset, 0);
+        mEdgeSwipesOffset[DragEdge.Right.ordinal()] = a.getDimension(R.styleable.SwipeLayout_rightEdgeSwipeOffset, 0);
+        mEdgeSwipesOffset[DragEdge.Top.ordinal()] = a.getDimension(R.styleable.SwipeLayout_topEdgeSwipeOffset, 0);
+        mEdgeSwipesOffset[DragEdge.Bottom.ordinal()] = a.getDimension(R.styleable.SwipeLayout_bottomEdgeSwipeOffset, 0);
+        setClickToClose(a.getBoolean(R.styleable.SwipeLayout_clickToClose, mClickToClose));
+
+        if ((dragEdgeChoices & DRAG_LEFT) == DRAG_LEFT) {
+            mDragEdges.put(DragEdge.Left, null);
+        }
+        if ((dragEdgeChoices & DRAG_TOP) == DRAG_TOP) {
+            mDragEdges.put(DragEdge.Top, null);
+        }
+        if ((dragEdgeChoices & DRAG_RIGHT) == DRAG_RIGHT) {
+            mDragEdges.put(DragEdge.Right, null);
+        }
+        if ((dragEdgeChoices & DRAG_BOTTOM) == DRAG_BOTTOM) {
+            mDragEdges.put(DragEdge.Bottom, null);
+        }
+        int ordinal = a.getInt(R.styleable.SwipeLayout_show_mode, ShowMode.PullOut.ordinal());
+        mShowMode = ShowMode.values()[ordinal];
+        a.recycle();
+
+    }
+
+    public interface SwipeListener {
+        void onStartOpen(SwipeLayout layout);
+
+        void onOpen(SwipeLayout layout);
+
+        void onStartClose(SwipeLayout layout);
+
+        void onClose(SwipeLayout layout);
+
+        void onUpdate(SwipeLayout layout, int leftOffset, int topOffset);
+
+        void onHandRelease(SwipeLayout layout, float xvel, float yvel);
+    }
+
+    public void addSwipeListener(SwipeListener l) {
+        mSwipeListeners.add(l);
+    }
+
+    public void removeSwipeListener(SwipeListener l) {
+        mSwipeListeners.remove(l);
+    }
+
+    public void removeAllSwipeListener() {
+        mSwipeListeners.clear();
+    }
+
+    public interface SwipeDenier {
+        /*
+         * Called in onInterceptTouchEvent Determines if this swipe event should
+         * be denied Implement this interface if you are using views with swipe
+         * gestures As a child of SwipeLayout
+         * 
+         * @return true deny false allow
+         */
+        boolean shouldDenySwipe(MotionEvent ev);
+    }
+
+    public void addSwipeDenier(SwipeDenier denier) {
+        mSwipeDeniers.add(denier);
+    }
+
+    public void removeSwipeDenier(SwipeDenier denier) {
+        mSwipeDeniers.remove(denier);
+    }
+
+    public void removeAllSwipeDeniers() {
+        mSwipeDeniers.clear();
+    }
+
+    public interface OnRevealListener {
+        void onReveal(View child, DragEdge edge, float fraction, int distance);
+    }
+
+    /**
+     * bind a view with a specific
+     *
+     * @param childId the view id.
+     * @param l       the target
+     */
+    public void addRevealListener(int childId, OnRevealListener l) {
+        View child = findViewById(childId);
+        if (child == null) {
+            throw new IllegalArgumentException("Child does not belong to SwipeListener.");
+        }
+
+        if (!mShowEntirely.containsKey(child)) {
+            mShowEntirely.put(child, false);
+        }
+        if (mRevealListeners.get(child) == null)
+            mRevealListeners.put(child, new ArrayList<OnRevealListener>());
+
+        mRevealListeners.get(child).add(l);
+    }
+
+    /**
+     * bind multiple views with an
+     *
+     * @param childIds the view id.
+     * @param l
+     */
+    public void addRevealListener(int[] childIds, OnRevealListener l) {
+        for (int i : childIds)
+            addRevealListener(i, l);
+    }
+
+    public void removeRevealListener(int childId, OnRevealListener l) {
+        View child = findViewById(childId);
+
+        if (child == null) return;
+
+        mShowEntirely.remove(child);
+        if (mRevealListeners.containsKey(child)) mRevealListeners.get(child).remove(l);
+    }
+
+    public void removeAllRevealListeners(int childId) {
+        View child = findViewById(childId);
+        if (child != null) {
+            mRevealListeners.remove(child);
+            mShowEntirely.remove(child);
+        }
+    }
+
+    private ViewDragHelper.Callback mDragHelperCallback = new ViewDragHelper.Callback() {
+
+        @Override
+        public int clampViewPositionHorizontal(View child, int left, int dx) {
+            if (child == getSurfaceView()) {
+                switch (mCurrentDragEdge) {
+                    case Top:
+                    case Bottom:
+                        return getPaddingLeft();
+                    case Left:
+                        if (left < getPaddingLeft()) return getPaddingLeft();
+                        if (left > getPaddingLeft() + mDragDistance)
+                            return getPaddingLeft() + mDragDistance;
+                        break;
+                    case Right:
+                        if (left > getPaddingLeft()) return getPaddingLeft();
+                        if (left < getPaddingLeft() - mDragDistance)
+                            return getPaddingLeft() - mDragDistance;
+                        break;
+                }
+            } else if (getCurrentBottomView() == child) {
+
+                switch (mCurrentDragEdge) {
+                    case Top:
+                    case Bottom:
+                        return getPaddingLeft();
+                    case Left:
+                        if (mShowMode == ShowMode.PullOut) {
+                            if (left > getPaddingLeft()) return getPaddingLeft();
+                        }
+                        break;
+                    case Right:
+                        if (mShowMode == ShowMode.PullOut) {
+                            if (left < getMeasuredWidth() - mDragDistance) {
+                                return getMeasuredWidth() - mDragDistance;
+                            }
+                        }
+                        break;
+                }
+            }
+            return left;
+        }
+
+        @Override
+        public int clampViewPositionVertical(View child, int top, int dy) {
+            if (child == getSurfaceView()) {
+                switch (mCurrentDragEdge) {
+                    case Left:
+                    case Right:
+                        return getPaddingTop();
+                    case Top:
+                        if (top < getPaddingTop()) return getPaddingTop();
+                        if (top > getPaddingTop() + mDragDistance)
+                            return getPaddingTop() + mDragDistance;
+                        break;
+                    case Bottom:
+                        if (top < getPaddingTop() - mDragDistance) {
+                            return getPaddingTop() - mDragDistance;
+                        }
+                        if (top > getPaddingTop()) {
+                            return getPaddingTop();
+                        }
+                }
+            } else {
+                View surfaceView = getSurfaceView();
+                int surfaceViewTop = surfaceView == null ? 0 : surfaceView.getTop();
+                switch (mCurrentDragEdge) {
+                    case Left:
+                    case Right:
+                        return getPaddingTop();
+                    case Top:
+                        if (mShowMode == ShowMode.PullOut) {
+                            if (top > getPaddingTop()) return getPaddingTop();
+                        } else {
+                            if (surfaceViewTop + dy < getPaddingTop())
+                                return getPaddingTop();
+                            if (surfaceViewTop + dy > getPaddingTop() + mDragDistance)
+                                return getPaddingTop() + mDragDistance;
+                        }
+                        break;
+                    case Bottom:
+                        if (mShowMode == ShowMode.PullOut) {
+                            if (top < getMeasuredHeight() - mDragDistance)
+                                return getMeasuredHeight() - mDragDistance;
+                        } else {
+                            if (surfaceViewTop + dy >= getPaddingTop())
+                                return getPaddingTop();
+                            if (surfaceViewTop + dy <= getPaddingTop() - mDragDistance)
+                                return getPaddingTop() - mDragDistance;
+                        }
+                }
+            }
+            return top;
+        }
+
+        @Override
+        public boolean tryCaptureView(View child, int pointerId) {
+            boolean result = child == getSurfaceView() || getBottomViews().contains(child);
+            if (result) {
+                isCloseBeforeDrag = getOpenStatus() == Status.Close;
+            }
+            return result;
+        }
+
+        @Override
+        public int getViewHorizontalDragRange(View child) {
+            return mDragDistance;
+        }
+
+        @Override
+        public int getViewVerticalDragRange(View child) {
+            return mDragDistance;
+        }
+
+        boolean isCloseBeforeDrag = true;
+
+        @Override
+        public void onViewReleased(View releasedChild, float xvel, float yvel) {
+            super.onViewReleased(releasedChild, xvel, yvel);
+            processHandRelease(xvel, yvel, isCloseBeforeDrag);
+            for (SwipeListener l : mSwipeListeners) {
+                l.onHandRelease(SwipeLayout.this, xvel, yvel);
+            }
+
+            invalidate();
+        }
+
+        @Override
+        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
+            View surfaceView = getSurfaceView();
+            if (surfaceView == null) return;
+            View currentBottomView = getCurrentBottomView();
+            int evLeft = surfaceView.getLeft(),
+                    evRight = surfaceView.getRight(),
+                    evTop = surfaceView.getTop(),
+                    evBottom = surfaceView.getBottom();
+            if (changedView == surfaceView) {
+
+                if (mShowMode == ShowMode.PullOut && currentBottomView != null) {
+                    if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
+                        currentBottomView.offsetLeftAndRight(dx);
+                    } else {
+                        currentBottomView.offsetTopAndBottom(dy);
+                    }
+                }
+
+            } else if (getBottomViews().contains(changedView)) {
+
+                if (mShowMode == ShowMode.PullOut) {
+                    surfaceView.offsetLeftAndRight(dx);
+                    surfaceView.offsetTopAndBottom(dy);
+                } else {
+                    Rect rect = computeBottomLayDown(mCurrentDragEdge);
+                    if (currentBottomView != null) {
+                        currentBottomView.layout(rect.left, rect.top, rect.right, rect.bottom);
+                    }
+
+                    int newLeft = surfaceView.getLeft() + dx, newTop = surfaceView.getTop() + dy;
+
+                    if (mCurrentDragEdge == DragEdge.Left && newLeft < getPaddingLeft())
+                        newLeft = getPaddingLeft();
+                    else if (mCurrentDragEdge == DragEdge.Right && newLeft > getPaddingLeft())
+                        newLeft = getPaddingLeft();
+                    else if (mCurrentDragEdge == DragEdge.Top && newTop < getPaddingTop())
+                        newTop = getPaddingTop();
+                    else if (mCurrentDragEdge == DragEdge.Bottom && newTop > getPaddingTop())
+                        newTop = getPaddingTop();
+
+                    surfaceView.layout(newLeft, newTop, newLeft + getMeasuredWidth(), newTop + getMeasuredHeight());
+                }
+            }
+
+            dispatchRevealEvent(evLeft, evTop, evRight, evBottom);
+
+            dispatchSwipeEvent(evLeft, evTop, dx, dy);
+
+            invalidate();
+
+            captureChildrenBound();
+        }
+    };
+
+    /**
+     * save children's bounds, so they can restore the bound in {@link #onLayout(boolean, int, int, int, int)}
+     */
+    private void captureChildrenBound() {
+        View currentBottomView = getCurrentBottomView();
+        if (getOpenStatus() == Status.Close) {
+            mViewBoundCache.remove(currentBottomView);
+            return;
+        }
+
+        View[] views = new View[]{getSurfaceView(), currentBottomView};
+        for (View child : views) {
+            Rect rect = mViewBoundCache.get(child);
+            if (rect == null) {
+                rect = new Rect();
+                mViewBoundCache.put(child, rect);
+            }
+            rect.left = child.getLeft();
+            rect.top = child.getTop();
+            rect.right = child.getRight();
+            rect.bottom = child.getBottom();
+        }
+    }
+
+    /**
+     * the dispatchRevealEvent method may not always get accurate position, it
+     * makes the view may not always get the event when the view is totally
+     * show( fraction = 1), so , we need to calculate every time.
+     */
+    protected boolean isViewTotallyFirstShowed(View child, Rect relativePosition, DragEdge edge, int surfaceLeft,
+                                               int surfaceTop, int surfaceRight, int surfaceBottom) {
+        if (mShowEntirely.get(child)) return false;
+        int childLeft = relativePosition.left;
+        int childRight = relativePosition.right;
+        int childTop = relativePosition.top;
+        int childBottom = relativePosition.bottom;
+        boolean r = false;
+        if (getShowMode() == ShowMode.LayDown) {
+            if ((edge == DragEdge.Right && surfaceRight <= childLeft)
+                    || (edge == DragEdge.Left && surfaceLeft >= childRight)
+                    || (edge == DragEdge.Top && surfaceTop >= childBottom)
+                    || (edge == DragEdge.Bottom && surfaceBottom <= childTop)) r = true;
+        } else if (getShowMode() == ShowMode.PullOut) {
+            if ((edge == DragEdge.Right && childRight <= getWidth())
+                    || (edge == DragEdge.Left && childLeft >= getPaddingLeft())
+                    || (edge == DragEdge.Top && childTop >= getPaddingTop())
+                    || (edge == DragEdge.Bottom && childBottom <= getHeight())) r = true;
+        }
+        return r;
+    }
+
+    protected boolean isViewShowing(View child, Rect relativePosition, DragEdge availableEdge, int surfaceLeft,
+                                    int surfaceTop, int surfaceRight, int surfaceBottom) {
+        int childLeft = relativePosition.left;
+        int childRight = relativePosition.right;
+        int childTop = relativePosition.top;
+        int childBottom = relativePosition.bottom;
+        if (getShowMode() == ShowMode.LayDown) {
+            switch (availableEdge) {
+                case Right:
+                    if (surfaceRight > childLeft && surfaceRight <= childRight) {
+                        return true;
+                    }
+                    break;
+                case Left:
+                    if (surfaceLeft < childRight && surfaceLeft >= childLeft) {
+                        return true;
+                    }
+                    break;
+                case Top:
+                    if (surfaceTop >= childTop && surfaceTop < childBottom) {
+                        return true;
+                    }
+                    break;
+                case Bottom:
+                    if (surfaceBottom > childTop && surfaceBottom <= childBottom) {
+                        return true;
+                    }
+                    break;
+            }
+        } else if (getShowMode() == ShowMode.PullOut) {
+            switch (availableEdge) {
+                case Right:
+                    if (childLeft <= getWidth() && childRight > getWidth()) return true;
+                    break;
+                case Left:
+                    if (childRight >= getPaddingLeft() && childLeft < getPaddingLeft()) return true;
+                    break;
+                case Top:
+                    if (childTop < getPaddingTop() && childBottom >= getPaddingTop()) return true;
+                    break;
+                case Bottom:
+                    if (childTop < getHeight() && childTop >= getPaddingTop()) return true;
+                    break;
+            }
+        }
+        return false;
+    }
+
+    protected Rect getRelativePosition(View child) {
+        View t = child;
+        Rect r = new Rect(t.getLeft(), t.getTop(), 0, 0);
+        while (t.getParent() != null && t != getRootView()) {
+            t = (View) t.getParent();
+            if (t == this) break;
+            r.left += t.getLeft();
+            r.top += t.getTop();
+        }
+        r.right = r.left + child.getMeasuredWidth();
+        r.bottom = r.top + child.getMeasuredHeight();
+        return r;
+    }
+
+    private int mEventCounter = 0;
+
+    protected void dispatchSwipeEvent(int surfaceLeft, int surfaceTop, int dx, int dy) {
+        DragEdge edge = getDragEdge();
+        boolean open = true;
+        if (edge == DragEdge.Left) {
+            if (dx < 0) open = false;
+        } else if (edge == DragEdge.Right) {
+            if (dx > 0) open = false;
+        } else if (edge == DragEdge.Top) {
+            if (dy < 0) open = false;
+        } else if (edge == DragEdge.Bottom) {
+            if (dy > 0) open = false;
+        }
+
+        dispatchSwipeEvent(surfaceLeft, surfaceTop, open);
+    }
+
+    protected void dispatchSwipeEvent(int surfaceLeft, int surfaceTop, boolean open) {
+        safeBottomView();
+        Status status = getOpenStatus();
+
+        if (!mSwipeListeners.isEmpty()) {
+            mEventCounter++;
+            for (SwipeListener l : mSwipeListeners) {
+                if (mEventCounter == 1) {
+                    if (open) {
+                        l.onStartOpen(this);
+                    } else {
+                        l.onStartClose(this);
+                    }
+                }
+                l.onUpdate(SwipeLayout.this, surfaceLeft - getPaddingLeft(), surfaceTop - getPaddingTop());
+            }
+
+            if (status == Status.Close) {
+                for (SwipeListener l : mSwipeListeners) {
+                    l.onClose(SwipeLayout.this);
+                }
+                mEventCounter = 0;
+            }
+
+            if (status == Status.Open) {
+                View currentBottomView = getCurrentBottomView();
+                if (currentBottomView != null) {
+                    currentBottomView.setEnabled(true);
+                }
+                for (SwipeListener l : mSwipeListeners) {
+                    l.onOpen(SwipeLayout.this);
+                }
+                mEventCounter = 0;
+            }
+        }
+    }
+
+    /**
+     * prevent bottom view get any touch event. Especially in LayDown mode.
+     */
+    private void safeBottomView() {
+        Status status = getOpenStatus();
+        List<View> bottoms = getBottomViews();
+
+        if (status == Status.Close) {
+            for (View bottom : bottoms) {
+                if (bottom != null && bottom.getVisibility() != INVISIBLE) {
+                    bottom.setVisibility(INVISIBLE);
+                }
+            }
+        } else {
+            View currentBottomView = getCurrentBottomView();
+            if (currentBottomView != null && currentBottomView.getVisibility() != VISIBLE) {
+                currentBottomView.setVisibility(VISIBLE);
+            }
+        }
+    }
+
+    protected void dispatchRevealEvent(final int surfaceLeft, final int surfaceTop, final int surfaceRight,
+                                       final int surfaceBottom) {
+        if (mRevealListeners.isEmpty()) return;
+        for (Map.Entry<View, ArrayList<OnRevealListener>> entry : mRevealListeners.entrySet()) {
+            View child = entry.getKey();
+            Rect rect = getRelativePosition(child);
+            if (isViewShowing(child, rect, mCurrentDragEdge, surfaceLeft, surfaceTop,
+                    surfaceRight, surfaceBottom)) {
+                mShowEntirely.put(child, false);
+                int distance = 0;
+                float fraction = 0f;
+                if (getShowMode() == ShowMode.LayDown) {
+                    switch (mCurrentDragEdge) {
+                        case Left:
+                            distance = rect.left - surfaceLeft;
+                            fraction = distance / (float) child.getWidth();
+                            break;
+                        case Right:
+                            distance = rect.right - surfaceRight;
+                            fraction = distance / (float) child.getWidth();
+                            break;
+                        case Top:
+                            distance = rect.top - surfaceTop;
+                            fraction = distance / (float) child.getHeight();
+                            break;
+                        case Bottom:
+                            distance = rect.bottom - surfaceBottom;
+                            fraction = distance / (float) child.getHeight();
+                            break;
+                    }
+                } else if (getShowMode() == ShowMode.PullOut) {
+                    switch (mCurrentDragEdge) {
+                        case Left:
+                            distance = rect.right - getPaddingLeft();
+                            fraction = distance / (float) child.getWidth();
+                            break;
+                        case Right:
+                            distance = rect.left - getWidth();
+                            fraction = distance / (float) child.getWidth();
+                            break;
+                        case Top:
+                            distance = rect.bottom - getPaddingTop();
+                            fraction = distance / (float) child.getHeight();
+                            break;
+                        case Bottom:
+                            distance = rect.top - getHeight();
+                            fraction = distance / (float) child.getHeight();
+                            break;
+                    }
+                }
+
+                for (OnRevealListener l : entry.getValue()) {
+                    l.onReveal(child, mCurrentDragEdge, Math.abs(fraction), distance);
+                    if (Math.abs(fraction) == 1) {
+                        mShowEntirely.put(child, true);
+                    }
+                }
+            }
+
+            if (isViewTotallyFirstShowed(child, rect, mCurrentDragEdge, surfaceLeft, surfaceTop,
+                    surfaceRight, surfaceBottom)) {
+                mShowEntirely.put(child, true);
+                for (OnRevealListener l : entry.getValue()) {
+                    if (mCurrentDragEdge == DragEdge.Left
+                            || mCurrentDragEdge == DragEdge.Right)
+                        l.onReveal(child, mCurrentDragEdge, 1, child.getWidth());
+                    else
+                        l.onReveal(child, mCurrentDragEdge, 1, child.getHeight());
+                }
+            }
+
+        }
+    }
+
+    @Override
+    public void computeScroll() {
+        super.computeScroll();
+        if (mDragHelper.continueSettling(true)) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    /**
+     * {@link OnLayoutChangeListener} added in API 11. I need
+     * to support it from API 8.
+     */
+    public interface OnLayout {
+        void onLayout(SwipeLayout v);
+    }
+
+    private List<OnLayout> mOnLayoutListeners;
+
+    public void addOnLayoutListener(OnLayout l) {
+        if (mOnLayoutListeners == null) mOnLayoutListeners = new ArrayList<OnLayout>();
+        mOnLayoutListeners.add(l);
+    }
+
+    public void removeOnLayoutListener(OnLayout l) {
+        if (mOnLayoutListeners != null) mOnLayoutListeners.remove(l);
+    }
+
+    public void clearDragEdge() {
+        mDragEdges.clear();
+    }
+
+    public void setDrag(DragEdge dragEdge, int childId) {
+        clearDragEdge();
+        addDrag(dragEdge, childId);
+    }
+
+    public void setDrag(DragEdge dragEdge, View child) {
+        clearDragEdge();
+        addDrag(dragEdge, child);
+    }
+
+    public void addDrag(DragEdge dragEdge, int childId) {
+        addDrag(dragEdge, findViewById(childId), null);
+    }
+
+    public void addDrag(DragEdge dragEdge, View child) {
+        addDrag(dragEdge, child, null);
+    }
+
+    public void addDrag(DragEdge dragEdge, View child, ViewGroup.LayoutParams params) {
+        if (child == null) return;
+
+        if (params == null) {
+            params = generateDefaultLayoutParams();
+        }
+        if (!checkLayoutParams(params)) {
+            params = generateLayoutParams(params);
+        }
+        int gravity = -1;
+        switch (dragEdge) {
+            case Left:
+                gravity = Gravity.LEFT;
+                break;
+            case Right:
+                gravity = Gravity.RIGHT;
+                break;
+            case Top:
+                gravity = Gravity.TOP;
+                break;
+            case Bottom:
+                gravity = Gravity.BOTTOM;
+                break;
+        }
+        if (params instanceof LayoutParams) {
+            ((LayoutParams) params).gravity = gravity;
+        }
+        addView(child, 0, params);
+    }
+
+    @Override
+    public void addView(View child, int index, ViewGroup.LayoutParams params) {
+        if (child == null) return;
+        int gravity = Gravity.NO_GRAVITY;
+        try {
+            gravity = (Integer) params.getClass().getField("gravity").get(params);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        if (gravity > 0) {
+            gravity = GravityCompat.getAbsoluteGravity(gravity, ViewCompat.getLayoutDirection(this));
+
+            if ((gravity & Gravity.LEFT) == Gravity.LEFT) {
+                mDragEdges.put(DragEdge.Left, child);
+            }
+            if ((gravity & Gravity.RIGHT) == Gravity.RIGHT) {
+                mDragEdges.put(DragEdge.Right, child);
+            }
+            if ((gravity & Gravity.TOP) == Gravity.TOP) {
+                mDragEdges.put(DragEdge.Top, child);
+            }
+            if ((gravity & Gravity.BOTTOM) == Gravity.BOTTOM) {
+                mDragEdges.put(DragEdge.Bottom, child);
+            }
+        } else {
+            for (Map.Entry<DragEdge, View> entry : mDragEdges.entrySet()) {
+                if (entry.getValue() == null) {
+                    //means used the drag_edge attr, the no gravity child should be use set
+                    mDragEdges.put(entry.getKey(), child);
+                    break;
+                }
+            }
+        }
+        if (child.getParent() == this) {
+            return;
+        }
+        super.addView(child, index, params);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        updateBottomViews();
+
+        if (mOnLayoutListeners != null) for (int i = 0; i < mOnLayoutListeners.size(); i++) {
+            mOnLayoutListeners.get(i).onLayout(this);
+        }
+    }
+
+    void layoutPullOut() {
+        View surfaceView = getSurfaceView();
+        Rect surfaceRect = mViewBoundCache.get(surfaceView);
+        if (surfaceRect == null) surfaceRect = computeSurfaceLayoutArea(false);
+        if (surfaceView != null) {
+            surfaceView.layout(surfaceRect.left, surfaceRect.top, surfaceRect.right, surfaceRect.bottom);
+            bringChildToFront(surfaceView);
+        }
+        View currentBottomView = getCurrentBottomView();
+        Rect bottomViewRect = mViewBoundCache.get(currentBottomView);
+        if (bottomViewRect == null)
+            bottomViewRect = computeBottomLayoutAreaViaSurface(ShowMode.PullOut, surfaceRect);
+        if (currentBottomView != null) {
+            currentBottomView.layout(bottomViewRect.left, bottomViewRect.top, bottomViewRect.right, bottomViewRect.bottom);
+        }
+    }
+
+    void layoutLayDown() {
+        View surfaceView = getSurfaceView();
+        Rect surfaceRect = mViewBoundCache.get(surfaceView);
+        if (surfaceRect == null) surfaceRect = computeSurfaceLayoutArea(false);
+        if (surfaceView != null) {
+            surfaceView.layout(surfaceRect.left, surfaceRect.top, surfaceRect.right, surfaceRect.bottom);
+            bringChildToFront(surfaceView);
+        }
+        View currentBottomView = getCurrentBottomView();
+        Rect bottomViewRect = mViewBoundCache.get(currentBottomView);
+        if (bottomViewRect == null)
+            bottomViewRect = computeBottomLayoutAreaViaSurface(ShowMode.LayDown, surfaceRect);
+        if (currentBottomView != null) {
+            currentBottomView.layout(bottomViewRect.left, bottomViewRect.top, bottomViewRect.right, bottomViewRect.bottom);
+        }
+    }
+
+    private boolean mIsBeingDragged;
+
+    private void checkCanDrag(MotionEvent ev) {
+        if (mIsBeingDragged) return;
+        if (getOpenStatus() == Status.Middle) {
+            mIsBeingDragged = true;
+            return;
+        }
+        Status status = getOpenStatus();
+        float distanceX = ev.getRawX() - sX;
+        float distanceY = ev.getRawY() - sY;
+        float angle = Math.abs(distanceY / distanceX);
+        angle = (float) Math.toDegrees(Math.atan(angle));
+        if (getOpenStatus() == Status.Close) {
+            DragEdge dragEdge;
+            if (angle < 45) {
+                if (distanceX > 0 && isLeftSwipeEnabled()) {
+                    dragEdge = DragEdge.Left;
+                } else if (distanceX < 0 && isRightSwipeEnabled()) {
+                    dragEdge = DragEdge.Right;
+                } else return;
+
+            } else {
+                if (distanceY > 0 && isTopSwipeEnabled()) {
+                    dragEdge = DragEdge.Top;
+                } else if (distanceY < 0 && isBottomSwipeEnabled()) {
+                    dragEdge = DragEdge.Bottom;
+                } else return;
+            }
+            setCurrentDragEdge(dragEdge);
+        }
+
+        boolean doNothing = false;
+        if (mCurrentDragEdge == DragEdge.Right) {
+            boolean suitable = (status == Status.Open && distanceX > mTouchSlop)
+                    || (status == Status.Close && distanceX < -mTouchSlop);
+            suitable = suitable || (status == Status.Middle);
+
+            if (angle > 30 || !suitable) {
+                doNothing = true;
+            }
+        }
+
+        if (mCurrentDragEdge == DragEdge.Left) {
+            boolean suitable = (status == Status.Open && distanceX < -mTouchSlop)
+                    || (status == Status.Close && distanceX > mTouchSlop);
+            suitable = suitable || status == Status.Middle;
+
+            if (angle > 30 || !suitable) {
+                doNothing = true;
+            }
+        }
+
+        if (mCurrentDragEdge == DragEdge.Top) {
+            boolean suitable = (status == Status.Open && distanceY < -mTouchSlop)
+                    || (status == Status.Close && distanceY > mTouchSlop);
+            suitable = suitable || status == Status.Middle;
+
+            if (angle < 60 || !suitable) {
+                doNothing = true;
+            }
+        }
+
+        if (mCurrentDragEdge == DragEdge.Bottom) {
+            boolean suitable = (status == Status.Open && distanceY > mTouchSlop)
+                    || (status == Status.Close && distanceY < -mTouchSlop);
+            suitable = suitable || status == Status.Middle;
+
+            if (angle < 60 || !suitable) {
+                doNothing = true;
+            }
+        }
+        mIsBeingDragged = !doNothing;
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        if (!isSwipeEnabled()) {
+            return false;
+        }
+        if (mClickToClose && getOpenStatus() == Status.Open && isTouchOnSurface(ev)) {
+            return true;
+        }
+        for (SwipeDenier denier : mSwipeDeniers) {
+            if (denier != null && denier.shouldDenySwipe(ev)) {
+                return false;
+            }
+        }
+
+        switch (ev.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                mDragHelper.processTouchEvent(ev);
+                mIsBeingDragged = false;
+                sX = ev.getRawX();
+                sY = ev.getRawY();
+                //if the swipe is in middle state(scrolling), should intercept the touch
+                if (getOpenStatus() == Status.Middle) {
+                    mIsBeingDragged = true;
+                }
+                break;
+            case MotionEvent.ACTION_MOVE:
+                boolean beforeCheck = mIsBeingDragged;
+                checkCanDrag(ev);
+                if (mIsBeingDragged) {
+                    ViewParent parent = getParent();
+                    if (parent != null) {
+                        parent.requestDisallowInterceptTouchEvent(true);
+                    }
+                }
+                if (!beforeCheck && mIsBeingDragged) {
+                    //let children has one chance to catch the touch, and request the swipe not intercept
+                    //useful when swipeLayout wrap a swipeLayout or other gestural layout
+                    return false;
+                }
+                break;
+
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                mIsBeingDragged = false;
+                mDragHelper.processTouchEvent(ev);
+                break;
+            default://handle other action, such as ACTION_POINTER_DOWN/UP
+                mDragHelper.processTouchEvent(ev);
+        }
+        return mIsBeingDragged;
+    }
+
+    private float sX = -1, sY = -1;
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (!isSwipeEnabled()) return super.onTouchEvent(event);
+
+        int action = event.getActionMasked();
+        gestureDetector.onTouchEvent(event);
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                mDragHelper.processTouchEvent(event);
+                sX = event.getRawX();
+                sY = event.getRawY();
+
+
+            case MotionEvent.ACTION_MOVE: {
+                //the drag state and the direction are already judged at onInterceptTouchEvent
+                checkCanDrag(event);
+                if (mIsBeingDragged) {
+                    getParent().requestDisallowInterceptTouchEvent(true);
+                    mDragHelper.processTouchEvent(event);
+                }
+                break;
+            }
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL:
+                mIsBeingDragged = false;
+                mDragHelper.processTouchEvent(event);
+                break;
+
+            default://handle other action, such as ACTION_POINTER_DOWN/UP
+                mDragHelper.processTouchEvent(event);
+        }
+
+        return super.onTouchEvent(event) || mIsBeingDragged || action == MotionEvent.ACTION_DOWN;
+    }
+
+    public boolean isClickToClose() {
+        return mClickToClose;
+    }
+
+    public void setClickToClose(boolean mClickToClose) {
+        this.mClickToClose = mClickToClose;
+    }
+
+    public void setSwipeEnabled(boolean enabled) {
+        mSwipeEnabled = enabled;
+    }
+
+    public boolean isSwipeEnabled() {
+        return mSwipeEnabled;
+    }
+
+    public boolean isLeftSwipeEnabled() {
+        View bottomView = mDragEdges.get(DragEdge.Left);
+        return bottomView != null && bottomView.getParent() == this
+                && bottomView != getSurfaceView() && mSwipesEnabled[DragEdge.Left.ordinal()];
+    }
+
+    public void setLeftSwipeEnabled(boolean leftSwipeEnabled) {
+        this.mSwipesEnabled[DragEdge.Left.ordinal()] = leftSwipeEnabled;
+    }
+
+    public boolean isRightSwipeEnabled() {
+        View bottomView = mDragEdges.get(DragEdge.Right);
+        return bottomView != null && bottomView.getParent() == this
+                && bottomView != getSurfaceView() && mSwipesEnabled[DragEdge.Right.ordinal()];
+    }
+
+    public void setRightSwipeEnabled(boolean rightSwipeEnabled) {
+        this.mSwipesEnabled[DragEdge.Right.ordinal()] = rightSwipeEnabled;
+    }
+
+    public boolean isTopSwipeEnabled() {
+        View bottomView = mDragEdges.get(DragEdge.Top);
+        return bottomView != null && bottomView.getParent() == this
+                && bottomView != getSurfaceView() && mSwipesEnabled[DragEdge.Top.ordinal()];
+    }
+
+    public void setTopSwipeEnabled(boolean topSwipeEnabled) {
+        this.mSwipesEnabled[DragEdge.Top.ordinal()] = topSwipeEnabled;
+    }
+
+    public boolean isBottomSwipeEnabled() {
+        View bottomView = mDragEdges.get(DragEdge.Bottom);
+        return bottomView != null && bottomView.getParent() == this
+                && bottomView != getSurfaceView() && mSwipesEnabled[DragEdge.Bottom.ordinal()];
+    }
+
+    public void setBottomSwipeEnabled(boolean bottomSwipeEnabled) {
+        this.mSwipesEnabled[DragEdge.Bottom.ordinal()] = bottomSwipeEnabled;
+    }
+
+    /***
+     * Returns the percentage of revealing at which the view below should the view finish opening
+     * if it was already open before dragging
+     *
+     * @returns The percentage of view revealed to trigger, default value is 0.25
+     */
+    public float getWillOpenPercentAfterOpen() {
+        return mWillOpenPercentAfterOpen;
+    }
+
+    /***
+     * Allows to stablish at what percentage of revealing the view below should the view finish opening
+     * if it was already open before dragging
+     *
+     * @param willOpenPercentAfterOpen The percentage of view revealed to trigger, default value is 0.25
+     */
+    public void setWillOpenPercentAfterOpen(float willOpenPercentAfterOpen) {
+        this.mWillOpenPercentAfterOpen = willOpenPercentAfterOpen;
+    }
+
+    /***
+     * Returns the percentage of revealing at which the view below should the view finish opening
+     * if it was already closed before dragging
+     *
+     * @returns The percentage of view revealed to trigger, default value is 0.25
+     */
+    public float getWillOpenPercentAfterClose() {
+        return mWillOpenPercentAfterClose;
+    }
+
+    /***
+     * Allows to stablish at what percentage of revealing the view below should the view finish opening
+     * if it was already closed before dragging
+     *
+     * @param willOpenPercentAfterClose The percentage of view revealed to trigger, default value is 0.75
+     */
+    public void setWillOpenPercentAfterClose(float willOpenPercentAfterClose) {
+        this.mWillOpenPercentAfterClose = willOpenPercentAfterClose;
+    }
+
+    private boolean insideAdapterView() {
+        return getAdapterView() != null;
+    }
+
+    private AdapterView getAdapterView() {
+        ViewParent t = getParent();
+        if (t instanceof AdapterView) {
+            return (AdapterView) t;
+        }
+        return null;
+    }
+
+    private void performAdapterViewItemClick() {
+        if (getOpenStatus() != Status.Close) return;
+        ViewParent t = getParent();
+        if (t instanceof AdapterView) {
+            AdapterView view = (AdapterView) t;
+            int p = view.getPositionForView(SwipeLayout.this);
+            if (p != AdapterView.INVALID_POSITION) {
+                view.performItemClick(view.getChildAt(p - view.getFirstVisiblePosition()), p, view
+                        .getAdapter().getItemId(p));
+            }
+        }
+    }
+
+    private boolean performAdapterViewItemLongClick() {
+        if (getOpenStatus() != Status.Close) return false;
+        ViewParent t = getParent();
+        if (t instanceof AdapterView) {
+            AdapterView view = (AdapterView) t;
+            int p = view.getPositionForView(SwipeLayout.this);
+            if (p == AdapterView.INVALID_POSITION) return false;
+            long vId = view.getItemIdAtPosition(p);
+            boolean handled = false;
+            try {
+                Method m = AbsListView.class.getDeclaredMethod("performLongPress", View.class, int.class, long.class);
+                m.setAccessible(true);
+                handled = (boolean) m.invoke(view, SwipeLayout.this, p, vId);
+
+            } catch (Exception e) {
+                e.printStackTrace();
+
+                if (view.getOnItemLongClickListener() != null) {
+                    handled = view.getOnItemLongClickListener().onItemLongClick(view, SwipeLayout.this, p, vId);
+                }
+                if (handled) {
+                    view.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+                }
+            }
+            return handled;
+        }
+        return false;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (insideAdapterView()) {
+            if (clickListener == null) {
+                setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        performAdapterViewItemClick();
+                    }
+                });
+            }
+            if (longClickListener == null) {
+                setOnLongClickListener(new OnLongClickListener() {
+                    @Override
+                    public boolean onLongClick(View v) {
+                        performAdapterViewItemLongClick();
+                        return true;
+                    }
+                });
+            }
+        }
+    }
+
+    OnClickListener clickListener;
+
+    @Override
+    public void setOnClickListener(OnClickListener l) {
+        super.setOnClickListener(l);
+        clickListener = l;
+    }
+
+    OnLongClickListener longClickListener;
+
+    @Override
+    public void setOnLongClickListener(OnLongClickListener l) {
+        super.setOnLongClickListener(l);
+        longClickListener = l;
+    }
+
+    private Rect hitSurfaceRect;
+
+    private boolean isTouchOnSurface(MotionEvent ev) {
+        View surfaceView = getSurfaceView();
+        if (surfaceView == null) {
+            return false;
+        }
+        if (hitSurfaceRect == null) {
+            hitSurfaceRect = new Rect();
+        }
+        surfaceView.getHitRect(hitSurfaceRect);
+        return hitSurfaceRect.contains((int) ev.getX(), (int) ev.getY());
+    }
+
+    private GestureDetector gestureDetector = new GestureDetector(getContext(), new SwipeDetector());
+
+    class SwipeDetector extends GestureDetector.SimpleOnGestureListener {
+        @Override
+        public boolean onSingleTapUp(MotionEvent e) {
+            if (mClickToClose && isTouchOnSurface(e)) {
+                close();
+            }
+            return super.onSingleTapUp(e);
+        }
+
+        @Override
+        public boolean onDoubleTap(MotionEvent e) {
+            if (mDoubleClickListener != null) {
+                View target;
+                View bottom = getCurrentBottomView();
+                View surface = getSurfaceView();
+                if (bottom != null && e.getX() > bottom.getLeft() && e.getX() < bottom.getRight()
+                        && e.getY() > bottom.getTop() && e.getY() < bottom.getBottom()) {
+                    target = bottom;
+                } else {
+                    target = surface;
+                }
+                mDoubleClickListener.onDoubleClick(SwipeLayout.this, target == surface);
+            }
+            return true;
+        }
+    }
+
+    /**
+     * set the drag distance, it will force set the bottom view's width or
+     * height via this value.
+     *
+     * @param max max distance in dp unit
+     */
+    public void setDragDistance(int max) {
+        if (max < 0) max = 0;
+        mDragDistance = dp2px(max);
+        requestLayout();
+    }
+
+    /**
+     * There are 2 diffirent show mode.
+     *
+     * @param mode
+     */
+    public void setShowMode(ShowMode mode) {
+        mShowMode = mode;
+        requestLayout();
+    }
+
+    public DragEdge getDragEdge() {
+        return mCurrentDragEdge;
+    }
+
+    public int getDragDistance() {
+        return mDragDistance;
+    }
+
+    public ShowMode getShowMode() {
+        return mShowMode;
+    }
+
+    /**
+     * return null if there is no surface view(no children)
+     */
+    public View getSurfaceView() {
+        if (getChildCount() == 0) return null;
+        return getChildAt(getChildCount() - 1);
+    }
+
+    /**
+     * return null if there is no bottom view
+     */
+    @Nullable
+    public View getCurrentBottomView() {
+        List<View> bottoms = getBottomViews();
+        if (mCurrentDragEdge.ordinal() < bottoms.size()) {
+            return bottoms.get(mCurrentDragEdge.ordinal());
+        }
+        return null;
+    }
+
+    /**
+     * @return all bottomViews: left, top, right, bottom (may null if the edge is not set)
+     */
+    public List<View> getBottomViews() {
+        ArrayList<View> bottoms = new ArrayList<View>();
+        for (DragEdge dragEdge : DragEdge.values()) {
+            bottoms.add(mDragEdges.get(dragEdge));
+        }
+        return bottoms;
+    }
+
+    public enum Status {
+        Middle,
+        Open,
+        Close
+    }
+
+    /**
+     * get the open status.
+     *
+     * @return Open , Close or
+     * Middle.
+     */
+    public Status getOpenStatus() {
+        View surfaceView = getSurfaceView();
+        if (surfaceView == null) {
+            return Status.Close;
+        }
+        int surfaceLeft = surfaceView.getLeft();
+        int surfaceTop = surfaceView.getTop();
+        if (surfaceLeft == getPaddingLeft() && surfaceTop == getPaddingTop()) return Status.Close;
+
+        if (surfaceLeft == (getPaddingLeft() - mDragDistance) || surfaceLeft == (getPaddingLeft() + mDragDistance)
+                || surfaceTop == (getPaddingTop() - mDragDistance) || surfaceTop == (getPaddingTop() + mDragDistance))
+            return Status.Open;
+
+        return Status.Middle;
+    }
+
+
+    /**
+     * Process the surface release event.
+     *
+     * @param xvel                 xVelocity
+     * @param yvel                 yVelocity
+     * @param isCloseBeforeDragged the open state before drag
+     */
+    protected void processHandRelease(float xvel, float yvel, boolean isCloseBeforeDragged) {
+        float minVelocity = mDragHelper.getMinVelocity();
+        View surfaceView = getSurfaceView();
+        DragEdge currentDragEdge = mCurrentDragEdge;
+        if (currentDragEdge == null || surfaceView == null) {
+            return;
+        }
+        float willOpenPercent = (isCloseBeforeDragged ? mWillOpenPercentAfterClose : mWillOpenPercentAfterOpen);
+        if (currentDragEdge == DragEdge.Left) {
+            if (xvel > minVelocity) open();
+            else if (xvel < -minVelocity) close();
+            else {
+                float openPercent = 1f * getSurfaceView().getLeft() / mDragDistance;
+                if (openPercent > willOpenPercent) open();
+                else close();
+            }
+        } else if (currentDragEdge == DragEdge.Right) {
+            if (xvel > minVelocity) close();
+            else if (xvel < -minVelocity) open();
+            else {
+                float openPercent = 1f * (-getSurfaceView().getLeft()) / mDragDistance;
+                if (openPercent > willOpenPercent) open();
+                else close();
+            }
+        } else if (currentDragEdge == DragEdge.Top) {
+            if (yvel > minVelocity) open();
+            else if (yvel < -minVelocity) close();
+            else {
+                float openPercent = 1f * getSurfaceView().getTop() / mDragDistance;
+                if (openPercent > willOpenPercent) open();
+                else close();
+            }
+        } else if (currentDragEdge == DragEdge.Bottom) {
+            if (yvel > minVelocity) close();
+            else if (yvel < -minVelocity) open();
+            else {
+                float openPercent = 1f * (-getSurfaceView().getTop()) / mDragDistance;
+                if (openPercent > willOpenPercent) open();
+                else close();
+            }
+        }
+    }
+
+    /**
+     * smoothly open surface.
+     */
+    public void open() {
+        open(true, true);
+    }
+
+    public void open(boolean smooth) {
+        open(smooth, true);
+    }
+
+    public void open(boolean smooth, boolean notify) {
+        View surface = getSurfaceView(), bottom = getCurrentBottomView();
+        if (surface == null) {
+            return;
+        }
+        int dx, dy;
+        Rect rect = computeSurfaceLayoutArea(true);
+        if (smooth) {
+            mDragHelper.smoothSlideViewTo(surface, rect.left, rect.top);
+        } else {
+            dx = rect.left - surface.getLeft();
+            dy = rect.top - surface.getTop();
+            surface.layout(rect.left, rect.top, rect.right, rect.bottom);
+            if (getShowMode() == ShowMode.PullOut) {
+                Rect bRect = computeBottomLayoutAreaViaSurface(ShowMode.PullOut, rect);
+                if (bottom != null) {
+                    bottom.layout(bRect.left, bRect.top, bRect.right, bRect.bottom);
+                }
+            }
+            if (notify) {
+                dispatchRevealEvent(rect.left, rect.top, rect.right, rect.bottom);
+                dispatchSwipeEvent(rect.left, rect.top, dx, dy);
+            } else {
+                safeBottomView();
+            }
+        }
+        invalidate();
+    }
+
+    public void open(DragEdge edge) {
+        setCurrentDragEdge(edge);
+        open(true, true);
+    }
+
+    public void open(boolean smooth, DragEdge edge) {
+        setCurrentDragEdge(edge);
+        open(smooth, true);
+    }
+
+    public void open(boolean smooth, boolean notify, DragEdge edge) {
+        setCurrentDragEdge(edge);
+        open(smooth, notify);
+    }
+
+    /**
+     * smoothly close surface.
+     */
+    public void close() {
+        close(true, true);
+    }
+
+    public void close(boolean smooth) {
+        close(smooth, true);
+    }
+
+    /**
+     * close surface
+     *
+     * @param smooth smoothly or not.
+     * @param notify if notify all the listeners.
+     */
+    public void close(boolean smooth, boolean notify) {
+        View surface = getSurfaceView();
+        if (surface == null) {
+            return;
+        }
+        int dx, dy;
+        if (smooth)
+            mDragHelper.smoothSlideViewTo(getSurfaceView(), getPaddingLeft(), getPaddingTop());
+        else {
+            Rect rect = computeSurfaceLayoutArea(false);
+            dx = rect.left - surface.getLeft();
+            dy = rect.top - surface.getTop();
+            surface.layout(rect.left, rect.top, rect.right, rect.bottom);
+            if (notify) {
+                dispatchRevealEvent(rect.left, rect.top, rect.right, rect.bottom);
+                dispatchSwipeEvent(rect.left, rect.top, dx, dy);
+            } else {
+                safeBottomView();
+            }
+        }
+        invalidate();
+    }
+
+    public void toggle() {
+        toggle(true);
+    }
+
+    public void toggle(boolean smooth) {
+        if (getOpenStatus() == Status.Open)
+            close(smooth);
+        else if (getOpenStatus() == Status.Close) open(smooth);
+    }
+
+
+    /**
+     * a helper function to compute the Rect area that surface will hold in.
+     *
+     * @param open open status or close status.
+     */
+    private Rect computeSurfaceLayoutArea(boolean open) {
+        int l = getPaddingLeft(), t = getPaddingTop();
+        if (open) {
+            if (mCurrentDragEdge == DragEdge.Left)
+                l = getPaddingLeft() + mDragDistance;
+            else if (mCurrentDragEdge == DragEdge.Right)
+                l = getPaddingLeft() - mDragDistance;
+            else if (mCurrentDragEdge == DragEdge.Top)
+                t = getPaddingTop() + mDragDistance;
+            else t = getPaddingTop() - mDragDistance;
+        }
+        return new Rect(l, t, l + getMeasuredWidth(), t + getMeasuredHeight());
+    }
+
+    private Rect computeBottomLayoutAreaViaSurface(ShowMode mode, Rect surfaceArea) {
+        Rect rect = surfaceArea;
+        View bottomView = getCurrentBottomView();
+
+        int bl = rect.left, bt = rect.top, br = rect.right, bb = rect.bottom;
+        if (mode == ShowMode.PullOut) {
+            if (mCurrentDragEdge == DragEdge.Left)
+                bl = rect.left - mDragDistance;
+            else if (mCurrentDragEdge == DragEdge.Right)
+                bl = rect.right;
+            else if (mCurrentDragEdge == DragEdge.Top)
+                bt = rect.top - mDragDistance;
+            else bt = rect.bottom;
+
+            if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
+                bb = rect.bottom;
+                br = bl + (bottomView == null ? 0 : bottomView.getMeasuredWidth());
+            } else {
+                bb = bt + (bottomView == null ? 0 : bottomView.getMeasuredHeight());
+                br = rect.right;
+            }
+        } else if (mode == ShowMode.LayDown) {
+            if (mCurrentDragEdge == DragEdge.Left)
+                br = bl + mDragDistance;
+            else if (mCurrentDragEdge == DragEdge.Right)
+                bl = br - mDragDistance;
+            else if (mCurrentDragEdge == DragEdge.Top)
+                bb = bt + mDragDistance;
+            else bt = bb - mDragDistance;
+
+        }
+        return new Rect(bl, bt, br, bb);
+
+    }
+
+    private Rect computeBottomLayDown(DragEdge dragEdge) {
+        int bl = getPaddingLeft(), bt = getPaddingTop();
+        int br, bb;
+        if (dragEdge == DragEdge.Right) {
+            bl = getMeasuredWidth() - mDragDistance;
+        } else if (dragEdge == DragEdge.Bottom) {
+            bt = getMeasuredHeight() - mDragDistance;
+        }
+        if (dragEdge == DragEdge.Left || dragEdge == DragEdge.Right) {
+            br = bl + mDragDistance;
+            bb = bt + getMeasuredHeight();
+        } else {
+            br = bl + getMeasuredWidth();
+            bb = bt + mDragDistance;
+        }
+        return new Rect(bl, bt, br, bb);
+    }
+
+    public void setOnDoubleClickListener(DoubleClickListener doubleClickListener) {
+        mDoubleClickListener = doubleClickListener;
+    }
+
+    public interface DoubleClickListener {
+        void onDoubleClick(SwipeLayout layout, boolean surface);
+    }
+
+    private int dp2px(float dp) {
+        return (int) (dp * getContext().getResources().getDisplayMetrics().density + 0.5f);
+    }
+
+
+    /**
+     * Deprecated, use {@link #setDrag(DragEdge, View)}
+     */
+    @Deprecated
+    public void setDragEdge(DragEdge dragEdge) {
+        clearDragEdge();
+        if (getChildCount() >= 2) {
+            mDragEdges.put(dragEdge, getChildAt(getChildCount() - 2));
+        }
+        setCurrentDragEdge(dragEdge);
+    }
+
+    public void onViewRemoved(View child) {
+        for (Map.Entry<DragEdge, View> entry : new HashMap<DragEdge, View>(mDragEdges).entrySet()) {
+            if (entry.getValue() == child) {
+                mDragEdges.remove(entry.getKey());
+            }
+        }
+    }
+
+    public Map<DragEdge, View> getDragEdgeMap() {
+        return mDragEdges;
+    }
+
+    /**
+     * Deprecated, use {@link #getDragEdgeMap()}
+     */
+    @Deprecated
+    public List<DragEdge> getDragEdges() {
+        return new ArrayList<DragEdge>(mDragEdges.keySet());
+    }
+
+    /**
+     * Deprecated, use {@link #setDrag(DragEdge, View)}
+     */
+    @Deprecated
+    public void setDragEdges(List<DragEdge> dragEdges) {
+        clearDragEdge();
+        for (int i = 0, size = Math.min(dragEdges.size(), getChildCount() - 1); i < size; i++) {
+            DragEdge dragEdge = dragEdges.get(i);
+            mDragEdges.put(dragEdge, getChildAt(i));
+        }
+        if (dragEdges.size() == 0 || dragEdges.contains(DefaultDragEdge)) {
+            setCurrentDragEdge(DefaultDragEdge);
+        } else {
+            setCurrentDragEdge(dragEdges.get(0));
+        }
+    }
+
+    /**
+     * Deprecated, use {@link #addDrag(DragEdge, View)}
+     */
+    @Deprecated
+    public void setDragEdges(DragEdge... mDragEdges) {
+        clearDragEdge();
+        setDragEdges(Arrays.asList(mDragEdges));
+    }
+
+    /**
+     * Deprecated, use {@link #addDrag(DragEdge, View)}
+     * When using multiple drag edges it's a good idea to pass the ids of the views that
+     * you're using for the left, right, top bottom views (-1 if you're not using a particular view)
+     */
+    @Deprecated
+    public void setBottomViewIds(int leftId, int rightId, int topId, int bottomId) {
+        addDrag(DragEdge.Left, findViewById(leftId));
+        addDrag(DragEdge.Right, findViewById(rightId));
+        addDrag(DragEdge.Top, findViewById(topId));
+        addDrag(DragEdge.Bottom, findViewById(bottomId));
+    }
+
+    private float getCurrentOffset() {
+        if (mCurrentDragEdge == null) return 0;
+        return mEdgeSwipesOffset[mCurrentDragEdge.ordinal()];
+    }
+
+    private void setCurrentDragEdge(DragEdge dragEdge) {
+        mCurrentDragEdge = dragEdge;
+        updateBottomViews();
+    }
+
+    private void updateBottomViews() {
+        View currentBottomView = getCurrentBottomView();
+        if (currentBottomView != null) {
+            if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
+                mDragDistance = currentBottomView.getMeasuredWidth() - dp2px(getCurrentOffset());
+            } else {
+                mDragDistance = currentBottomView.getMeasuredHeight() - dp2px(getCurrentOffset());
+            }
+        }
+
+        if (mShowMode == ShowMode.PullOut) {
+            layoutPullOut();
+        } else if (mShowMode == ShowMode.LayDown) {
+            layoutLayDown();
+        }
+
+        safeBottomView();
+    }
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/activity/LoadmoreActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/activity/LoadmoreActivity.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/activity/LoadmoreActivity.java	(revision )
@@ -0,0 +1,257 @@
+package com.scene.sceneandroiddemo.ui.activity;
+
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.support.v4.widget.SwipeRefreshLayout;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.Toolbar;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+
+import com.scene.mylib.view.loadstateview.LoadStateView;
+import com.scene.mylib.view.recyclerview.EndlessRecyclerOnScrollListener;
+import com.scene.mylib.view.recyclerview.HeaderAndFooterRecyclerViewAdapter;
+import com.scene.mylib.view.recyclerview.OnRecyclerViewItemClickListener;
+import com.scene.mylib.view.utils.RecyclerViewStateUtils;
+import com.scene.mylib.view.weight.LoadingFooter;
+import com.scene.sceneandroiddemo.BaseActivity;
+import com.scene.sceneandroiddemo.R;
+import com.scene.sceneandroiddemo.adapter.LoadMoreAdapter;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+
+import butterknife.Bind;
+import butterknife.OnClick;
+
+/**
+ * 加载更多
+ * Created by scene on 16/01/26.
+ */
+public class LoadmoreActivity extends BaseActivity implements OnRecyclerViewItemClickListener, SwipeRefreshLayout.OnRefreshListener {
+
+    @Bind(R.id.toolbar)
+    Toolbar toolbar;
+    @Bind(R.id.load_state_view)
+    LoadStateView loadStateView;
+    @Bind(R.id.recyclerView)
+    RecyclerView recyclerView;
+    @Bind(R.id.refreshLayout)
+    SwipeRefreshLayout refreshLayout;
+
+
+    private List<String> dataList;
+    PreviewHandler preHandler = new PreviewHandler(this);
+
+    private LoadMoreAdapter adapter = null;
+    private HeaderAndFooterRecyclerViewAdapter headerAndFooterRecyclerViewAdapter = null;
+
+    //分页需要用到的
+    public int page = 1;
+    public int totalCount = 0;
+    public static final int REQUEST_COUNT = 15;
+    private boolean isLoading = false;
+
+    //测试用的按钮
+    @Bind(R.id.empty)
+    Button empty;
+    @Bind(R.id.error)
+    Button error;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        initToolBar();
+        bindRecyclerView();
+    }
+
+    @Override
+    protected int setLayoutResId() {
+        return R.layout.activity_loadmore;
+    }
+
+
+    private void initToolBar() {
+        toolbar.setTitle("RecyclerView分页");
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+        }
+        toolbar.setNavigationOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                finish();
+            }
+        });
+    }
+
+    /**
+     * 绑定adapter 设置自定义的滚动监听
+     */
+    private void bindRecyclerView() {
+        dataList = new ArrayList<>();
+        adapter = new LoadMoreAdapter(mContext, dataList, recyclerView);
+        adapter.setOnRecyclerViewItemClickListener(this);
+        headerAndFooterRecyclerViewAdapter = new HeaderAndFooterRecyclerViewAdapter(adapter);
+        recyclerView.setLayoutManager(new LinearLayoutManager(mContext));
+        recyclerView.setAdapter(headerAndFooterRecyclerViewAdapter);
+        recyclerView.addOnScrollListener(scrollListener);
+        refreshLayout.setOnRefreshListener(this);
+
+        loadStateView.showLoading();
+        reqData();
+    }
+
+    /**
+     * 刷新
+     */
+    @Override
+    public void onRefresh() {
+        if (isLoading) {
+            return;
+        }
+        isLoading = true;
+        page = 1;
+        reqData();
+    }
+
+    /**
+     * 加载更多
+     */
+    EndlessRecyclerOnScrollListener scrollListener = new EndlessRecyclerOnScrollListener() {
+        @Override
+        public void onLoadNextPage(View view) {
+            super.onLoadNextPage(view);
+
+            LoadingFooter.State state = RecyclerViewStateUtils.getFooterViewState(recyclerView);
+
+            if (state == LoadingFooter.State.Loading || isLoading) {
+                Log.d("@scene", "the state is Loading, just wait..");
+                return;
+            }
+            if (dataList.size() < totalCount) {
+                // loading more
+                RecyclerViewStateUtils.setFooterViewState(LoadmoreActivity.this, recyclerView, REQUEST_COUNT, LoadingFooter.State.Loading, null);
+                page++;
+                reqData();
+            } else {
+                //the end
+                RecyclerViewStateUtils.setFooterViewState(LoadmoreActivity.this, recyclerView, REQUEST_COUNT, LoadingFooter.State.TheEnd, new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        showToast("点击到底了");
+                    }
+                });
+            }
+        }
+    };
+    private View.OnClickListener mFooterClick = new View.OnClickListener() {
+        @Override
+        public void onClick(View v) {
+            RecyclerViewStateUtils.setFooterViewState(LoadmoreActivity.this, recyclerView, REQUEST_COUNT, LoadingFooter.State.Loading, null);
+            reqData();
+        }
+    };
+
+    /**
+     * 自定义的监听
+     *
+     * @param position
+     */
+    @Override
+    public void onRecyclerViewItemClick(int position) {
+        showToast("点击的是：" + dataList.get(position));
+    }
+
+    /**
+     * 模拟获取数据与展示
+     */
+    private void reqData() {
+        new Handler().postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                preHandler.sendEmptyMessage(-1);
+            }
+        }, 3000);
+    }
+
+    /**
+     * 模拟请求之后的数据处理
+     */
+    private class PreviewHandler extends Handler {
+
+        private WeakReference<LoadmoreActivity> ref;
+
+        PreviewHandler(LoadmoreActivity activity) {
+            ref = new WeakReference<>(activity);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            final LoadmoreActivity activity = ref.get();
+            if (activity == null || activity.isFinishing()) {
+                return;
+            }
+            loadStateView.showContent();
+            isLoading = false;
+            refreshLayout.setRefreshing(false);
+            switch (msg.what) {
+                case -1://正常状态
+                    totalCount = 64;
+                    if (page == 1) {
+                        dataList.clear();
+                    }
+                    //模拟组装15个数据
+                    for (int i = 0; i < 15; i++) {
+                        if (dataList.size() >= totalCount) {
+                            break;
+                        }
+                        dataList.add("item" + ((15 * (page - 1)) + (i + 1)));
+                    }
+                    headerAndFooterRecyclerViewAdapter.notifyDataSetChanged();
+                    RecyclerViewStateUtils.setFooterViewState(activity.recyclerView, LoadingFooter.State.Normal);
+                    break;
+                case -2:
+                    headerAndFooterRecyclerViewAdapter.notifyDataSetChanged();
+                    break;
+                case -3://失败时候的处理方式处理
+                    RecyclerViewStateUtils.setFooterViewState(activity, activity.recyclerView, REQUEST_COUNT, LoadingFooter.State.NetWorkError, LoadmoreActivity.this.mFooterClick);
+                    break;
+            }
+        }
+    }
+
+    /**
+     * 以下2个方法是测试显示空和错误的布局
+     */
+
+    @OnClick(R.id.error)
+    public void onClickError() {
+        /**
+         * 显示错误页面有5个参数
+         * 1、提示图片（可以是drawable和resId）
+         * 2、提示文字标题
+         * 3、提示内容
+         * 4、按钮文字
+         * 5、按钮的监听
+         */
+        loadStateView.showError(R.drawable.btn_crop_operator, "网络异常", "请检查网络连接", "点击重试", new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                loadStateView.showLoading();
+                //然后在这儿重新请求数据
+            }
+        });
+    }
+
+    @OnClick(R.id.empty)
+    public void onClickEmpty() {
+        /**
+         * 显示空页面有4个参数
+         */
+        loadStateView.showEmpty(R.drawable.btn_crop_operator, "没有数据", "这儿没有什么东西");
+    }
+}
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision )
+++ .idea/modules.xml	(revision )
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/SceneAndroidDemo.iml" filepath="$PROJECT_DIR$/SceneAndroidDemo.iml" />
+      <module fileurl="file://$PROJECT_DIR$/app/app.iml" filepath="$PROJECT_DIR$/app/app.iml" />
+      <module fileurl="file://$PROJECT_DIR$/chooseimagelib/chooseimagelib.iml" filepath="$PROJECT_DIR$/chooseimagelib/chooseimagelib.iml" />
+      <module fileurl="file://$PROJECT_DIR$/common/common.iml" filepath="$PROJECT_DIR$/common/common.iml" />
+      <module fileurl="file://$PROJECT_DIR$/customfresco/customfresco.iml" filepath="$PROJECT_DIR$/customfresco/customfresco.iml" />
+      <module fileurl="file://$PROJECT_DIR$/easypermissions/easypermissions.iml" filepath="$PROJECT_DIR$/easypermissions/easypermissions.iml" />
+      <module fileurl="file://$PROJECT_DIR$/mylib/mylib.iml" filepath="$PROJECT_DIR$/mylib/mylib.iml" />
+      <module fileurl="file://$PROJECT_DIR$/timeline/timeline.iml" filepath="$PROJECT_DIR$/timeline/timeline.iml" />
+      <module fileurl="file://$PROJECT_DIR$/ucrop/ucrop.iml" filepath="$PROJECT_DIR$/ucrop/ucrop.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/tab/ViewHolder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/tab/ViewHolder.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/tab/ViewHolder.java	(revision )
@@ -0,0 +1,25 @@
+package com.scene.mylib.view.tab;
+
+import android.util.SparseArray;
+import android.view.View;
+
+/**
+ * Created by linhongong on 2015/9/22.
+ */
+public class ViewHolder {
+
+    public static <T extends View> T get(View view, int id) {
+        @SuppressWarnings("unchecked")
+        SparseArray<View> viewHolder = (SparseArray<View>) view.getTag();
+        if (viewHolder == null) {
+            viewHolder = new SparseArray<View>();
+            view.setTag(viewHolder);
+        }
+        View childView = viewHolder.get(id);
+        if (childView == null) {
+            childView = view.findViewById(id);
+            viewHolder.put(id, childView);
+        }
+        return (T) childView;
+    }
+}
Index: common/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/.gitignore	(revision )
+++ common/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: app/src/main/res/layout/fragment1.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/fragment1.xml	(revision )
+++ app/src/main/res/layout/fragment1.xml	(revision )
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    tools:context="com.scene.sceneandroiddemo.MainActivity">
+
+
+    <android.support.v7.widget.RecyclerView
+        android:id="@+id/recyclerView"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:background="@color/white"
+        android:paddingLeft="15dp"
+        android:paddingRight="15dp"/>
+
+</LinearLayout>
Index: mylib/src/main/java/com/scene/mylib/view/utils/RecyclerViewStateUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/utils/RecyclerViewStateUtils.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/utils/RecyclerViewStateUtils.java	(revision )
@@ -0,0 +1,105 @@
+package com.scene.mylib.view.utils;
+
+import android.app.Activity;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+
+import com.scene.mylib.view.recyclerview.HeaderAndFooterRecyclerViewAdapter;
+import com.scene.mylib.view.weight.LoadingFooter;
+
+
+/**
+ * Created by scene on 2015/11/9.
+ * <p/>
+ * 分页展示数据时，RecyclerView的FooterView State 操作工具类
+ * <p/>
+ * RecyclerView一共有几种State：Normal/Loading/Error/TheEnd
+ */
+public class RecyclerViewStateUtils {
+
+    /**
+     * 设置headerAndFooterAdapter的FooterView State
+     *
+     * @param instance      context
+     * @param recyclerView  recyclerView
+     * @param pageSize      分页展示时，recyclerView每一页的数量
+     * @param state         FooterView State
+     * @param errorListener FooterView处于Error状态时的点击事件
+     */
+    public static void setFooterViewState(Activity instance, RecyclerView recyclerView, int pageSize, LoadingFooter.State state, View.OnClickListener errorListener) {
+
+        if (instance == null || instance.isFinishing()) {
+            return;
+        }
+
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+
+        if (outerAdapter == null || !(outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter)) {
+            return;
+        }
+
+        HeaderAndFooterRecyclerViewAdapter headerAndFooterAdapter = (HeaderAndFooterRecyclerViewAdapter) outerAdapter;
+
+        //只有一页的时候，就别加什么FooterView了
+        if (headerAndFooterAdapter.getInnerAdapter().getItemCount() < pageSize) {
+            return;
+        }
+
+        LoadingFooter footerView;
+
+        //已经有footerView了
+        if (headerAndFooterAdapter.getFooterViewsCount() > 0) {
+            footerView = (LoadingFooter) headerAndFooterAdapter.getFooterView();
+            footerView.setState(state);
+
+            if (state == LoadingFooter.State.NetWorkError||state== LoadingFooter.State.TheEnd) {
+                footerView.setOnClickListener(errorListener);
+            }
+            recyclerView.scrollToPosition(headerAndFooterAdapter.getItemCount() - 1);
+        } else {
+            footerView = new LoadingFooter(instance);
+            footerView.setState(state);
+
+            if (state == LoadingFooter.State.NetWorkError||state== LoadingFooter.State.TheEnd) {
+                footerView.setOnClickListener(errorListener);
+            }
+
+            headerAndFooterAdapter.addFooterView(footerView);
+            recyclerView.scrollToPosition(headerAndFooterAdapter.getItemCount() - 1);
+        }
+    }
+
+    /**
+     * 获取当前RecyclerView.FooterView的状态
+     *
+     * @param recyclerView
+     */
+    public static LoadingFooter.State getFooterViewState(RecyclerView recyclerView) {
+
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+        if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter) {
+            if (((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getFooterViewsCount() > 0) {
+                LoadingFooter footerView = (LoadingFooter) ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getFooterView();
+                return footerView.getState();
+            }
+        }
+
+        return LoadingFooter.State.Normal;
+    }
+
+    /**
+     * 设置当前RecyclerView.FooterView的状态
+     *
+     * @param recyclerView
+     * @param state
+     */
+    public static void setFooterViewState(RecyclerView recyclerView, LoadingFooter.State state) {
+        RecyclerView.Adapter outerAdapter = recyclerView.getAdapter();
+        if (outerAdapter != null && outerAdapter instanceof HeaderAndFooterRecyclerViewAdapter) {
+            if (((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getFooterViewsCount() > 0) {
+                LoadingFooter footerView = (LoadingFooter) ((HeaderAndFooterRecyclerViewAdapter) outerAdapter).getFooterView();
+                footerView.setState(state);
+            }
+        }
+    }
+}
Index: easypermissions/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/proguard-rules.pro	(revision )
+++ easypermissions/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/google/home/samstern/android-sdk-linux/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: chooseimagelib/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/res/values/styles.xml	(revision )
+++ chooseimagelib/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,13 @@
+<resources>
+
+    <style name="CropButton">
+        <item name="android:layout_margin">1dp</item>
+        <item name="android:paddingTop">0dp</item>
+        <item name="android:paddingBottom">3dp</item>
+        <item name="android:layout_height">50dp</item>
+        <item name="android:layout_width">60dp</item>
+        <item name="android:textSize">20sp</item>
+        <item name="android:layout_weight">1</item>
+        <item name="android:background">@drawable/selector_crop_button</item>
+    </style>
+</resources>
Index: ucrop/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/values/styles.xml	(revision )
+++ ucrop/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <style name="ucrop_ImageViewWidgetIcon">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:layout_gravity">center</item>
+        <item name="android:scaleType">fitCenter</item>
+        <item name="android:duplicateParentState">true</item>
+    </style>
+
+    <style name="ucrop_WrapperIconState">
+        <item name="android:layout_width">0dp</item>
+        <item name="android:layout_height">match_parent</item>
+        <item name="android:layout_weight">1</item>
+        <item name="android:background">?attr/selectableItemBackground</item>
+        <item name="android:clickable">true</item>
+    </style>
+
+    <style name="ucrop_WrapperRotateButton">
+        <item name="android:layout_width">50dp</item>
+        <item name="android:layout_height">50dp</item>
+        <item name="android:background">?attr/selectableItemBackgroundBorderless</item>
+        <item name="android:clickable">true</item>
+    </style>
+
+    <style name="ucrop_TextViewCropAspectRatio">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">40dp</item>
+        <item name="android:layout_gravity">center</item>
+        <item name="android:duplicateParentState">true</item>
+        <item name="android:textColor">@color/ucrop_scale_text_view_selector</item>
+    </style>
+
+</resources>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/FileUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/FileUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/FileUtil.java	(revision )
@@ -0,0 +1,93 @@
+package com.scene.common.common.utils;
+
+import java.io.*;
+import java.nio.channels.FileChannel;
+import java.text.DecimalFormat;
+
+/**
+ * @author MaTianyu
+ * @date 2014-08-10
+ */
+public class FileUtil {
+
+    private static final String TAG = FileUtil.class.getSimpleName();
+
+    public static void fileChannelCopy(File s, File t) {
+        FileInputStream fi = null;
+        FileOutputStream fo = null;
+        try {
+            fi = new FileInputStream(s);
+            fo = new FileOutputStream(t);
+            FileChannel in = fi.getChannel();//得到对应的文件通道
+            FileChannel out = fo.getChannel();//得到对应的文件通道
+            in.transferTo(0, in.size(), out);//连接两个通道，并且从in通道读取，然后写入out通道
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                if (fo != null) fo.close();
+                if (fi != null) fi.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+
+        }
+    }
+
+    public static String formatFileSizeToString(long fileLen) {// 转换文件大小
+        DecimalFormat df = new DecimalFormat("#.00");
+        String fileSizeString = "";
+        if (fileLen < 1024) {
+            fileSizeString = df.format((double) fileLen) + "B";
+        } else if (fileLen < 1048576) {
+            fileSizeString = df.format((double) fileLen / 1024) + "K";
+        } else if (fileLen < 1073741824) {
+            fileSizeString = df.format((double) fileLen / 1048576) + "M";
+        } else {
+            fileSizeString = df.format((double) fileLen / 1073741824) + "G";
+        }
+        return fileSizeString;
+    }
+
+    /***
+     * 根据路径删除图片
+     */
+    public static boolean deleteFile(File file)throws IOException{
+        return file != null && file.delete();
+    }
+
+    /***
+     * 获取文件扩展名
+     * @param filename
+     * @return 返回文件扩展名
+     */
+    public static String getExtensionName(String filename) {
+        if ((filename != null) && (filename.length() > 0)) {
+            int dot = filename.lastIndexOf('.');
+            if ((dot >-1) && (dot < (filename.length() - 1))) {
+                return filename.substring(dot + 1);
+            }
+        }
+        return filename;
+    }
+
+
+    /**
+     * 读取指定文件的输出
+     */
+    public static String getFileOutputString(String path) {
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(path), 8192);
+            StringBuilder sb = new StringBuilder();
+            String line = null;
+            while ((line = bufferedReader.readLine()) != null) {
+                sb.append("\n").append(line);
+            }
+            bufferedReader.close();
+            return sb.toString();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+}
Index: common/src/main/java/com/scene/common/common/assist/FlashLight.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/FlashLight.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/FlashLight.java	(revision )
@@ -0,0 +1,64 @@
+package com.scene.common.common.assist;
+
+import android.hardware.Camera;
+import android.os.Build;
+import android.os.Handler;
+
+/**
+ * <!-- 手电筒 -->
+ * Call requires API level 5
+ * <uses-permission android:name="android.permission.FLASHLIGHT"/>
+ * <uses-permission android:name="android.permission.CAMERA"/>
+ *
+ * @author MaTianyu
+ * @date 2014-11-04
+ */
+public class FlashLight {
+
+    private Camera camera;
+    private Handler handler = new Handler();
+
+    /**
+     * 超过3分钟自动关闭，防止损伤硬件
+     */
+    private static final int OFF_TIME = 3 * 60 * 1000;
+
+    public boolean turnOnFlashLight() {
+        if (camera == null) {
+            camera = Camera.open();
+            camera.startPreview();
+            Camera.Parameters parameter = camera.getParameters();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ECLAIR) {
+                parameter.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
+            } else {
+                parameter.set("flash-mode", "torch");
+            }
+            camera.setParameters(parameter);
+            handler.removeCallbacksAndMessages(null);
+            handler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    turnOffFlashLight();
+                }
+            }, OFF_TIME);
+        }
+        return true;
+    }
+
+    public boolean turnOffFlashLight() {
+        if (camera != null) {
+            handler.removeCallbacksAndMessages(null);
+            Camera.Parameters parameter = camera.getParameters();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ECLAIR) {
+                parameter.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
+            } else {
+                parameter.set("flash-mode", "off");
+            }
+            camera.setParameters(parameter);
+            camera.stopPreview();
+            camera.release();
+            camera = null;
+        }
+        return true;
+    }
+}
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/implments/SwipeItemMangerImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/implments/SwipeItemMangerImpl.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/implments/SwipeItemMangerImpl.java	(revision )
@@ -0,0 +1,215 @@
+package com.scene.mylib.view.swipelayout.implments;
+
+import android.view.View;
+
+import com.scene.mylib.view.swipelayout.SimpleSwipeListener;
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeAdapterInterface;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeItemMangerInterface;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * SwipeItemMangerImpl is a helper class to help all the adapters to maintain open status.
+ */
+public class SwipeItemMangerImpl implements SwipeItemMangerInterface {
+
+    private Attributes.Mode mode = Attributes.Mode.Single;
+    public final int INVALID_POSITION = -1;
+
+    protected int mOpenPosition = INVALID_POSITION;
+
+    protected Set<Integer> mOpenPositions = new HashSet<Integer>();
+    protected Set<SwipeLayout> mShownLayouts = new HashSet<SwipeLayout>();
+
+    protected SwipeAdapterInterface swipeAdapterInterface;
+
+    public SwipeItemMangerImpl(SwipeAdapterInterface swipeAdapterInterface) {
+        if (swipeAdapterInterface == null)
+            throw new IllegalArgumentException("SwipeAdapterInterface can not be null");
+
+        this.swipeAdapterInterface = swipeAdapterInterface;
+    }
+
+    public Attributes.Mode getMode() {
+        return mode;
+    }
+
+    public void setMode(Attributes.Mode mode) {
+        this.mode = mode;
+        mOpenPositions.clear();
+        mShownLayouts.clear();
+        mOpenPosition = INVALID_POSITION;
+    }
+
+    public void bind(View view, int position) {
+        int resId = swipeAdapterInterface.getSwipeLayoutResourceId(position);
+        SwipeLayout swipeLayout = (SwipeLayout) view.findViewById(resId);
+        if (swipeLayout == null)
+            throw new IllegalStateException("can not find SwipeLayout in target view");
+
+        if (swipeLayout.getTag(resId) == null) {
+            OnLayoutListener onLayoutListener = new OnLayoutListener(position);
+            SwipeMemory swipeMemory = new SwipeMemory(position);
+            swipeLayout.addSwipeListener(swipeMemory);
+            swipeLayout.addOnLayoutListener(onLayoutListener);
+            swipeLayout.setTag(resId, new ValueBox(position, swipeMemory, onLayoutListener));
+            mShownLayouts.add(swipeLayout);
+        } else {
+            ValueBox valueBox = (ValueBox) swipeLayout.getTag(resId);
+            valueBox.swipeMemory.setPosition(position);
+            valueBox.onLayoutListener.setPosition(position);
+            valueBox.position = position;
+        }
+    }
+
+    @Override
+    public void openItem(int position) {
+        if (mode == Attributes.Mode.Multiple) {
+            if (!mOpenPositions.contains(position))
+                mOpenPositions.add(position);
+        } else {
+            mOpenPosition = position;
+        }
+        swipeAdapterInterface.notifyDatasetChanged();
+    }
+
+    @Override
+    public void closeItem(int position) {
+        if (mode == Attributes.Mode.Multiple) {
+            mOpenPositions.remove(position);
+        } else {
+            if (mOpenPosition == position)
+                mOpenPosition = INVALID_POSITION;
+        }
+        swipeAdapterInterface.notifyDatasetChanged();
+    }
+
+    @Override
+    public void closeAllExcept(SwipeLayout layout) {
+        for (SwipeLayout s : mShownLayouts) {
+            if (s != layout)
+                s.close();
+        }
+    }
+
+    @Override
+    public void closeAllItems() {
+        if (mode == Attributes.Mode.Multiple) {
+            mOpenPositions.clear();
+        } else {
+            mOpenPosition = INVALID_POSITION;
+        }
+        for (SwipeLayout s : mShownLayouts) {
+            s.close();
+        }
+    }
+
+    @Override
+    public void removeShownLayouts(SwipeLayout layout) {
+        mShownLayouts.remove(layout);
+    }
+
+    @Override
+    public List<Integer> getOpenItems() {
+        if (mode == Attributes.Mode.Multiple) {
+            return new ArrayList<Integer>(mOpenPositions);
+        } else {
+            return Collections.singletonList(mOpenPosition);
+        }
+    }
+
+    @Override
+    public List<SwipeLayout> getOpenLayouts() {
+        return new ArrayList<SwipeLayout>(mShownLayouts);
+    }
+
+    @Override
+    public boolean isOpen(int position) {
+        if (mode == Attributes.Mode.Multiple) {
+            return mOpenPositions.contains(position);
+        } else {
+            return mOpenPosition == position;
+        }
+    }
+
+    class ValueBox {
+        OnLayoutListener onLayoutListener;
+        SwipeMemory swipeMemory;
+        int position;
+
+        ValueBox(int position, SwipeMemory swipeMemory, OnLayoutListener onLayoutListener) {
+            this.swipeMemory = swipeMemory;
+            this.onLayoutListener = onLayoutListener;
+            this.position = position;
+        }
+    }
+
+    class OnLayoutListener implements SwipeLayout.OnLayout {
+
+        private int position;
+
+        OnLayoutListener(int position) {
+            this.position = position;
+        }
+
+        public void setPosition(int position) {
+            this.position = position;
+        }
+
+        @Override
+        public void onLayout(SwipeLayout v) {
+            if (isOpen(position)) {
+                v.open(false, false);
+            } else {
+                v.close(false, false);
+            }
+        }
+
+    }
+
+    class SwipeMemory extends SimpleSwipeListener {
+
+        private int position;
+
+        SwipeMemory(int position) {
+            this.position = position;
+        }
+
+        @Override
+        public void onClose(SwipeLayout layout) {
+            if (mode == Attributes.Mode.Multiple) {
+                mOpenPositions.remove(position);
+            } else {
+                mOpenPosition = INVALID_POSITION;
+            }
+        }
+
+        @Override
+        public void onStartOpen(SwipeLayout layout) {
+            if (mode == Attributes.Mode.Single) {
+                closeAllExcept(layout);
+            }
+        }
+
+        @Override
+        public void onOpen(SwipeLayout layout) {
+            if (mode == Attributes.Mode.Multiple)
+                mOpenPositions.add(position);
+            else {
+                closeAllExcept(layout);
+                mOpenPosition = position;
+            }
+        }
+
+        public void setPosition(int position) {
+            this.position = position;
+        }
+    }
+
+}
Index: ucrop/src/main/res/values/attrs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/values/attrs.xml	(revision )
+++ ucrop/src/main/res/values/attrs.xml	(revision )
@@ -0,0 +1,33 @@
+<resources>
+
+    <declare-styleable name="ucrop_CropImageView">
+
+        <attr name="ucrop_aspect_ratio_x" format="float"/>
+        <attr name="ucrop_aspect_ratio_y" format="float"/>
+
+        <attr name="ucrop_max_scale_multiplier" format="float"/>
+
+        <attr name="ucrop_overlay_color" format="color"/>
+
+        <attr name="ucrop_grid_stroke_size" format="dimension"/>
+        <attr name="ucrop_grid_color" format="color"/>
+        <attr name="ucrop_grid_row_count" format="integer"/>
+        <attr name="ucrop_grid_column_count" format="integer"/>
+        <attr name="ucrop_show_grid" format="boolean"/>
+
+        <attr name="ucrop_frame_stroke_size" format="dimension"/>
+        <attr name="ucrop_frame_color" format="color"/>
+        <attr name="ucrop_show_frame" format="boolean"/>
+
+    </declare-styleable>
+
+    <declare-styleable name="ucrop_AspectRatioTextView">
+
+        <attr name="ucrop_artv_ratio_title" format="string"/>
+
+        <attr name="ucrop_artv_ratio_x" format="float"/>
+        <attr name="ucrop_artv_ratio_y" format="float"/>
+
+    </declare-styleable>
+
+</resources>
\ No newline at end of file
Index: app/src/main/res/layout/activity_main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_main.xml	(revision )
+++ app/src/main/res/layout/activity_main.xml	(revision )
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    tools:context="com.scene.sceneandroiddemo.MainActivity">
+
+    <android.support.v7.widget.Toolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="?attr/actionBarSize"
+        android:background="?attr/colorPrimary"/>
+
+    <android.support.v7.widget.RecyclerView
+        android:id="@+id/recyclerView"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:background="@color/white"
+        android:paddingLeft="15dp"
+        android:paddingRight="15dp"/>
+
+</LinearLayout>
Index: app/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/proguard-rules.pro	(revision )
+++ app/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\Devolopment\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: app/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/colors.xml	(revision )
+++ app/src/main/res/values/colors.xml	(revision )
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+
+    <color name="white">#FFFFFF</color>
+    <color name="item_title_color">#999999</color>
+    <color name="item_bg_color">#6cd263</color>
+
+    <!--tab的颜色配置-->
+    <color name="home_bar_text_normal">#6a6c6f</color>
+    <color name="home_bar_text_push">#ff5959</color>
+    <color name="textnormal">#adadad</color>
+
+    <color name="btn_bg_pressed_color">#ffacac</color>
+    <color name="btn_bg_color">#ff5959</color>
+    <!--tab的颜色配置结束-->
+</resources>
Index: common/src/main/java/com/scene/common/common/data/cipher/Cipher.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/data/cipher/Cipher.java	(revision )
+++ common/src/main/java/com/scene/common/common/data/cipher/Cipher.java	(revision )
@@ -0,0 +1,9 @@
+package com.scene.common.common.data.cipher;
+
+/**
+ * @author MaTianyu
+ * @date 14-7-31
+ */
+public abstract class Cipher implements Encrypt,Decrypt{
+
+}
Index: ucrop/src/main/res/layout/ucrop_activity_photobox.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/layout/ucrop_activity_photobox.xml	(revision )
+++ ucrop/src/main/res/layout/ucrop_activity_photobox.xml	(revision )
@@ -0,0 +1,103 @@
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <android.support.v7.widget.Toolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:background="@color/ucrop_color_toolbar"
+        android:minHeight="?attr/actionBarSize">
+
+        <TextView
+            style="@style/TextAppearance.Widget.AppCompat.Toolbar.Title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:text="@string/ucrop_label_edit_photo"
+            android:textColor="@android:color/white"/>
+
+    </android.support.v7.widget.Toolbar>
+
+    <com.yalantis.ucrop.view.GestureCropImageView
+        android:id="@+id/image_view_crop"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_above="@+id/wrapper_controls"
+        android:layout_below="@+id/toolbar"
+        android:background="@android:color/black"
+        android:padding="16dp"
+        app:ucrop_show_frame="true"/>
+
+    <FrameLayout
+        android:id="@+id/wrapper_controls"
+        android:layout_width="match_parent"
+        android:layout_height="64dp"
+        android:layout_above="@+id/wrapper_states"
+        android:background="@color/ucrop_color_widget_background">
+
+        <include
+            android:id="@+id/layout_aspect_ratio"
+            layout="@layout/ucrop_layout_aspect_ratio"/>
+
+        <include
+            android:id="@+id/layout_rotate_wheel"
+            layout="@layout/ucrop_layout_rotate_wheel"/>
+
+        <include
+            android:id="@+id/layout_scale_wheel"
+            layout="@layout/ucrop_layout_scale_wheel"/>
+
+    </FrameLayout>
+
+    <ImageView
+        android:layout_width="match_parent"
+        android:layout_height="3dp"
+        android:layout_above="@+id/wrapper_states"
+        android:background="@drawable/ucrop_shadow_upside"/>
+
+    <LinearLayout
+        android:id="@+id/wrapper_states"
+        android:layout_width="match_parent"
+        android:layout_height="72dp"
+        android:layout_alignParentBottom="true"
+        android:background="@color/ucrop_color_widget_background"
+        android:baselineAligned="false"
+        android:gravity="center"
+        android:orientation="horizontal">
+
+        <FrameLayout
+            android:id="@+id/state_scale"
+            style="@style/ucrop_WrapperIconState">
+
+            <ImageView
+                style="@style/ucrop_ImageViewWidgetIcon"
+                android:src="@drawable/ucrop_ic_selector_scale"/>
+
+        </FrameLayout>
+
+        <FrameLayout
+            android:id="@+id/state_rotate"
+            style="@style/ucrop_WrapperIconState">
+
+            <ImageView
+                style="@style/ucrop_ImageViewWidgetIcon"
+                android:src="@drawable/ucrop_ic_selector_rotate"/>
+
+        </FrameLayout>
+
+        <FrameLayout
+            android:id="@+id/state_aspect_ratio"
+            style="@style/ucrop_WrapperIconState">
+
+            <ImageView
+                style="@style/ucrop_ImageViewWidgetIcon"
+                android:src="@drawable/ucrop_ic_selector_aspect_ratio"/>
+
+        </FrameLayout>
+
+    </LinearLayout>
+
+</RelativeLayout>
\ No newline at end of file
Index: .idea/copyright/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/copyright/profiles_settings.xml	(revision )
+++ .idea/copyright/profiles_settings.xml	(revision )
@@ -0,0 +1,3 @@
+<component name="CopyrightManager">
+  <settings default="" />
+</component>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/TelephoneUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/TelephoneUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/TelephoneUtil.java	(revision )
@@ -0,0 +1,289 @@
+package com.scene.common.common.utils;
+
+import android.content.Context;
+import android.telephony.TelephonyManager;
+import com.scene.common.android.log.Log;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+/**
+ * Get phone info, such as IMEI,IMSI,Number,Sim State, etc.
+ *
+ * <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
+ *
+ * @author MaTianyu
+ * @date 2014-09-25
+ */
+public class TelephoneUtil {
+
+    private static final String TAG = TelephoneUtil.class.getSimpleName();
+
+    /**
+     * IMSI是国际移动用户识别码的简称(International Mobile Subscriber Identity)
+     * IMSI共有15位，其结构如下：
+     * MCC+MNC+MIN
+     * MCC：Mobile Country Code，移动国家码，共3位，中国为460;
+     * MNC:Mobile NetworkCode，移动网络码，共2位
+     * 在中国，移动的代码为电00和02，联通的代码为01，电信的代码为03
+     * 合起来就是（也是Android手机中APN配置文件中的代码）：
+     * 中国移动：46000 46002
+     * 中国联通：46001
+     * 中国电信：46003
+     * 举例，一个典型的IMSI号码为460030912121001
+     */
+    public static String getIMSI(Context context) {
+        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        String IMSI = telephonyManager.getSubscriberId();
+        Log.i(TAG, " IMSI：" + IMSI);
+        return IMSI;
+    }
+
+    /**
+     * IMEI是International Mobile Equipment Identity （国际移动设备标识）的简称
+     * IMEI由15位数字组成的”电子串号”，它与每台手机一一对应，而且该码是全世界唯一的
+     * 其组成为：
+     * 1. 前6位数(TAC)是”型号核准号码”，一般代表机型
+     * 2. 接着的2位数(FAC)是”最后装配号”，一般代表产地
+     * 3. 之后的6位数(SNR)是”串号”，一般代表生产顺序号
+     * 4. 最后1位数(SP)通常是”0″，为检验码，目前暂备用
+     */
+    public static String getIMEI(Context context) {
+        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        String IMEI = telephonyManager.getDeviceId();
+        Log.i(TAG, " IMEI：" + IMEI);
+        return IMEI;
+    }
+
+    /**
+     * Print telephone info.
+     */
+    public static String printTelephoneInfo(Context context) {
+        Date date = new Date(System.currentTimeMillis());
+        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+        String time = dateFormat.format(date);
+        StringBuilder sb = new StringBuilder();
+        sb.append("_______ 手机信息  ").append(time).append(" ______________");
+        TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        String IMSI = tm.getSubscriberId();
+        //IMSI前面三位460是国家号码，其次的两位是运营商代号，00、02是中国移动，01是联通，03是电信。
+        String providerName = null;
+        if (IMSI != null) {
+            if (IMSI.startsWith("46000") || IMSI.startsWith("46002")) {
+                providerName = "中国移动";
+            } else if (IMSI.startsWith("46001")) {
+                providerName = "中国联通";
+            } else if (IMSI.startsWith("46003")) {
+                providerName = "中国电信";
+            }
+        }
+        sb.append(providerName).append("  手机号：").append(tm.getLine1Number()).append(" IMSI是：").append(IMSI);
+        sb.append("\nDeviceID(IMEI)       :").append(tm.getDeviceId());
+        sb.append("\nDeviceSoftwareVersion:").append(tm.getDeviceSoftwareVersion());
+        sb.append("\ngetLine1Number       :").append(tm.getLine1Number());
+        sb.append("\nNetworkCountryIso    :").append(tm.getNetworkCountryIso());
+        sb.append("\nNetworkOperator      :").append(tm.getNetworkOperator());
+        sb.append("\nNetworkOperatorName  :").append(tm.getNetworkOperatorName());
+        sb.append("\nNetworkType          :").append(tm.getNetworkType());
+        sb.append("\nPhoneType            :").append(tm.getPhoneType());
+        sb.append("\nSimCountryIso        :").append(tm.getSimCountryIso());
+        sb.append("\nSimOperator          :").append(tm.getSimOperator());
+        sb.append("\nSimOperatorName      :").append(tm.getSimOperatorName());
+        sb.append("\nSimSerialNumber      :").append(tm.getSimSerialNumber());
+        sb.append("\ngetSimState          :").append(tm.getSimState());
+        sb.append("\nSubscriberId         :").append(tm.getSubscriberId());
+        sb.append("\nVoiceMailNumber      :").append(tm.getVoiceMailNumber());
+
+        Log.i(TAG, sb.toString());
+        return sb.toString();
+    }
+
+    /////_________________ 双卡双待系统IMEI和IMSI方案（see more on http://benson37.iteye.com/blog/1923946）
+
+    /**
+     * 双卡双待神机IMSI、IMSI、PhoneType信息
+     * <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
+     */
+    public static class TeleInfo {
+        public String imsi_1;
+        public String imsi_2;
+        public String imei_1;
+        public String imei_2;
+        public int phoneType_1;
+        public int phoneType_2;
+
+        @Override
+        public String toString() {
+            return "TeleInfo{" +
+                   "imsi_1='" + imsi_1 + '\'' +
+                   ", imsi_2='" + imsi_2 + '\'' +
+                   ", imei_1='" + imei_1 + '\'' +
+                   ", imei_2='" + imei_2 + '\'' +
+                   ", phoneType_1=" + phoneType_1 +
+                   ", phoneType_2=" + phoneType_2 +
+                   '}';
+        }
+    }
+
+    /**
+     * MTK Phone.
+     *
+     * 获取 MTK 神机的双卡 IMSI、IMSI 信息
+     */
+    public static TeleInfo getMtkTeleInfo(Context context) {
+        TeleInfo teleInfo = new TeleInfo();
+        try {
+            Class<?> phone = Class.forName("com.android.internal.telephony.Phone");
+
+            Field fields1 = phone.getField("GEMINI_SIM_1");
+            fields1.setAccessible(true);
+            int simId_1 = (Integer) fields1.get(null);
+
+            Field fields2 = phone.getField("GEMINI_SIM_2");
+            fields2.setAccessible(true);
+            int simId_2 = (Integer) fields2.get(null);
+
+            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            Method getSubscriberIdGemini = TelephonyManager.class.getDeclaredMethod("getSubscriberIdGemini", int.class);
+            String imsi_1 = (String) getSubscriberIdGemini.invoke(tm, simId_1);
+            String imsi_2 = (String) getSubscriberIdGemini.invoke(tm, simId_2);
+            teleInfo.imsi_1 = imsi_1;
+            teleInfo.imsi_2 = imsi_2;
+
+            Method getDeviceIdGemini = TelephonyManager.class.getDeclaredMethod("getDeviceIdGemini", int.class);
+            String imei_1 = (String) getDeviceIdGemini.invoke(tm, simId_1);
+            String imei_2 = (String) getDeviceIdGemini.invoke(tm, simId_2);
+
+            teleInfo.imei_1 = imei_1;
+            teleInfo.imei_2 = imei_2;
+
+            Method getPhoneTypeGemini = TelephonyManager.class.getDeclaredMethod("getPhoneTypeGemini", int.class);
+            int phoneType_1 = (Integer) getPhoneTypeGemini.invoke(tm, simId_1);
+            int phoneType_2 = (Integer) getPhoneTypeGemini.invoke(tm, simId_2);
+            teleInfo.phoneType_1 = phoneType_1;
+            teleInfo.phoneType_2 = phoneType_2;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        Log.i(TAG, "MTK: " + teleInfo);
+        return teleInfo;
+    }
+
+    /**
+     * MTK Phone.
+     *
+     * 获取 MTK 神机的双卡 IMSI、IMSI 信息
+     */
+    public static TeleInfo getMtkTeleInfo2(Context context) {
+        TeleInfo teleInfo = new TeleInfo();
+        try {
+            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            Class<?> phone = Class.forName("com.android.internal.telephony.Phone");
+            Field fields1 = phone.getField("GEMINI_SIM_1");
+            fields1.setAccessible(true);
+            int simId_1 = (Integer) fields1.get(null);
+            Field fields2 = phone.getField("GEMINI_SIM_2");
+            fields2.setAccessible(true);
+            int simId_2 = (Integer) fields2.get(null);
+
+            Method getDefault = TelephonyManager.class.getMethod("getDefault", int.class);
+            TelephonyManager tm1 = (TelephonyManager) getDefault.invoke(tm, simId_1);
+            TelephonyManager tm2 = (TelephonyManager) getDefault.invoke(tm, simId_2);
+
+            String imsi_1 = tm1.getSubscriberId();
+            String imsi_2 = tm2.getSubscriberId();
+            teleInfo.imsi_1 = imsi_1;
+            teleInfo.imsi_2 = imsi_2;
+
+            String imei_1 = tm1.getDeviceId();
+            String imei_2 = tm2.getDeviceId();
+            teleInfo.imei_1 = imei_1;
+            teleInfo.imei_2 = imei_2;
+
+            int phoneType_1 = tm1.getPhoneType();
+            int phoneType_2 = tm2.getPhoneType();
+            teleInfo.phoneType_1 = phoneType_1;
+            teleInfo.phoneType_2 = phoneType_2;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        Log.i(TAG, "MTK2: " + teleInfo);
+        return teleInfo;
+    }
+
+    /**
+     * Qualcomm Phone.
+     * 获取 高通 神机的双卡 IMSI、IMSI 信息
+     */
+    public static TeleInfo getQualcommTeleInfo(Context context) {
+        TeleInfo teleInfo = new TeleInfo();
+        try {
+            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            Class<?> simTMclass = Class.forName("android.telephony.MSimTelephonyManager");
+            Object sim = context.getSystemService("phone_msim");
+            int simId_1 = 0;
+            int simId_2 = 1;
+
+            Method getSubscriberId = simTMclass.getMethod("getSubscriberId", int.class);
+            String imsi_1 = (String) getSubscriberId.invoke(sim, simId_1);
+            String imsi_2 = (String) getSubscriberId.invoke(sim, simId_2);
+            teleInfo.imsi_1 = imsi_1;
+            teleInfo.imsi_2 = imsi_2;
+
+            Method getDeviceId = simTMclass.getMethod("getDeviceId", int.class);
+            String imei_1 = (String) getDeviceId.invoke(sim, simId_1);
+            String imei_2 = (String) getDeviceId.invoke(sim, simId_2);
+            teleInfo.imei_1 = imei_1;
+            teleInfo.imei_2 = imei_2;
+
+            Method getDataState = simTMclass.getMethod("getDataState");
+            int phoneType_1 = tm.getDataState();
+            int phoneType_2 = (Integer) getDataState.invoke(sim);
+            teleInfo.phoneType_1 = phoneType_1;
+            teleInfo.phoneType_2 = phoneType_2;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        Log.i(TAG, "Qualcomm: " + teleInfo);
+        return teleInfo;
+    }
+
+    /**
+     * Spreadtrum Phone.
+     *
+     * 获取 展讯 神机的双卡 IMSI、IMSI 信息
+     */
+    public static TeleInfo getSpreadtrumTeleInfo(Context context) {
+        TeleInfo teleInfo = new TeleInfo();
+        try {
+
+            TelephonyManager tm1 = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            String imsi_1 = tm1.getSubscriberId();
+            String imei_1 = tm1.getDeviceId();
+            int phoneType_1 = tm1.getPhoneType();
+            teleInfo.imsi_1 = imsi_1;
+            teleInfo.imei_1 = imei_1;
+            teleInfo.phoneType_1 = phoneType_1;
+
+            Class<?> phoneFactory = Class.forName("com.android.internal.telephony.PhoneFactory");
+            Method getServiceName = phoneFactory.getMethod("getServiceName", String.class, int.class);
+            getServiceName.setAccessible(true);
+            String spreadTmService = (String) getServiceName.invoke(phoneFactory, Context.TELEPHONY_SERVICE, 1);
+
+            TelephonyManager tm2 = (TelephonyManager) context.getSystemService(spreadTmService);
+            String imsi_2 = tm2.getSubscriberId();
+            String imei_2 = tm2.getDeviceId();
+            int phoneType_2 = tm2.getPhoneType();
+            teleInfo.imsi_2 = imsi_2;
+            teleInfo.imei_2 = imei_2;
+            teleInfo.phoneType_2 = phoneType_2;
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        Log.i(TAG, "Spreadtrum: " + teleInfo);
+        return teleInfo;
+    }
+}
Index: app/src/main/res/layout/activity_web_view_demo.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_web_view_demo.xml	(revision )
+++ app/src/main/res/layout/activity_web_view_demo.xml	(revision )
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context="com.scene.sceneandroiddemo.ui.activity.WebViewDemo">
+
+    <WebView
+        android:id="@+id/webView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+</RelativeLayout>
Index: app/src/main/java/com/scene/sceneandroiddemo/BaseApplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/BaseApplication.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/BaseApplication.java	(revision )
@@ -0,0 +1,16 @@
+package com.scene.sceneandroiddemo;
+
+import android.app.Application;
+
+import com.facebook.drawee.backends.pipeline.Fresco;
+
+/**
+ * Created by scene on 16/02/24.
+ */
+public class BaseApplication extends Application {
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Fresco.initialize(this);
+    }
+}
Index: ucrop/src/main/res/values/public.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/values/public.xml	(revision )
+++ ucrop/src/main/res/values/public.xml	(revision )
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <!--Do not expose library resources-->
+    <public/>
+</resources>
\ No newline at end of file
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropImageView.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropImageView.java	(revision )
@@ -0,0 +1,262 @@
+package com.scene.chooseimagelib.simplecropimage;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+import java.util.ArrayList;
+
+class CropImageView extends ImageViewTouchBase {
+
+    ArrayList<HighlightView> mHighlightViews      = new ArrayList<HighlightView>();
+    HighlightView            mMotionHighlightView = null;
+    float mLastX, mLastY;
+    int mMotionEdge;
+
+    private Context mContext;
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top,
+                            int right, int bottom) {
+
+        super.onLayout(changed, left, top, right, bottom);
+        if (mBitmapDisplayed.getBitmap() != null) {
+            for (HighlightView hv : mHighlightViews) {
+                hv.mMatrix.set(getImageMatrix());
+                hv.invalidate();
+                if (hv.mIsFocused) {
+                    centerBasedOnHighlightView(hv);
+                }
+            }
+        }
+    }
+
+    public CropImageView(Context context, AttributeSet attrs) {
+
+        super(context, attrs);
+        this.mContext = context;
+    }
+
+    @Override
+    protected void zoomTo(float scale, float centerX, float centerY) {
+
+        super.zoomTo(scale, centerX, centerY);
+        for (HighlightView hv : mHighlightViews) {
+            hv.mMatrix.set(getImageMatrix());
+            hv.invalidate();
+        }
+    }
+
+    @Override
+    protected void zoomIn() {
+
+        super.zoomIn();
+        for (HighlightView hv : mHighlightViews) {
+            hv.mMatrix.set(getImageMatrix());
+            hv.invalidate();
+        }
+    }
+
+    @Override
+    protected void zoomOut() {
+
+        super.zoomOut();
+        for (HighlightView hv : mHighlightViews) {
+            hv.mMatrix.set(getImageMatrix());
+            hv.invalidate();
+        }
+    }
+
+    @Override
+    protected void postTranslate(float deltaX, float deltaY) {
+
+        super.postTranslate(deltaX, deltaY);
+        for (int i = 0; i < mHighlightViews.size(); i++) {
+            HighlightView hv = mHighlightViews.get(i);
+            hv.mMatrix.postTranslate(deltaX, deltaY);
+            hv.invalidate();
+        }
+    }
+
+    // According to the event's position, change the focus to the first
+    // hitting cropping rectangle.
+    private void recomputeFocus(MotionEvent event) {
+
+        for (int i = 0; i < mHighlightViews.size(); i++) {
+            HighlightView hv = mHighlightViews.get(i);
+            hv.setFocus(false);
+            hv.invalidate();
+        }
+
+        for (int i = 0; i < mHighlightViews.size(); i++) {
+            HighlightView hv = mHighlightViews.get(i);
+            int edge = hv.getHit(event.getX(), event.getY());
+            if (edge != HighlightView.GROW_NONE) {
+                if (!hv.hasFocus()) {
+                    hv.setFocus(true);
+                    hv.invalidate();
+                }
+                break;
+            }
+        }
+        invalidate();
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+
+        CropImage cropImage = (CropImage) mContext;
+        if (cropImage.mSaving) {
+            return false;
+        }
+
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                if (cropImage.mWaitingToPick) {
+                    recomputeFocus(event);
+                } else {
+                    for (int i = 0; i < mHighlightViews.size(); i++) {
+                        HighlightView hv = mHighlightViews.get(i);
+                        int edge = hv.getHit(event.getX(), event.getY());
+                        if (edge != HighlightView.GROW_NONE) {
+                            mMotionEdge = edge;
+                            mMotionHighlightView = hv;
+                            mLastX = event.getX();
+                            mLastY = event.getY();
+                            mMotionHighlightView.setMode(
+                                    (edge == HighlightView.MOVE)
+                                            ? HighlightView.ModifyMode.Move
+                                            : HighlightView.ModifyMode.Grow);
+                            break;
+                        }
+                    }
+                }
+                break;
+            case MotionEvent.ACTION_UP:
+                if (cropImage.mWaitingToPick) {
+                    for (int i = 0; i < mHighlightViews.size(); i++) {
+                        HighlightView hv = mHighlightViews.get(i);
+                        if (hv.hasFocus()) {
+                            cropImage.mCrop = hv;
+                            for (int j = 0; j < mHighlightViews.size(); j++) {
+                                if (j == i) {
+                                    continue;
+                                }
+                                mHighlightViews.get(j).setHidden(true);
+                            }
+                            centerBasedOnHighlightView(hv);
+                            ((CropImage) mContext).mWaitingToPick = false;
+                            return true;
+                        }
+                    }
+                } else if (mMotionHighlightView != null) {
+                    centerBasedOnHighlightView(mMotionHighlightView);
+                    mMotionHighlightView.setMode(
+                            HighlightView.ModifyMode.None);
+                }
+                mMotionHighlightView = null;
+                break;
+            case MotionEvent.ACTION_MOVE:
+                if (cropImage.mWaitingToPick) {
+                    recomputeFocus(event);
+                } else if (mMotionHighlightView != null) {
+                    mMotionHighlightView.handleMotion(mMotionEdge,
+                            event.getX() - mLastX,
+                            event.getY() - mLastY);
+                    mLastX = event.getX();
+                    mLastY = event.getY();
+
+                    if (true) {
+                        // This section of code is optional. It has some user
+                        // benefit in that moving the crop rectangle against
+                        // the edge of the screen causes scrolling but it means
+                        // that the crop rectangle is no longer fixed under
+                        // the user's finger.
+                        ensureVisible(mMotionHighlightView);
+                    }
+                }
+                break;
+        }
+
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_UP:
+                center(true, true);
+                break;
+            case MotionEvent.ACTION_MOVE:
+                // if we're not zoomed then there's no point in even allowing
+                // the user to move the image around.  This call to center puts
+                // it back to the normalized location (with false meaning don't
+                // animate).
+                if (getScale() == 1F) {
+                    center(true, true);
+                }
+                break;
+        }
+
+        return true;
+    }
+
+    // Pan the displayed image to make sure the cropping rectangle is visible.
+    private void ensureVisible(HighlightView hv) {
+
+        Rect r = hv.mDrawRect;
+
+        int panDeltaX1 = Math.max(0, mLeft - r.left);
+        int panDeltaX2 = Math.min(0, mRight - r.right);
+
+        int panDeltaY1 = Math.max(0, mTop - r.top);
+        int panDeltaY2 = Math.min(0, mBottom - r.bottom);
+
+        int panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2;
+        int panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2;
+
+        if (panDeltaX != 0 || panDeltaY != 0) {
+            panBy(panDeltaX, panDeltaY);
+        }
+    }
+
+    // If the cropping rectangle's size changed significantly, change the
+    // view's center and scale according to the cropping rectangle.
+    private void centerBasedOnHighlightView(HighlightView hv) {
+
+        Rect drawRect = hv.mDrawRect;
+
+        float width = drawRect.width();
+        float height = drawRect.height();
+
+        float thisWidth = getWidth();
+        float thisHeight = getHeight();
+
+        float z1 = thisWidth / width * .6F;
+        float z2 = thisHeight / height * .6F;
+
+        float zoom = Math.min(z1, z2);
+        zoom = zoom * this.getScale();
+        zoom = Math.max(1F, zoom);
+        if ((Math.abs(zoom - getScale()) / zoom) > .1) {
+            float[] coordinates = new float[]{hv.mCropRect.centerX(),
+                    hv.mCropRect.centerY()};
+            getImageMatrix().mapPoints(coordinates);
+            zoomTo(zoom, coordinates[0], coordinates[1], 300F);
+        }
+
+        ensureVisible(hv);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+
+        super.onDraw(canvas);
+        for (int i = 0; i < mHighlightViews.size(); i++) {
+            mHighlightViews.get(i).draw(canvas);
+        }
+    }
+
+    public void add(HighlightView hv) {
+
+        mHighlightViews.add(hv);
+        invalidate();
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/RandomUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/RandomUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/RandomUtil.java	(revision )
@@ -0,0 +1,206 @@
+package com.scene.common.common.utils;
+
+import java.util.Random;
+
+/**
+ * 随机工具类
+ * modified form Trinea
+ * @author trinea
+ * @date 2014-12-10
+ */
+public class RandomUtil {
+    public static final String NUMBERS_AND_LETTERS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+    public static final String NUMBERS             = "0123456789";
+    public static final String LETTERS             = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+    public static final String CAPITAL_LETTERS     = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+    public static final String LOWER_CASE_LETTERS  = "abcdefghijklmnopqrstuvwxyz";
+
+    private RandomUtil() {
+        throw new AssertionError();
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of uppercase, lowercase letters and numbers
+     *
+     * @param length
+     * @return
+     * @see RandomUtil#getRandom(String source, int length)
+     */
+    public static String getRandomNumbersAndLetters(int length) {
+        return getRandom(NUMBERS_AND_LETTERS, length);
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of numbers
+     *
+     * @param length
+     * @return
+     * @see RandomUtil#getRandom(String source, int length)
+     */
+    public static String getRandomNumbers(int length) {
+        return getRandom(NUMBERS, length);
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of uppercase and lowercase letters
+     *
+     * @param length
+     * @return
+     * @see RandomUtil#getRandom(String source, int length)
+     */
+    public static String getRandomLetters(int length) {
+        return getRandom(LETTERS, length);
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of uppercase letters
+     *
+     * @param length
+     * @return
+     * @see RandomUtil#getRandom(String source, int length)
+     */
+    public static String getRandomCapitalLetters(int length) {
+        return getRandom(CAPITAL_LETTERS, length);
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of lowercase letters
+     *
+     * @param length
+     * @return
+     * @see RandomUtil#getRandom(String source, int length)
+     */
+    public static String getRandomLowerCaseLetters(int length) {
+        return getRandom(LOWER_CASE_LETTERS, length);
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of chars in source
+     *
+     * @param source
+     * @param length
+     * @return <ul>
+     * <li>if source is null or empty, return null</li>
+     * <li>else see {@link RandomUtil#getRandom(char[] sourceChar, int length)}</li>
+     * </ul>
+     */
+    public static String getRandom(String source, int length) {
+        return source == null ? null : getRandom(source.toCharArray(), length);
+    }
+
+    /**
+     * get a fixed-length random string, its a mixture of chars in sourceChar
+     *
+     * @param sourceChar
+     * @param length
+     * @return <ul>
+     * <li>if sourceChar is null or empty, return null</li>
+     * <li>if length less than 0, return null</li>
+     * </ul>
+     */
+    public static String getRandom(char[] sourceChar, int length) {
+        if (sourceChar == null || sourceChar.length == 0 || length < 0) {
+            return null;
+        }
+
+        StringBuilder str = new StringBuilder(length);
+        Random random = new Random();
+        for (int i = 0; i < length; i++) {
+            str.append(sourceChar[random.nextInt(sourceChar.length)]);
+        }
+        return str.toString();
+    }
+
+    /**
+     * get random int between 0 and max
+     *
+     * @param max
+     * @return <ul>
+     * <li>if max <= 0, return 0</li>
+     * <li>else return random int between 0 and max</li>
+     * </ul>
+     */
+    public static int getRandom(int max) {
+        return getRandom(0, max);
+    }
+
+    /**
+     * get random int between min and max
+     *
+     * @param min
+     * @param max
+     * @return <ul>
+     * <li>if min > max, return 0</li>
+     * <li>if min == max, return min</li>
+     * <li>else return random int between min and max</li>
+     * </ul>
+     */
+    public static int getRandom(int min, int max) {
+        if (min > max) {
+            return 0;
+        }
+        if (min == max) {
+            return min;
+        }
+        return min + new Random().nextInt(max - min);
+    }
+
+    /**
+     * Shuffling algorithm, Randomly permutes the specified array using a default source of randomness
+     */
+    public static boolean shuffle(Object[] objArray) {
+        if (objArray == null) {
+            return false;
+        }
+        return shuffle(objArray, getRandom(objArray.length));
+    }
+
+    /**
+     * Shuffling algorithm, Randomly permutes the specified array
+     */
+    public static boolean shuffle(Object[] objArray, int shuffleCount) {
+        int length;
+        if (objArray == null || shuffleCount < 0 || (length = objArray.length) < shuffleCount) {
+            return false;
+        }
+
+        for (int i = 1; i <= shuffleCount; i++) {
+            int random = getRandom(length - i);
+            Object temp = objArray[length - i];
+            objArray[length - i] = objArray[random];
+            objArray[random] = temp;
+        }
+        return true;
+    }
+
+    /**
+     * Shuffling algorithm, Randomly permutes the specified int array using a default source of randomness
+     */
+    public static int[] shuffle(int[] intArray) {
+        if (intArray == null) {
+            return null;
+        }
+
+        return shuffle(intArray, getRandom(intArray.length));
+    }
+
+    /**
+     * Shuffling algorithm, Randomly permutes the specified int array
+     */
+    public static int[] shuffle(int[] intArray, int shuffleCount) {
+        int length;
+        if (intArray == null || shuffleCount < 0 || (length = intArray.length) < shuffleCount) {
+            return null;
+        }
+
+        int[] out = new int[shuffleCount];
+        for (int i = 1; i <= shuffleCount; i++) {
+            int random = getRandom(length - i);
+            out[i - 1] = intArray[random];
+            int temp = intArray[length - i];
+            intArray[length - i] = intArray[random];
+            intArray[random] = temp;
+        }
+        return out;
+    }
+}
Index: common/src/main/java/com/scene/common/common/io/stream/ByteArrayOutputStream.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/stream/ByteArrayOutputStream.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/stream/ByteArrayOutputStream.java	(revision )
@@ -0,0 +1,357 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io.stream;
+ 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.SequenceInputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * This class implements an output stream in which the data is 
+ * written into a byte array. The buffer automatically grows as data 
+ * is written to it.
+ * <p> 
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an <tt>IOException</tt>.
+ * <p>
+ * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}
+ * class. The original implementation only allocates 32 bytes at the beginning.
+ * As this class is designed for heavy duty it starts at 1024 bytes. In contrast
+ * to the original it doesn't reallocate the whole memory block but allocates
+ * additional buffers. This way no buffers need to be garbage collected and
+ * the contents don't have to be copied to the new buffer. This class is
+ * designed to behave exactly like the original. The only exception is the
+ * deprecated toString(int) method that has been ignored.
+ * 
+ * @version $Id: ByteArrayOutputStream.java 1304052 2012-03-22 20:55:29Z ggregory $
+ */
+public class ByteArrayOutputStream extends OutputStream {
+
+    /** A singleton empty byte array. */
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /** The list of buffers, which grows and never reduces. */
+    private final List<byte[]> buffers = new ArrayList<byte[]>();
+    /** The index of the current buffer. */
+    private int currentBufferIndex;
+    /** The total count of bytes in all the filled buffers. */
+    private int filledBufferSum;
+    /** The current buffer. */
+    private byte[] currentBuffer;
+    /** The total count of bytes written. */
+    private int count;
+
+    /**
+     * Creates a new byte array output stream. The buffer capacity is 
+     * initially 1024 bytes, though its size increases if necessary. 
+     */
+    public ByteArrayOutputStream() {
+        this(1024);
+    }
+
+    /**
+     * Creates a new byte array output stream, with a buffer capacity of 
+     * the specified size, in bytes. 
+     *
+     * @param size  the initial size
+     * @throws IllegalArgumentException if size is negative
+     */
+    public ByteArrayOutputStream(int size) {
+        if (size < 0) {
+            throw new IllegalArgumentException(
+                "Negative initial size: " + size);
+        }
+        synchronized (this) {
+            needNewBuffer(size);
+        }
+    }
+
+    /**
+     * Makes a new buffer available either by allocating
+     * a new one or re-cycling an existing one.
+     *
+     * @param newcount  the size of the buffer if one is created
+     */
+    private void needNewBuffer(int newcount) {
+        if (currentBufferIndex < buffers.size() - 1) {
+            //Recycling old buffer
+            filledBufferSum += currentBuffer.length;
+            
+            currentBufferIndex++;
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Creating new buffer
+            int newBufferSize;
+            if (currentBuffer == null) {
+                newBufferSize = newcount;
+                filledBufferSum = 0;
+            } else {
+                newBufferSize = Math.max(
+                    currentBuffer.length << 1, 
+                    newcount - filledBufferSum);
+                filledBufferSum += currentBuffer.length;
+            }
+            
+            currentBufferIndex++;
+            currentBuffer = new byte[newBufferSize];
+            buffers.add(currentBuffer);
+        }
+    }
+
+    /**
+     * Write the bytes to byte array.
+     * @param b the bytes to write
+     * @param off The start offset
+     * @param len The number of bytes to write
+     */
+    @Override
+    public void write(byte[] b, int off, int len) {
+        if ((off < 0) 
+                || (off > b.length) 
+                || (len < 0) 
+                || ((off + len) > b.length) 
+                || ((off + len) < 0)) {
+            throw new IndexOutOfBoundsException();
+        } else if (len == 0) {
+            return;
+        }
+        synchronized (this) {
+            int newcount = count + len;
+            int remaining = len;
+            int inBufferPos = count - filledBufferSum;
+            while (remaining > 0) {
+                int part = Math.min(remaining, currentBuffer.length - inBufferPos);
+                System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);
+                remaining -= part;
+                if (remaining > 0) {
+                    needNewBuffer(newcount);
+                    inBufferPos = 0;
+                }
+            }
+            count = newcount;
+        }
+    }
+
+    /**
+     * Write a byte to byte array.
+     * @param b the byte to write
+     */
+    @Override
+    public synchronized void write(int b) {
+        int inBufferPos = count - filledBufferSum;
+        if (inBufferPos == currentBuffer.length) {
+            needNewBuffer(count + 1);
+            inBufferPos = 0;
+        }
+        currentBuffer[inBufferPos] = (byte) b;
+        count++;
+    }
+
+    /**
+     * Writes the entire contents of the specified input stream to this
+     * byte stream. Bytes from the input stream are read directly into the
+     * internal buffers of this streams.
+     *
+     * @param in the input stream to read from
+     * @return total number of bytes read from the input stream
+     *         (and written to this stream)
+     * @throws IOException if an I/O error occurs while reading the input stream
+     * @since 1.4
+     */
+    public synchronized int write(InputStream in) throws IOException {
+        int readCount = 0;
+        int inBufferPos = count - filledBufferSum;
+        int n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        while (n != -1) {
+            readCount += n;
+            inBufferPos += n;
+            count += n;
+            if (inBufferPos == currentBuffer.length) {
+                needNewBuffer(currentBuffer.length);
+                inBufferPos = 0;
+            }
+            n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        }
+        return readCount;
+    }
+
+    /**
+     * Return the current size of the byte array.
+     * @return the current size of the byte array
+     */
+    public synchronized int size() {
+        return count;
+    }
+
+    /**
+     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
+     * this class can be called after the stream has been closed without
+     * generating an <tt>IOException</tt>.
+     *
+     * @throws IOException never (this method should not declare this exception
+     * but it has to now due to backwards compatability)
+     */
+    @Override
+    public void close() throws IOException {
+        //nop
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#reset()
+     */
+    public synchronized void reset() {
+        count = 0;
+        filledBufferSum = 0;
+        currentBufferIndex = 0;
+        currentBuffer = buffers.get(currentBufferIndex);
+    }
+
+    /**
+     * Writes the entire contents of this byte stream to the
+     * specified output stream.
+     *
+     * @param out  the output stream to write to
+     * @throws IOException if an I/O error occurs, such as if the stream is closed
+     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
+     */
+    public synchronized void writeTo(OutputStream out) throws IOException {
+        int remaining = count;
+        for (byte[] buf : buffers) {
+            int c = Math.min(buf.length, remaining);
+            out.write(buf, 0, c);
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+    }
+
+    /**
+     * Fetches entire contents of an <code>InputStream</code> and represent
+     * same data as result InputStream.
+     * <p>
+     * This method is useful where,
+     * <ul>
+     * <li>Source InputStream is slow.</li>
+     * <li>It has network resources associated, so we cannot keep it open for
+     * long time.</li>
+     * <li>It has network timeout associated.</li>
+     * </ul>
+     * It can be used in favor of {@link #toByteArray()}, since it
+     * avoids unnecessary allocation and copy of byte[].<br>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * 
+     * @param input Stream to be fully buffered.
+     * @return A fully buffered stream.
+     * @throws IOException if an I/O error occurs
+     * @since 2.0
+     */
+    public static InputStream toBufferedInputStream(InputStream input)
+            throws IOException {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        output.write(input);
+        return output.toBufferedInputStream();
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a Input Stream. The
+     * returned stream is backed by buffers of <code>this</code> stream,
+     * avoiding memory allocation and copy, thus saving space and time.<br>
+     * 
+     * @return the current contents of this output stream.
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     * @see #reset()
+     * @since 2.0
+     */
+    private InputStream toBufferedInputStream() {
+        int remaining = count;
+        if (remaining == 0) {
+            return new ClosedInputStream();
+        }
+        List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>(buffers.size());
+        for (byte[] buf : buffers) {
+            int c = Math.min(buf.length, remaining);
+            list.add(new ByteArrayInputStream(buf, 0, c));
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        return new SequenceInputStream(Collections.enumeration(list));
+    }
+
+    /**
+     * Gets the curent contents of this byte stream as a byte array.
+     * The result is independent of this stream.
+     *
+     * @return the current contents of this output stream, as a byte array
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     */
+    public synchronized byte[] toByteArray() {
+        int remaining = count;
+        if (remaining == 0) {
+            return EMPTY_BYTE_ARRAY; 
+        }
+        byte newbuf[] = new byte[remaining];
+        int pos = 0;
+        for (byte[] buf : buffers) {
+            int c = Math.min(buf.length, remaining);
+            System.arraycopy(buf, 0, newbuf, pos, c);
+            pos += c;
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        return newbuf;
+    }
+
+    /**
+     * Gets the curent contents of this byte stream as a string.
+     * @return the contents of the byte array as a String
+     * @see java.io.ByteArrayOutputStream#toString()
+     */
+    @Override
+    public String toString() {
+        return new String(toByteArray());
+    }
+
+    /**
+     * Gets the curent contents of this byte stream as a string
+     * using the specified encoding.
+     *
+     * @param enc  the name of the character encoding
+     * @return the string converted from the byte array
+     * @throws UnsupportedEncodingException if the encoding is not supported
+     * @see java.io.ByteArrayOutputStream#toString(String)
+     */
+    public String toString(String enc) throws UnsupportedEncodingException {
+        return new String(toByteArray(), enc);
+    }
+
+}
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision )
+++ .idea/gradle.xml	(revision )
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="GradleSettings">
+    <option name="linkedExternalProjectsSettings">
+      <GradleProjectSettings>
+        <option name="distributionType" value="LOCAL" />
+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
+        <option name="gradleHome" value="D:\开发环境\android-studio1.5.1\android-studio\gradle\gradle-2.8" />
+        <option name="gradleJvm" value="1.8" />
+        <option name="modules">
+          <set>
+            <option value="$PROJECT_DIR$" />
+            <option value="$PROJECT_DIR$/app" />
+            <option value="$PROJECT_DIR$/chooseimagelib" />
+            <option value="$PROJECT_DIR$/common" />
+            <option value="$PROJECT_DIR$/customfresco" />
+            <option value="$PROJECT_DIR$/easypermissions" />
+            <option value="$PROJECT_DIR$/mylib" />
+            <option value="$PROJECT_DIR$/timeline" />
+            <option value="$PROJECT_DIR$/ucrop" />
+          </set>
+        </option>
+      </GradleProjectSettings>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: chooseimagelib/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/build.gradle	(revision )
+++ chooseimagelib/build.gradle	(revision )
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+}
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropImage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropImage.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/CropImage.java	(revision )
@@ -0,0 +1,683 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.chooseimagelib.simplecropimage;
+
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.CountDownLatch;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Path;
+import android.graphics.PointF;
+import android.graphics.PorterDuff;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.Region;
+import android.media.FaceDetector;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.StatFs;
+import android.util.Log;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.scene.chooseimagelib.R;
+
+
+/**
+ * The activity can crop specific region of interest from an image.
+ */
+public class CropImage extends MonitoredActivity {
+
+    final int IMAGE_MAX_SIZE = 1024;
+
+    private static final String TAG = "CropImage";
+    public static final String IMAGE_PATH = "image-path";
+    public static final String IMAGE_SAVE_PATH = "image-save-path";
+    public static final String SCALE = "scale";
+    public static final String ORIENTATION_IN_DEGREES = "orientation_in_degrees";
+    public static final String ASPECT_X = "aspectX";
+    public static final String ASPECT_Y = "aspectY";
+    public static final String OUTPUT_X = "outputX";
+    public static final String OUTPUT_Y = "outputY";
+    public static final String SCALE_UP_IF_NEEDED = "scaleUpIfNeeded";
+    public static final String CIRCLE_CROP = "circleCrop";
+    public static final String RETURN_DATA = "return-data";
+    public static final String RETURN_DATA_AS_BITMAP = "data";
+    public static final String ACTION_INLINE_DATA = "inline-data";
+
+    // These are various options can be specified in the intent.
+    private Bitmap.CompressFormat mOutputFormat = Bitmap.CompressFormat.JPEG;
+    private Uri mSaveUri = null;
+    private boolean mDoFaceDetection = true;
+    private boolean mCircleCrop = false;
+    private final Handler mHandler = new Handler();
+
+    private int mAspectX;
+    private int mAspectY;
+    private int mOutputX;
+    private int mOutputY;
+    private boolean mScale;
+    private CropImageView mImageView;
+    private ContentResolver mContentResolver;
+    private Bitmap mBitmap;
+    private String mImagePath;
+
+    boolean mWaitingToPick; // Whether we are wait the user to pick a face.
+    boolean mSaving;  // Whether the "save" button is already clicked.
+    HighlightView mCrop;
+
+    // These options specifiy the output image size and whether we should
+    // scale the output to fit it (or just crop it).
+    private boolean mScaleUp = true;
+
+    private final BitmapManager.ThreadSet mDecodingThreads =
+            new BitmapManager.ThreadSet();
+
+    @Override
+    public void onCreate(Bundle icicle) {
+
+        super.onCreate(icicle);
+        mContentResolver = getContentResolver();
+
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        setContentView(R.layout.cropimage);
+
+        mImageView = (CropImageView) findViewById(R.id.image);
+
+        showStorageToast(this);
+
+        Intent intent = getIntent();
+        Bundle extras = intent.getExtras();
+        if (extras != null) {
+
+            if (extras.getString(CIRCLE_CROP) != null) {
+
+                if (Build.VERSION.SDK_INT > Build.VERSION_CODES.HONEYCOMB) {
+                    mImageView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
+                }
+
+                mCircleCrop = true;
+                mAspectX = 1;
+                mAspectY = 1;
+            }
+
+            mImagePath = extras.getString(IMAGE_PATH);
+
+            mSaveUri = extras.getParcelable(IMAGE_SAVE_PATH);
+            mBitmap = getBitmap(mImagePath);
+
+            if (extras.containsKey(ASPECT_X) && extras.get(ASPECT_X) instanceof Integer) {
+
+                mAspectX = extras.getInt(ASPECT_X);
+            } else {
+
+                throw new IllegalArgumentException("aspect_x must be integer");
+            }
+            if (extras.containsKey(ASPECT_Y) && extras.get(ASPECT_Y) instanceof Integer) {
+
+                mAspectY = extras.getInt(ASPECT_Y);
+            } else {
+
+                throw new IllegalArgumentException("aspect_y must be integer");
+            }
+            mOutputX = extras.getInt(OUTPUT_X);
+            mOutputY = extras.getInt(OUTPUT_Y);
+            mScale = extras.getBoolean(SCALE, true);
+            mScaleUp = extras.getBoolean(SCALE_UP_IF_NEEDED, true);
+        }
+
+
+        if (mBitmap == null) {
+
+            Log.d(TAG, "finish!!!");
+            finish();
+            return;
+        }
+
+        // Make UI fullscreen.
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
+
+        findViewById(R.id.discard).setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+
+                        setResult(RESULT_CANCELED);
+                        finish();
+                    }
+                });
+
+        findViewById(R.id.save).setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+
+                        try {
+                            onSaveClicked();
+                        } catch (Exception e) {
+                            finish();
+                        }
+                    }
+                });
+        findViewById(R.id.rotateLeft).setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+
+                        mBitmap = CropUtil.rotateImage(mBitmap, -90);
+                        RotateBitmap rotateBitmap = new RotateBitmap(mBitmap);
+                        mImageView.setImageRotateBitmapResetBase(rotateBitmap, true);
+                        mRunFaceDetection.run();
+                    }
+                });
+
+        findViewById(R.id.rotateRight).setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+
+                        mBitmap = CropUtil.rotateImage(mBitmap, 90);
+                        RotateBitmap rotateBitmap = new RotateBitmap(mBitmap);
+                        mImageView.setImageRotateBitmapResetBase(rotateBitmap, true);
+                        mRunFaceDetection.run();
+                    }
+                });
+        startFaceDetection();
+    }
+
+    private Uri getImageUri(String path) {
+
+        return Uri.fromFile(new File(path));
+    }
+
+    private Bitmap getBitmap(String path) {
+
+        Uri uri = getImageUri(path);
+        InputStream in = null;
+        try {
+            in = mContentResolver.openInputStream(uri);
+
+            //Decode image size
+            BitmapFactory.Options o = new BitmapFactory.Options();
+            o.inJustDecodeBounds = true;
+
+            BitmapFactory.decodeStream(in, null, o);
+            in.close();
+
+            int scale = 1;
+            if (o.outHeight > IMAGE_MAX_SIZE || o.outWidth > IMAGE_MAX_SIZE) {
+                scale = (int) Math.pow(2, (int) Math.round(Math.log(IMAGE_MAX_SIZE / (double) Math.max(o.outHeight, o.outWidth)) / Math.log(0.5)));
+            }
+
+            BitmapFactory.Options o2 = new BitmapFactory.Options();
+            o2.inSampleSize = scale;
+            in = mContentResolver.openInputStream(uri);
+            Bitmap b = BitmapFactory.decodeStream(in, null, o2);
+            in.close();
+
+            return b;
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "file " + path + " not found");
+        } catch (IOException e) {
+            Log.e(TAG, "file " + path + " not found");
+        }
+        return null;
+    }
+
+
+    private void startFaceDetection() {
+
+        if (isFinishing()) {
+            return;
+        }
+
+        mImageView.setImageBitmapResetBase(mBitmap, true);
+
+        CropUtil.startBackgroundJob(this, null,
+                "Please wait\u2026",
+                new Runnable() {
+                    public void run() {
+
+                        final CountDownLatch latch = new CountDownLatch(1);
+                        final Bitmap b = mBitmap;
+                        mHandler.post(new Runnable() {
+                            public void run() {
+
+                                if (b != mBitmap && b != null) {
+                                    mImageView.setImageBitmapResetBase(b, true);
+                                    mBitmap.recycle();
+                                    mBitmap = b;
+                                }
+                                if (mImageView.getScale() == 1F) {
+                                    mImageView.center(true, true);
+                                }
+                                latch.countDown();
+                            }
+                        });
+                        try {
+                            latch.await();
+                        } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                        }
+                        mRunFaceDetection.run();
+                    }
+                }, mHandler);
+    }
+
+
+    private void onSaveClicked() throws Exception {
+        // TODO this code needs to change to use the decode/crop/encode single
+        // step api so that we don't require that the whole (possibly large)
+        // bitmap doesn't have to be read into memory
+        if (mSaving) return;
+
+        if (mCrop == null) {
+
+            return;
+        }
+
+        mSaving = true;
+
+        Rect r = mCrop.getCropRect();
+
+        int width = r.width();
+        int height = r.height();
+
+        // If we are circle cropping, we want alpha channel, which is the
+        // third param here.
+        Bitmap croppedImage;
+        try {
+
+            croppedImage = Bitmap.createBitmap(width, height,
+                    mCircleCrop ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+        } catch (Exception e) {
+            throw e;
+        }
+        if (croppedImage == null) {
+
+            return;
+        }
+
+        {
+            Canvas canvas = new Canvas(croppedImage);
+            Rect dstRect = new Rect(0, 0, width, height);
+            canvas.drawBitmap(mBitmap, r, dstRect, null);
+        }
+
+        if (mCircleCrop) {
+
+            // OK, so what's all this about?
+            // Bitmaps are inherently rectangular but we want to return
+            // something that's basically a circle.  So we fill in the
+            // area around the circle with alpha.  Note the all important
+            // PortDuff.Mode.CLEAR.
+            Canvas c = new Canvas(croppedImage);
+            Path p = new Path();
+            p.addCircle(width / 2F, height / 2F, width / 2F,
+                    Path.Direction.CW);
+            c.clipPath(p, Region.Op.DIFFERENCE);
+            c.drawColor(0x00000000, PorterDuff.Mode.CLEAR);
+        }
+
+		/* If the output is required to a specific size then scale or fill */
+        if (mOutputX != 0 && mOutputY != 0) {
+
+            if (mScale) {
+
+                /* Scale the image to the required dimensions */
+                Bitmap old = croppedImage;
+                croppedImage = CropUtil.transform(new Matrix(),
+                        croppedImage, mOutputX, mOutputY, mScaleUp);
+                if (old != croppedImage) {
+
+                    old.recycle();
+                }
+            } else {
+
+				/* Don't scale the image crop it to the size requested.
+                 * Create an new image with the cropped image in the center and
+				 * the extra space filled.
+				 */
+
+                // Don't scale the image but instead fill it so it's the
+                // required dimension
+                Bitmap b = Bitmap.createBitmap(mOutputX, mOutputY,
+                        Bitmap.Config.RGB_565);
+                Canvas canvas = new Canvas(b);
+
+                Rect srcRect = mCrop.getCropRect();
+                Rect dstRect = new Rect(0, 0, mOutputX, mOutputY);
+
+                int dx = (srcRect.width() - dstRect.width()) / 2;
+                int dy = (srcRect.height() - dstRect.height()) / 2;
+
+				/* If the srcRect is too big, use the center part of it. */
+                srcRect.inset(Math.max(0, dx), Math.max(0, dy));
+
+				/* If the dstRect is too big, use the center part of it. */
+                dstRect.inset(Math.max(0, -dx), Math.max(0, -dy));
+
+				/* Draw the cropped bitmap in the center */
+                canvas.drawBitmap(mBitmap, srcRect, dstRect, null);
+
+				/* Set the cropped bitmap as the new bitmap */
+                croppedImage.recycle();
+                croppedImage = b;
+            }
+        }
+
+        // Return the cropped image directly or save it to the specified URI.
+        Bundle myExtras = getIntent().getExtras();
+        if (myExtras != null && (myExtras.getParcelable("data") != null
+                || myExtras.getBoolean(RETURN_DATA))) {
+
+            Bundle extras = new Bundle();
+            extras.putParcelable(RETURN_DATA_AS_BITMAP, croppedImage);
+            setResult(RESULT_OK,
+                    (new Intent()).setAction(ACTION_INLINE_DATA).putExtras(extras));
+            finish();
+        } else {
+            final Bitmap b = croppedImage;
+            CropUtil.startBackgroundJob(this, null, getString(R.string.saving_image),
+                    new Runnable() {
+                        public void run() {
+
+                            saveOutput(b);
+                        }
+                    }, mHandler);
+        }
+    }
+
+    private void saveOutput(Bitmap croppedImage) {
+
+        if (mSaveUri != null) {
+            OutputStream outputStream = null;
+            try {
+                outputStream = mContentResolver.openOutputStream(mSaveUri);
+                if (outputStream != null) {
+                    croppedImage.compress(mOutputFormat, 90, outputStream);
+                }
+            } catch (IOException ex) {
+
+                Log.e(TAG, "Cannot open file: " + mSaveUri, ex);
+                setResult(RESULT_CANCELED);
+                finish();
+                return;
+            } finally {
+
+                CropUtil.closeSilently(outputStream);
+            }
+
+            Bundle extras = new Bundle();
+            Intent intent = new Intent(mSaveUri.toString());
+            intent.putExtras(extras);
+            intent.putExtra(IMAGE_PATH, mImagePath);
+            intent.putExtra(ORIENTATION_IN_DEGREES, CropUtil.getOrientationInDegree(this));
+            setResult(RESULT_OK, intent);
+        } else {
+
+            Log.e(TAG, "not defined image url");
+        }
+        croppedImage.recycle();
+        finish();
+    }
+
+    @Override
+    protected void onPause() {
+
+        super.onPause();
+        BitmapManager.instance().cancelThreadDecoding(mDecodingThreads);
+    }
+
+    @Override
+    protected void onDestroy() {
+
+        super.onDestroy();
+
+        if (mBitmap != null) {
+
+            mBitmap.recycle();
+        }
+    }
+
+
+    Runnable mRunFaceDetection = new Runnable() {
+        @SuppressWarnings("hiding")
+        float mScale = 1F;
+        Matrix mImageMatrix;
+        FaceDetector.Face[] mFaces = new FaceDetector.Face[3];
+        int mNumFaces;
+
+        // For each face, we create a HightlightView for it.
+        private void handleFace(FaceDetector.Face f) {
+
+            PointF midPoint = new PointF();
+
+            int r = ((int) (f.eyesDistance() * mScale)) * 2;
+            f.getMidPoint(midPoint);
+            midPoint.x *= mScale;
+            midPoint.y *= mScale;
+
+            int midX = (int) midPoint.x;
+            int midY = (int) midPoint.y;
+
+            HighlightView hv = new HighlightView(mImageView);
+
+            int width = mBitmap.getWidth();
+            int height = mBitmap.getHeight();
+
+            Rect imageRect = new Rect(0, 0, width, height);
+
+            RectF faceRect = new RectF(midX, midY, midX, midY);
+            faceRect.inset(-r, -r);
+            if (faceRect.left < 0) {
+                faceRect.inset(-faceRect.left, -faceRect.left);
+            }
+
+            if (faceRect.top < 0) {
+                faceRect.inset(-faceRect.top, -faceRect.top);
+            }
+
+            if (faceRect.right > imageRect.right) {
+                faceRect.inset(faceRect.right - imageRect.right,
+                        faceRect.right - imageRect.right);
+            }
+
+            if (faceRect.bottom > imageRect.bottom) {
+                faceRect.inset(faceRect.bottom - imageRect.bottom,
+                        faceRect.bottom - imageRect.bottom);
+            }
+
+            hv.setup(mImageMatrix, imageRect, faceRect, mCircleCrop,
+                    mAspectX != 0 && mAspectY != 0);
+
+            mImageView.add(hv);
+        }
+
+        // Create a default HightlightView if we found no face in the picture.
+        private void makeDefault() {
+
+            HighlightView hv = new HighlightView(mImageView);
+
+            int width = mBitmap.getWidth();
+            int height = mBitmap.getHeight();
+
+            Rect imageRect = new Rect(0, 0, width, height);
+
+            // make the default size about 4/5 of the width or height
+            int cropWidth = Math.min(width, height) * 4 / 5;
+            int cropHeight = cropWidth;
+
+            if (mAspectX != 0 && mAspectY != 0) {
+
+                if (mAspectX > mAspectY) {
+
+                    cropHeight = cropWidth * mAspectY / mAspectX;
+                } else {
+
+                    cropWidth = cropHeight * mAspectX / mAspectY;
+                }
+            }
+
+            int x = (width - cropWidth) / 2;
+            int y = (height - cropHeight) / 2;
+
+            RectF cropRect = new RectF(x, y, x + cropWidth, y + cropHeight);
+            hv.setup(mImageMatrix, imageRect, cropRect, mCircleCrop,
+                    mAspectX != 0 && mAspectY != 0);
+
+            mImageView.mHighlightViews.clear(); // Thong added for rotate
+
+            mImageView.add(hv);
+        }
+
+        // Scale the image down for faster face detection.
+        private Bitmap prepareBitmap() {
+
+            if (mBitmap == null) {
+
+                return null;
+            }
+
+            // 256 pixels wide is enough.
+            if (mBitmap.getWidth() > 256) {
+
+                mScale = 256.0F / mBitmap.getWidth();
+            }
+            Matrix matrix = new Matrix();
+            matrix.setScale(mScale, mScale);
+            return Bitmap.createBitmap(mBitmap, 0, 0, mBitmap.getWidth(), mBitmap.getHeight(), matrix, true);
+        }
+
+        public void run() {
+
+            mImageMatrix = mImageView.getImageMatrix();
+            Bitmap faceBitmap = prepareBitmap();
+
+            mScale = 1.0F / mScale;
+            if (faceBitmap != null && mDoFaceDetection) {
+                FaceDetector detector = new FaceDetector(faceBitmap.getWidth(),
+                        faceBitmap.getHeight(), mFaces.length);
+                mNumFaces = detector.findFaces(faceBitmap, mFaces);
+            }
+
+            if (faceBitmap != null && faceBitmap != mBitmap) {
+                faceBitmap.recycle();
+            }
+
+            mHandler.post(new Runnable() {
+                public void run() {
+
+                    mWaitingToPick = mNumFaces > 1;
+                    if (mNumFaces > 0) {
+                        for (int i = 0; i < mNumFaces; i++) {
+                            handleFace(mFaces[i]);
+                        }
+                    } else {
+                        makeDefault();
+                    }
+                    mImageView.invalidate();
+                    if (mImageView.mHighlightViews.size() == 1) {
+                        mCrop = mImageView.mHighlightViews.get(0);
+                        mCrop.setFocus(true);
+                    }
+
+                    if (mNumFaces > 1) {
+                        Toast.makeText(CropImage.this,
+                                "Multi face crop help",
+                                Toast.LENGTH_SHORT).show();
+                    }
+                }
+            });
+        }
+    };
+
+    public static final int NO_STORAGE_ERROR = -1;
+    public static final int CANNOT_STAT_ERROR = -2;
+
+    public static void showStorageToast(Activity activity) {
+
+        showStorageToast(activity, calculatePicturesRemaining(activity));
+    }
+
+    public static void showStorageToast(Activity activity, int remaining) {
+
+        String noStorageText = null;
+
+        if (remaining == NO_STORAGE_ERROR) {
+
+            String state = Environment.getExternalStorageState();
+            if (state.equals(Environment.MEDIA_CHECKING)) {
+
+                noStorageText = activity.getString(R.string.preparing_card);
+            } else {
+
+                noStorageText = activity.getString(R.string.no_storage_card);
+            }
+        } else if (remaining < 1) {
+
+            noStorageText = activity.getString(R.string.not_enough_space);
+        }
+
+        if (noStorageText != null) {
+
+            Toast.makeText(activity, noStorageText, Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    public static int calculatePicturesRemaining(Activity activity) {
+
+        try {
+            /*if (!ImageManager.hasStorage()) {
+                return NO_STORAGE_ERROR;
+            } else {*/
+            String storageDirectory = "";
+            String state = Environment.getExternalStorageState();
+            if (Environment.MEDIA_MOUNTED.equals(state)) {
+                storageDirectory = Environment.getExternalStorageDirectory().toString();
+            } else {
+                storageDirectory = activity.getFilesDir().toString();
+            }
+            StatFs stat = new StatFs(storageDirectory);
+            float remaining = ((float) stat.getAvailableBlocks()
+                    * (float) stat.getBlockSize()) / 400000F;
+            return (int) remaining;
+            //}
+        } catch (Exception ex) {
+            // if we can't stat the filesystem then we don't know how many
+            // pictures are remaining.  it might be zero but just leave it
+            // blank since we really don't know.
+            return CANNOT_STAT_ERROR;
+        }
+    }
+
+
+}
+
+
Index: mylib/src/main/java/com/scene/mylib/view/tab/CustomPagerSlidingTabStrip.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/tab/CustomPagerSlidingTabStrip.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/tab/CustomPagerSlidingTabStrip.java	(revision )
@@ -0,0 +1,605 @@
+package com.scene.mylib.view.tab;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.os.Build;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.SparseArray;
+import android.util.TypedValue;
+import android.view.View;
+import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+import android.widget.HorizontalScrollView;
+import android.widget.LinearLayout;
+
+import com.scene.mylib.R;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Locale;
+
+/**
+ * Created by linhomhom on 2015/9/22.
+ */
+public class CustomPagerSlidingTabStrip extends HorizontalScrollView {
+
+    public interface CustomTabProvider{
+        public View getSelectTabView(int position, View convertView);
+        public View getDisSelectTabView(int position, View convertView);
+    }
+    // @formatter:on
+
+    private LinearLayout.LayoutParams defaultTabLayoutParams;
+    private LinearLayout.LayoutParams expandedTabLayoutParams;
+
+    private final PageListener pageListener = new PageListener();
+    public ViewPager.OnPageChangeListener delegatePageListener;
+
+    private LinearLayout tabsContainer;
+    private ViewPager pager;
+
+    private int tabCount;
+
+    private int currentPosition = 0;
+    private float currentPositionOffset = 0f;
+
+    private Paint rectPaint;
+    private Paint dividerPaint;
+
+    private boolean checkedTabWidths = false;
+
+    private int indicatorColor = 0xFF666666;
+    private int underlineColor = 0x1A000000;
+    private int dividerColor = 0x1A000000;
+
+    private boolean shouldExpand = true;
+
+    private int scrollOffset = 52;
+    private int indicatorHeight = 3;
+    private int underlineHeight = 2;
+    private int dividerPadding = 12;
+    private int tabPadding = 24;
+    private int tabPaddingTopBottom = 0;
+    private int dividerWidth = 1;
+
+    private int lastScrollX = 0;
+
+    private int tabBackgroundResId = R.drawable.psts_background_tab;
+//    private int tabBackgroundResId;
+
+    private Locale locale;
+
+    public CustomPagerSlidingTabStrip(Context context) {
+        this(context, null);
+    }
+
+    public CustomPagerSlidingTabStrip(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public CustomPagerSlidingTabStrip(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        setFillViewport(true);
+        setWillNotDraw(false);
+
+        tabsContainer = new LinearLayout(context);
+        tabsContainer.setOrientation(LinearLayout.HORIZONTAL);
+        tabsContainer.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        addView(tabsContainer);
+
+        DisplayMetrics dm = getResources().getDisplayMetrics();
+
+        scrollOffset = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, scrollOffset, dm);
+        indicatorHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, indicatorHeight, dm);
+        underlineHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, underlineHeight, dm);
+        dividerPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerPadding, dm);
+        tabPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, tabPadding, dm);
+        dividerWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerWidth, dm);
+
+        // get system attrs (android:textSize and android:textColor)
+
+        TypedArray a = null;
+
+        // get custom attrs
+
+
+        a = context.obtainStyledAttributes(attrs, R.styleable.AdvancedPagerSlidingTabStrip);
+
+        indicatorColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewIndicatorColor, indicatorColor);
+        underlineColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewUnderlineColor, underlineColor);
+        dividerColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewDividerColor, dividerColor);
+        indicatorHeight = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewIndicatorHeight, indicatorHeight);
+        underlineHeight = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewUnderlineHeight, underlineHeight);
+        dividerPadding = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewDividerPadding, dividerPadding);
+        tabPadding = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewPaddingLeftRight, tabPadding);
+        tabPaddingTopBottom = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewPaddingTopBottom, tabPaddingTopBottom);
+        tabBackgroundResId = a.getResourceId(R.styleable.AdvancedPagerSlidingTabStrip_tabViewBackground, tabBackgroundResId);
+        shouldExpand = a.getBoolean(R.styleable.AdvancedPagerSlidingTabStrip_tabViewShouldExpand, shouldExpand);
+        scrollOffset = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewScrollOffset, scrollOffset);
+
+        a.recycle();
+
+        rectPaint = new Paint();
+        rectPaint.setAntiAlias(true);
+        rectPaint.setStyle(Style.FILL);
+
+        dividerPaint = new Paint();
+        dividerPaint.setAntiAlias(true);
+        dividerPaint.setStrokeWidth(dividerWidth);
+
+        defaultTabLayoutParams = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+        expandedTabLayoutParams = new LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f);
+
+        if (locale == null) {
+            locale = getResources().getConfiguration().locale;
+        }
+
+        if(mDisSelectTabViewCache == null){
+            mDisSelectTabViewCache = new SparseArray<>();
+        }
+        if(mSelectTabViewCache == null){
+            mSelectTabViewCache = new SparseArray<>();
+        }
+    }
+
+    public void setViewPager(ViewPager pager) {
+        this.pager = pager;
+
+        if (pager.getAdapter() == null) {
+            throw new IllegalStateException("ViewPager does not have adapter instance.");
+        }
+
+        pager.addOnPageChangeListener(pageListener);
+
+        notifyDataSetChanged();
+    }
+
+    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
+        this.delegatePageListener = listener;
+    }
+
+    public void notifyDataSetChanged() {
+
+        tabsContainer.removeAllViews();
+
+        tabCount = pager.getAdapter().getCount();
+
+        for (int i = 0; i < tabCount; i++) {
+
+            if (pager.getAdapter() instanceof CustomTabProvider) {
+                View view = ((CustomTabProvider) pager.getAdapter()).getSelectTabView(i, getSelectTabView(i));
+                setSelectTabView(i, view);
+                updateViewStyle(view);
+                addTab(i, view);
+            }
+
+        }
+
+//        updateTabStyles();
+
+        checkedTabWidths = false;
+
+        getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
+
+            @SuppressWarnings("deprecation")
+            @SuppressLint("NewApi")
+            @Override
+            public void onGlobalLayout() {
+
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                }
+
+                currentPosition = pager.getCurrentItem();
+                scrollToChild(currentPosition, 0);
+            }
+        });
+
+        pageListener.onPageSelected(0);//default
+
+    }
+
+    private PageOnClickListener mPageOnClickListener;
+
+    private void addTab(final int position, View view){
+        if(mPageOnClickListener == null){
+            mPageOnClickListener = new PageOnClickListener();
+        }
+        view.setTag(R.id.tag_position, position);
+        view.setOnClickListener(mPageOnClickListener);
+        tabsContainer.addView(view);
+    }
+
+    public View getTabAt(int pos) {
+        if (pos >= tabsContainer.getChildCount()) {
+            throw new IllegalStateException("pos is too big.");
+        }
+        return tabsContainer.getChildAt(pos);
+    }
+
+    private void updateTabStyles() {
+
+        for (int i = 0; i < tabCount; i++) {
+
+            View v = tabsContainer.getChildAt(i);
+
+            //v.setLayoutParams(defaultTabLayoutParams);
+            //my modify
+            updateViewStyle(v);
+        }
+
+    }
+
+    public void updateViewStyle(View v){
+        v.setLayoutParams(expandedTabLayoutParams);
+        v.setBackgroundResource(tabBackgroundResId);
+        if (shouldExpand) {
+            v.setPadding(0, 0, 0, 0);
+        } else {
+            v.setPadding(tabPadding, tabPaddingTopBottom, tabPadding, tabPaddingTopBottom);
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        if (!shouldExpand || MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.UNSPECIFIED) {
+            return;
+        }
+
+        int myWidth = getMeasuredWidth();
+        int childWidth = 0;
+        for (int i = 0; i < tabCount; i++) {
+            childWidth += tabsContainer.getChildAt(i).getMeasuredWidth();
+        }
+
+        if (!checkedTabWidths && childWidth > 0 && myWidth > 0) {
+
+            if (childWidth <= myWidth) {
+                for (int i = 0; i < tabCount; i++) {
+                    tabsContainer.getChildAt(i).setLayoutParams(expandedTabLayoutParams);
+                }
+            }
+
+            checkedTabWidths = true;
+        }
+    }
+
+    private void scrollToChild(int position, int offset) {
+
+        if (tabCount == 0) {
+            return;
+        }
+
+        int newScrollX = tabsContainer.getChildAt(position).getLeft() + offset;
+
+        if (position > 0 || offset > 0) {
+            newScrollX -= scrollOffset;
+        }
+
+        if (newScrollX != lastScrollX) {
+            lastScrollX = newScrollX;
+            scrollTo(newScrollX, 0);
+        }
+
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (isInEditMode() || tabCount == 0) {
+            return;
+        }
+
+        drawTabNormalMode(canvas);
+    }
+
+    private void drawTabNormalMode(Canvas canvas){
+        final int height = getHeight();
+
+        // 设置提示下划线的颜色
+
+        rectPaint.setColor(indicatorColor);
+
+        // default: line below current tab
+        View currentTab = tabsContainer.getChildAt(currentPosition);
+        float lineLeft = currentTab.getLeft();
+        float lineRight = currentTab.getRight();
+
+        // if there is an offset, start interpolating left and right coordinates between current and next tab
+        if (currentPositionOffset > 0f && currentPosition < tabCount - 1) {
+
+            View nextTab = tabsContainer.getChildAt(currentPosition + 1);
+            final float nextTabLeft = nextTab.getLeft();
+            final float nextTabRight = nextTab.getRight();
+
+            lineLeft = (currentPositionOffset * nextTabLeft + (1f - currentPositionOffset) * lineLeft);
+            lineRight = (currentPositionOffset * nextTabRight + (1f - currentPositionOffset) * lineRight);
+
+        }
+
+        //绘制提示下划线
+        canvas.drawRect(lineLeft , height - indicatorHeight, lineRight , height, rectPaint);
+
+        // 绘制下划线
+
+        rectPaint.setColor(underlineColor);
+        canvas.drawRect(0, height - underlineHeight, tabsContainer.getWidth(), height, rectPaint);
+
+        // 绘制分割线
+
+        dividerPaint.setColor(dividerColor);
+
+        for (int i = 0; i < tabCount - 1; i++) {
+            View tab = tabsContainer.getChildAt(i);
+            canvas.drawLine(tab.getRight(), dividerPadding, tab.getRight(), height - dividerPadding, dividerPaint);
+        }
+    }
+
+    private class PageListener implements ViewPager.OnPageChangeListener {
+
+        @Override
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+
+            currentPosition = position;
+            currentPositionOffset = positionOffset;
+
+            scrollToChild(position, (int) (positionOffset * tabsContainer.getChildAt(position).getWidth()));
+
+            invalidate();
+
+            if (delegatePageListener != null) {
+                delegatePageListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
+            }
+        }
+
+        @Override
+        public void onPageScrollStateChanged(int state) {
+            if (state == ViewPager.SCROLL_STATE_IDLE) {
+                scrollToChild(pager.getCurrentItem(), 0);
+            }
+
+            if (delegatePageListener != null) {
+                delegatePageListener.onPageScrollStateChanged(state);
+            }
+        }
+
+        @Override
+        public void onPageSelected(int position) {
+
+            setSelectItem(position);
+
+            if (delegatePageListener != null) {
+                delegatePageListener.onPageSelected(position);
+            }
+        }
+
+    }
+
+    private SparseArray<View> mDisSelectTabViewCache;//缓存
+
+    private View getDisSelectTabView(int position){
+        return mDisSelectTabViewCache.get(position);
+    }
+
+    private void setDisSelectTabView(int position , View view){
+        mDisSelectTabViewCache.put(position,view);
+    }
+
+    private SparseArray<View> mSelectTabViewCache;//缓存
+
+    private View getSelectTabView(int position){
+        return mSelectTabViewCache.get(position);
+    }
+
+    private void setSelectTabView( int position ,View view){
+        mSelectTabViewCache.put(position,view);
+    }
+
+    class PageOnClickListener implements OnClickListener{
+
+        @Override
+        public void onClick(View view) {
+            int tag = (int)view.getTag(R.id.tag_position);
+            scrollToChild(tag, 0);
+            pager.setCurrentItem(tag);
+        }
+    }
+
+    public void setSelectItem(int position){
+        if (!(pager.getAdapter() instanceof CustomTabProvider)) {
+            return;
+        }
+        for (int i = 0; i < tabsContainer.getChildCount(); i++) {
+
+            tabsContainer.removeViewAt(i);
+
+            View view = null;
+
+            if (i == position) {
+                view = ((CustomTabProvider) pager.getAdapter()).getSelectTabView(i, getSelectTabView(i));
+                setSelectTabView(i, view);
+
+            } else {
+                view = ((CustomTabProvider) pager.getAdapter()).getDisSelectTabView(i, getDisSelectTabView(i));
+                setDisSelectTabView(i, view);
+            }
+
+            view.setTag(R.id.tag_position, i);
+
+            if(mPageOnClickListener == null){
+                mPageOnClickListener = new PageOnClickListener();
+            }
+
+            view.setOnClickListener(mPageOnClickListener);
+
+            tabsContainer.addView(view, i);
+
+            updateViewStyle(view);
+        }
+    }
+
+    public void setIndicatorColor(int indicatorColor) {
+        this.indicatorColor = indicatorColor;
+        invalidate();
+    }
+
+    public void setIndicatorColorResource(int resId) {
+        this.indicatorColor = getResources().getColor(resId);
+        invalidate();
+    }
+
+    public int getIndicatorColor() {
+        return this.indicatorColor;
+    }
+
+    public void setIndicatorHeight(int indicatorLineHeightPx) {
+        this.indicatorHeight = indicatorLineHeightPx;
+        invalidate();
+    }
+
+    public int getIndicatorHeight() {
+        return indicatorHeight;
+    }
+
+    public void setUnderlineColor(int underlineColor) {
+        this.underlineColor = underlineColor;
+        invalidate();
+    }
+
+    public void setUnderlineColorResource(int resId) {
+        this.underlineColor = getResources().getColor(resId);
+        invalidate();
+    }
+
+    public int getUnderlineColor() {
+        return underlineColor;
+    }
+
+    public void setDividerColor(int dividerColor) {
+        this.dividerColor = dividerColor;
+        invalidate();
+    }
+
+    public void setDividerColorResource(int resId) {
+        this.dividerColor = getResources().getColor(resId);
+        invalidate();
+    }
+
+    public int getDividerColor() {
+        return dividerColor;
+    }
+
+    public void setUnderlineHeight(int underlineHeightPx) {
+        this.underlineHeight = underlineHeightPx;
+        invalidate();
+    }
+
+    public int getUnderlineHeight() {
+        return underlineHeight;
+    }
+
+    public void setDividerPadding(int dividerPaddingPx) {
+        this.dividerPadding = dividerPaddingPx;
+        invalidate();
+    }
+
+    public int getDividerPadding() {
+        return dividerPadding;
+    }
+
+    public void setScrollOffset(int scrollOffsetPx) {
+        this.scrollOffset = scrollOffsetPx;
+        invalidate();
+    }
+
+    public int getScrollOffset() {
+        return scrollOffset;
+    }
+
+    public void setShouldExpand(boolean shouldExpand) {
+        this.shouldExpand = shouldExpand;
+        requestLayout();
+    }
+
+    public boolean getShouldExpand() {
+        return shouldExpand;
+    }
+
+    public void setTabBackground(int resId) {
+        this.tabBackgroundResId = resId;
+    }
+
+    public int getTabBackground() {
+        return tabBackgroundResId;
+    }
+
+    public void setTabPaddingLeftRight(int paddingPx) {
+        this.tabPadding = paddingPx;
+        updateTabStyles();
+    }
+
+    public int getTabPaddingLeftRight() {
+        return tabPadding;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        SavedState savedState = (SavedState) state;
+        super.onRestoreInstanceState(savedState.getSuperState());
+        currentPosition = savedState.currentPosition;
+        requestLayout();
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+        SavedState savedState = new SavedState(superState);
+        savedState.currentPosition = currentPosition;
+        return savedState;
+    }
+
+    static class SavedState extends BaseSavedState {
+        int currentPosition;
+
+        public SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        private SavedState(Parcel in) {
+            super(in);
+            currentPosition = in.readInt();
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            super.writeToParcel(dest, flags);
+            dest.writeInt(currentPosition);
+        }
+
+        public static final Creator<SavedState> CREATOR = new Creator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+}
Index: ucrop/src/main/res/layout/ucrop_layout_scale_wheel.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/res/layout/ucrop_layout_scale_wheel.xml	(revision )
+++ ucrop/src/main/res/layout/ucrop_layout_scale_wheel.xml	(revision )
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                tools:showIn="@layout/ucrop_activity_photobox"
+                tools:visibility="gone">
+
+    <TextView
+        android:id="@+id/text_view_scale"
+        android:layout_width="100dp"
+        android:layout_height="wrap_content"
+        android:layout_centerHorizontal="true"
+        android:layout_marginTop="10dp"
+        android:gravity="center"
+        android:textColor="@android:color/black"
+        android:textSize="13sp"
+        tools:text="100%"/>
+
+    <com.yalantis.ucrop.view.widget.HorizontalProgressWheelView
+        android:id="@+id/scale_scroll_wheel"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_below="@+id/text_view_scale"/>
+
+</RelativeLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/FieldUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/FieldUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/FieldUtil.java	(revision )
@@ -0,0 +1,128 @@
+package com.scene.common.common.utils;
+
+import java.io.Serializable;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * 域工具
+ *
+ * @author mty
+ * @date 2013-6-10下午6:36:29
+ */
+public class FieldUtil {
+
+    /**
+     * 判断是否序列化
+     *
+     * @param f
+     * @return
+     */
+    public static boolean isSerializable(Field f) {
+        Class<?>[] cls = f.getType().getInterfaces();
+        for (Class<?> c : cls) {
+            if (Serializable.class == c) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * 设置域的值
+     *
+     * @param f
+     * @param obj
+     * @return
+     * @throws IllegalAccessException
+     * @throws IllegalArgumentException
+     */
+    public static Object set(Field f, Object obj, Object value) throws IllegalArgumentException, IllegalAccessException {
+        f.setAccessible(true);
+        f.set(obj, value);
+        return f.get(obj);
+    }
+
+    /**
+     * 获取域的值
+     *
+     * @param f
+     * @param obj
+     * @return
+     * @throws IllegalAccessException
+     * @throws IllegalArgumentException
+     */
+    public static Object get(Field f, Object obj) throws IllegalArgumentException, IllegalAccessException {
+        f.setAccessible(true);
+        return f.get(obj);
+    }
+
+    public static boolean isLong(Field field) {
+        return field.getType() == long.class || field.getType() == Long.class;
+    }
+
+    public static boolean isInteger(Field field) {
+        return field.getType() == int.class || field.getType() != Integer.class;
+    }
+
+    /**
+     * 获取域的泛型类型，如果不带泛型返回null
+     *
+     * @param f
+     * @return
+     */
+    public static Class<?> getGenericType(Field f) {
+        Type type = f.getGenericType();
+        if (type instanceof ParameterizedType) {
+            type = ((ParameterizedType) type).getActualTypeArguments()[0];
+            if (type instanceof Class<?>) return (Class<?>) type;
+        } else if (type instanceof Class<?>) return (Class<?>) type;
+        return null;
+    }
+
+    /**
+     * 获取数组的类型
+     *
+     * @param f
+     * @return
+     */
+    public static Class<?> getComponentType(Field f) {
+        return f.getType().getComponentType();
+    }
+
+    /**
+     * 获取全部Field，包括父类
+     *
+     * @param claxx
+     * @return
+     */
+    public static List<Field> getAllDeclaredFields(Class<?> claxx) {
+        // find all field.
+        LinkedList<Field> fieldList = new LinkedList<Field>();
+        while (claxx != null && claxx != Object.class) {
+            Field[] fs = claxx.getDeclaredFields();
+            for (int i = 0; i < fs.length; i++) {
+                Field f = fs[i];
+                if (!isInvalid(f)) {
+                    fieldList.addLast(f);
+                }
+            }
+            claxx = claxx.getSuperclass();
+        }
+        return fieldList;
+    }
+
+    /**
+     * 是静态常量或者内部结构属性
+     *
+     * @param f
+     * @return
+     */
+    public static boolean isInvalid(Field f) {
+        return (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) || f.isSynthetic();
+    }
+}
Index: .idea/inspectionProfiles/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/inspectionProfiles/profiles_settings.xml	(revision )
+++ .idea/inspectionProfiles/profiles_settings.xml	(revision )
@@ -0,0 +1,7 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="PROJECT_PROFILE" value="Project Default" />
+    <option name="USE_PROJECT_PROFILE" value="true" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
Index: mylib/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/.gitignore	(revision )
+++ mylib/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: chooseimagelib/src/androidTest/java/com/scene/chooseimagelib/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/androidTest/java/com/scene/chooseimagelib/ApplicationTest.java	(revision )
+++ chooseimagelib/src/androidTest/java/com/scene/chooseimagelib/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.scene.chooseimagelib;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/receiver/TimeReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/receiver/TimeReceiver.java	(revision )
+++ common/src/main/java/com/scene/common/common/receiver/TimeReceiver.java	(revision )
@@ -0,0 +1,85 @@
+package com.scene.common.common.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import com.scene.common.android.log.Log;
+
+/**
+ * 时间广播
+ *
+ * @author MaTianyu
+ * @date 2015-03-09
+ */
+public class TimeReceiver extends BroadcastReceiver {
+
+    private static final String TAG = "TimeReceiver";
+
+    private TimeListener timeListener;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (Log.isPrint) {
+            Log.i(TAG, "action: " + intent.getAction());
+            Log.d(TAG, "intent : ");
+            Bundle bundle = intent.getExtras();
+            for (String key : bundle.keySet()) {
+                Log.d(TAG, key + " : " + bundle.get(key));
+            }
+        }
+        if (Intent.ACTION_TIME_TICK.equals(intent.getAction())) {
+            if (timeListener != null) {
+                timeListener.onTimeTick();
+            }
+        } else if (Intent.ACTION_TIME_CHANGED.equals(intent.getAction())) {
+            if (timeListener != null) {
+                timeListener.onTimeChanged();
+            }
+        } else if (Intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
+            if (timeListener != null) {
+                timeListener.onTimeZoneChanged();
+            }
+        }
+    }
+
+    public void registerReceiver(Context context, TimeListener timeListener) {
+        try {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_TIME_CHANGED);
+            filter.addAction(Intent.ACTION_TIME_TICK);
+            filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+            filter.setPriority(Integer.MAX_VALUE);
+            context.registerReceiver(this, filter);
+            this.timeListener = timeListener;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void unRegisterReceiver(Context context) {
+        try {
+            context.unregisterReceiver(this);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static interface TimeListener {
+        /**
+         * 时区改变
+         */
+        public void onTimeZoneChanged();
+
+        /**
+         * 设置时间
+         */
+        public void onTimeChanged();
+
+        /**
+         * 每分钟调用
+         */
+        public void onTimeTick();
+    }
+}
Index: common/src/main/java/com/scene/common/android/log/LogReader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/android/log/LogReader.java	(revision )
+++ common/src/main/java/com/scene/common/android/log/LogReader.java	(revision )
@@ -0,0 +1,135 @@
+package com.scene.common.android.log;
+
+import java.io.*;
+import java.text.DecimalFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+/**
+ * 打印日志
+ *
+ * @author mty
+ * @time 2011-11-2下午06:23:29
+ */
+public class LogReader extends Thread {
+    public static final String TAG           = "LogReader";
+    public static final String LOG_FILE_PATH = "/bonglog.txt";
+    public static final String LOG_ROOT_PATH = "/sdcard";
+
+    public static  boolean   open        = true;
+    private static LogReader instance    = null;
+    private static Process   mLogcatProc = null;
+
+    private BufferedReader mReader = null;
+    private String packageName = "*";
+
+    public static void startCatchLog(String packageName) {
+        if (!open) return;
+        if (instance == null) {
+            instance = new LogReader();
+            instance.packageName = packageName;
+            instance.start();
+        }
+    }
+
+    public static void stopCatchLog() {
+        if (!open) return;
+        if (mLogcatProc != null) {
+            mLogcatProc.destroy();
+            mLogcatProc = null;
+        }
+    }
+
+    @Override
+    public void run() {
+        Log.i(TAG, "log reader(catcher) is running..---------------------------");
+        BufferedWriter bw = null;
+        try {
+            mLogcatProc = Runtime.getRuntime().exec("logcat " + packageName + ":I");
+            mReader = new BufferedReader(new InputStreamReader(mLogcatProc.getInputStream()));
+
+            // 打印系统信息。
+            logSystemInfo();
+
+            String line;
+            File file = new File(LOG_ROOT_PATH + LOG_FILE_PATH);
+            if (file.exists() && isFileSizeOutof10M(file)) {
+                file.delete();
+            }
+            if (file.exists()) {
+                System.out.println("log file size is :"
+                        + FormatFileSize(file.length()));
+            }
+            FileWriter fw = new FileWriter(file, true);
+            bw = new BufferedWriter(fw);
+            while ((line = mReader.readLine()) != null) {
+                bw.append(line);
+                bw.newLine();
+                bw.flush();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            Log.i(TAG, "Log reader(catcher) and bufferwriter has closed. ------------------");
+            try {
+                if (mReader != null) {
+                    mReader.close();
+                    mReader = null;
+                }
+                if (bw != null) {
+                    bw.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            instance = null;
+        }
+
+    }
+
+    public static String FormatFileSize(long fileS) {// 转换文件大小
+        DecimalFormat df = new DecimalFormat("#.00");
+        String fileSizeString = "";
+        if (fileS < 1024) {
+            fileSizeString = df.format((double) fileS) + "B";
+        } else if (fileS < 1048576) {
+            fileSizeString = df.format((double) fileS / 1024) + "K";
+        } else if (fileS < 1073741824) {
+            fileSizeString = df.format((double) fileS / 1048576) + "M";
+        } else {
+            fileSizeString = df.format((double) fileS / 1073741824) + "G";
+        }
+        return fileSizeString;
+    }
+
+    /**
+     * 判断文件是否大于10M。
+     *
+     * @param file
+     * @return
+     * @throws Exception
+     */
+    public static boolean isFileSizeOutof10M(File file) throws Exception {
+        if (file == null) return false;
+        return file.length() >= 10485760;
+    }
+
+    public static void logSystemInfo() {
+        Date date = new Date(System.currentTimeMillis());
+        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+        String time = dateFormat.format(date);
+        android.util.Log.w("system", "New Start $$$$$$$$$$$$$$###########   " + time + "############$$$$$$$$$$$$$$$");
+        android.util.Log.w("system", "android.os.Build.BOARD:" + android.os.Build.BOARD);
+        android.util.Log.w("system", "android.os.Build.DEVICE:" + android.os.Build.DEVICE);
+        android.util.Log.w("system", "android.os.Build.MANUFACTURER:"
+                + android.os.Build.MANUFACTURER);
+        android.util.Log.w("system", "android.os.Build.MODEL:" + android.os.Build.MODEL);
+        android.util.Log.w("system", "android.os.Build.PRODUCT:" + android.os.Build.PRODUCT);
+        android.util.Log.w("system", "android.os.Build.VERSION.CODENAME:"
+                + android.os.Build.VERSION.CODENAME);
+        android.util.Log.w("system", "android.os.Build.VERSION.RELEASE:"
+                + android.os.Build.VERSION.RELEASE);
+        //android.util.Log.w("system", "android.os.Build.VERSION.SDK:"
+        //        + android.os.Build.VERSION.SDK);
+    }
+}
Index: common/src/main/java/com/scene/common/common/utils/CpuUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/CpuUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/CpuUtil.java	(revision )
@@ -0,0 +1,179 @@
+package com.scene.common.common.utils;
+
+import com.scene.common.android.log.Log;
+import com.scene.common.common.assist.Check;
+
+import java.io.*;
+import java.util.regex.Pattern;
+
+/**
+ * Get CPU info.
+ *
+ * @author MaTianyu
+ * @date 2015-04-18
+ */
+public class CpuUtil {
+    private static final String TAG = CpuUtil.class.getSimpleName();
+    private static final String CPU_INFO_PATH = "/proc/cpuinfo";
+    private static final String CPU_FREQ_NULL = "N/A";
+    private static final String CMD_CAT = "/system/bin/cat";
+    private static final String CPU_FREQ_CUR_PATH = "/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq";
+    private static final String CPU_FREQ_MAX_PATH = "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq";
+    private static final String CPU_FREQ_MIN_PATH = "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq";
+
+    private static String CPU_NAME;
+    private static int CPU_CORES = 0;
+    private static long CPU_MAX_FREQENCY = 0;
+    private static long CPU_MIN_FREQENCY = 0;
+
+    /**
+     * Print cpu info.
+     */
+    public static String printCpuInfo() {
+        String info = FileUtil.getFileOutputString(CPU_INFO_PATH);
+        if (Log.isPrint) {
+            Log.i(TAG, "_______  CPU :   \n" + info);
+        }
+        return info;
+    }
+
+    /**
+     * Get available processors.
+     */
+    public static int getProcessorsCount() {
+        return Runtime.getRuntime().availableProcessors();
+    }
+
+    /**
+     * Gets the number of cores available in this device, across all processors.
+     * Requires: Ability to peruse the filesystem at "/sys/devices/system/cpu"
+     *
+     * @return The number of cores, or available processors if failed to get result
+     */
+    public static int getCoresNumbers() {
+        if (CPU_CORES != 0) {
+            return CPU_CORES;
+        }
+        //Private Class to display only CPU devices in the directory listing
+        class CpuFilter implements FileFilter {
+            @Override
+            public boolean accept(File pathname) {
+                //Check if filename is "cpu", followed by a single digit number
+                if (Pattern.matches("cpu[0-9]+", pathname.getName())) {
+                    return true;
+                }
+                return false;
+            }
+        }
+
+        try {
+            //Get directory containing CPU info
+            File dir = new File("/sys/devices/system/cpu/");
+            //Filter to only list the devices we care about
+            File[] files = dir.listFiles(new CpuFilter());
+            //Return the number of cores (virtual CPU devices)
+            CPU_CORES = files.length;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        if (CPU_CORES < 1) {
+            CPU_CORES = Runtime.getRuntime().availableProcessors();
+        }
+        if (CPU_CORES < 1) {
+            CPU_CORES = 1;
+        }
+        return CPU_CORES;
+    }
+
+    /**
+     * Get CPU name.
+     */
+    public static String getCpuName() {
+        if (!Check.isEmpty(CPU_NAME)) {
+            return CPU_NAME;
+        }
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(CPU_INFO_PATH), 8192);
+            String line = bufferedReader.readLine();
+            bufferedReader.close();
+            String[] array = line.split(":\\s+", 2);
+            if (array.length > 1) {
+                if (Log.isPrint) {
+                    Log.i(TAG, array[1]);
+                }
+                CPU_NAME = array[1];
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return CPU_NAME;
+    }
+
+    /**
+     * Get current CPU freqency.
+     */
+    public static long getCurrentFreqency() {
+        try {
+            return Long.parseLong(FileUtil.getFileOutputString(CPU_FREQ_CUR_PATH).trim());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return 0;
+    }
+
+    /**
+     * Get maximum CPU freqency
+     */
+    public static long getMaxFreqency() {
+        if (CPU_MAX_FREQENCY > 0) {
+            return CPU_MAX_FREQENCY;
+        }
+        try {
+            CPU_MAX_FREQENCY = Long.parseLong(getCMDOutputString(new String[]{CMD_CAT, CPU_FREQ_MAX_PATH}).trim());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return CPU_MAX_FREQENCY;
+    }
+
+    /**
+     * Get minimum frenqency.
+     */
+    public static long getMinFreqency() {
+        if (CPU_MIN_FREQENCY > 0) {
+            return CPU_MIN_FREQENCY;
+        }
+        try {
+            CPU_MIN_FREQENCY = Long.parseLong(getCMDOutputString(new String[]{CMD_CAT, CPU_FREQ_MIN_PATH}).trim());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return CPU_MIN_FREQENCY;
+    }
+
+    /**
+     * Get command output string.
+     */
+    public static String getCMDOutputString(String[] args) {
+        try {
+            ProcessBuilder cmd = new ProcessBuilder(args);
+            Process process = cmd.start();
+            InputStream in = process.getInputStream();
+            StringBuilder sb = new StringBuilder();
+            byte[] re = new byte[64];
+            int len;
+            while ((len = in.read(re)) != -1) {
+                sb.append(new String(re, 0, len));
+            }
+            in.close();
+            process.destroy();
+            if (Log.isPrint) {
+                Log.i(TAG, "CMD: " + sb.toString());
+            }
+            return sb.toString();
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+        return null;
+    }
+}
Index: ucrop/gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/gradle.properties	(revision )
+++ ucrop/gradle.properties	(revision )
@@ -0,0 +1,3 @@
+POM_NAME=uCrop
+POM_ARTIFACT_ID=ucrop
+POM_PACKAGING=aar
\ No newline at end of file
Index: customfresco/src/main/java/com/scene/customfresco/FrescoZoomImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/FrescoZoomImageView.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/FrescoZoomImageView.java	(revision )
@@ -0,0 +1,234 @@
+package com.scene.customfresco;
+
+import android.content.Context;
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.drawee.generic.RoundingParams;
+import com.facebook.drawee.interfaces.DraweeController;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imagepipeline.request.ImageRequestBuilder;
+import com.facebook.imagepipeline.request.Postprocessor;
+import com.scene.customfresco.zoomable.ZoomableDraweeView;
+
+
+/**
+ * Created by Linhh on 16/2/18.
+ */
+public class FrescoZoomImageView extends ZoomableDraweeView {
+//
+//    //    private final static String TAG = "FrescoThumbnailView";
+//    private final static String HTTP_PERFIX = "http://";
+//    private final static String HTTPS_PERFIX = "https://";
+//    private final static String FILE_PERFIX = "file://";
+
+    private String mThumbnailUrl = null;
+    private int  mDefaultResID = 0;
+
+    private ImageRequest mRequest;
+
+    private boolean mAnim = true;//默认开启动画
+
+    private Postprocessor mPostProcessor;
+
+    private DraweeController mController;
+
+    public FrescoZoomImageView(Context context) {
+        this(context, null);
+    }
+
+    public FrescoZoomImageView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public FrescoZoomImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+//        init();
+    }
+
+//    public void init(){
+//
+//        GenericDraweeHierarchy hierarchy = new GenericDraweeHierarchyBuilder(getResources())
+//                .setActualImageScaleType(ScalingUtils.ScaleType.FIT_CENTER)
+////                .setProgressBarImage(new ProgressBarDrawable())
+//                .build();
+//
+////        view.setController(ctrl);
+//        this.setHierarchy(hierarchy);
+//    }
+
+    private void setController(int resid){
+        if(resid == 0){
+            return;
+        }
+
+        if(mPostProcessor != null) {
+            mRequest = ImageRequestBuilder.newBuilderWithResourceId(resid)
+                    .setPostprocessor(mPostProcessor)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+
+        }else{
+            mRequest = ImageRequestBuilder.newBuilderWithResourceId(resid)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+        }
+
+        mController = Fresco.newDraweeControllerBuilder()
+                .setImageRequest(mRequest)
+                .setAutoPlayAnimations(mAnim)
+                .setOldController(this.getController())
+                .build();
+
+        this.setController(mController);
+    }
+
+    private void setController(Uri uri, Uri lowResUri){
+
+        if(uri == null){
+            return;
+        }
+
+        if(mPostProcessor != null) {
+            mRequest = ImageRequestBuilder.newBuilderWithSource(uri)
+                    .setPostprocessor(mPostProcessor)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+
+        }else{
+            mRequest = ImageRequestBuilder.newBuilderWithSource(uri)
+                    .setLocalThumbnailPreviewsEnabled(true)
+                    .build();
+        }
+
+        ImageRequest lowResRequest = ImageRequest.fromUri(lowResUri);
+
+        if(lowResRequest == null) {
+            mController = Fresco.newDraweeControllerBuilder()
+                    .setImageRequest(mRequest)
+                    .setAutoPlayAnimations(mAnim)
+                    .setOldController(this.getController())
+                    .build();
+
+        }else{
+            mController = Fresco.newDraweeControllerBuilder()
+                    .setImageRequest(mRequest)
+                    .setLowResImageRequest(lowResRequest)
+                    .setAutoPlayAnimations(mAnim)
+                    .setOldController(this.getController())
+                    .build();
+        }
+        this.setController(mController);
+    }
+
+    public void setPostProcessor(Postprocessor postProcessor){
+        this.mPostProcessor = postProcessor;
+    }
+
+    public Postprocessor getPostProcessor(){
+        return this.mPostProcessor;
+    }
+
+    public void loadView(String lowUrl ,String url, int defaultResID) {
+        try {
+            if (url == null || url.length() <= 0) {
+                this.getHierarchy().setPlaceholderImage(defaultResID);
+                this.setController(defaultResID);
+                mThumbnailUrl = url;
+                return;
+            }
+            mThumbnailUrl = url;
+            mDefaultResID = defaultResID;
+
+            if (mThumbnailUrl.startsWith(FrescoImageView.HTTP_PERFIX) || mThumbnailUrl.startsWith(FrescoImageView.HTTPS_PERFIX)) {
+
+                Uri uri = Uri.parse(mThumbnailUrl);
+                this.getHierarchy().setPlaceholderImage(defaultResID);
+
+                Uri lowUri = null;
+
+                if(!TextUtils.isEmpty(lowUrl)){
+                    lowUri = Uri.parse(mThumbnailUrl);
+                }
+
+                setController(uri ,lowUri);
+
+            } else {
+                this.getHierarchy().setPlaceholderImage(defaultResID);
+                this.setController(defaultResID);
+            }
+
+        }catch (OutOfMemoryError e){
+            e.printStackTrace();
+        }
+
+    }
+
+    public void loadView(String url, int defaultResID) {
+        this.loadView(null, url, defaultResID);
+    }
+
+    /**
+     * 获得当前使用的图片URL
+     * @return
+     */
+    public String getThumbnailUrl(){
+        return this.mThumbnailUrl;
+    }
+
+    /**
+     * 获得当前使用的默认占位图
+     * @return
+     */
+    public int getDefaultResID(){
+        return this.mDefaultResID;
+    }
+
+    public void loadLocalImage(String path, int defaultRes){
+        this.getHierarchy().setPlaceholderImage(defaultRes);
+        if(null == path || path.length() == 0){
+            this.setController(defaultRes);
+            return;
+        }
+        if(!path.startsWith(FrescoImageView.FILE_PERFIX)){
+            path = FrescoImageView.FILE_PERFIX + path;
+        }
+        Uri uri = Uri.parse(path);
+        setController(uri, null);
+    }
+
+    public void setCornerRadius(float radius){
+        RoundingParams roundingParams = RoundingParams.fromCornersRadius(radius);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setCornerRadius(float radius, int overlay_color){
+        RoundingParams roundingParams = RoundingParams.fromCornersRadius(radius).
+                setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR).
+                setOverlayColor(overlay_color);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setCircle(int overlay_color){
+        RoundingParams roundingParams = RoundingParams.asCircle().
+                setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR).
+                setOverlayColor(overlay_color);
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+
+    public void setAnim(boolean b){
+        mAnim = b;
+    }
+
+    public boolean isAnim(){
+        return mAnim;
+    }
+
+    public void asCircle(){
+        RoundingParams roundingParams = RoundingParams.asCircle();
+        this.getHierarchy().setRoundingParams(roundingParams);
+    }
+}
+
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision )
+++ .idea/compiler.xml	(revision )
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="!?*.java" />
+      <entry name="!?*.form" />
+      <entry name="!?*.class" />
+      <entry name="!?*.groovy" />
+      <entry name="!?*.scala" />
+      <entry name="!?*.flex" />
+      <entry name="!?*.kt" />
+      <entry name="!?*.clj" />
+      <entry name="!?*.aj" />
+    </wildcardResourcePatterns>
+    <annotationProcessing>
+      <profile default="true" name="Default" enabled="false">
+        <processorPath useClasspath="true" />
+      </profile>
+    </annotationProcessing>
+  </component>
+</project>
\ No newline at end of file
Index: easypermissions/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/.gitignore	(revision )
+++ easypermissions/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: timeline/src/main/res/values/attr.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/main/res/values/attr.xml	(revision )
+++ timeline/src/main/res/values/attr.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="timeline_style" >
+        <attr name="marker" format="color|reference"/>
+        <attr name="line" format="color|reference"/>
+        <attr name="marker_size" format="dimension"/>
+        <attr name="line_size" format="dimension"/>
+    </declare-styleable>
+</resources>
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/SecondFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/SecondFragment.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/fragments/SecondFragment.java	(revision )
@@ -0,0 +1,45 @@
+package com.scene.sceneandroiddemo.ui.fragments;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentTransaction;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.scene.sceneandroiddemo.BaseFragment;
+import com.scene.sceneandroiddemo.MainTabActivity;
+import com.scene.sceneandroiddemo.R;
+
+import butterknife.Bind;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+
+
+public class SecondFragment extends BaseFragment {
+
+    @Bind(R.id.next)
+    Button next;
+
+    public static SecondFragment instance() {
+        SecondFragment view = new SecondFragment();
+        return view;
+    }
+
+    @Override
+    public int setLayoutResId() {
+        return R.layout.fragment2;
+    }
+
+    @Override
+    public void init() {
+
+    }
+
+    @OnClick(R.id.next)
+    public void onClickNext() {
+
+    }
+}
\ No newline at end of file
Index: mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/SimpleCursorSwipeAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/SimpleCursorSwipeAdapter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/swipelayout/adapters/SimpleCursorSwipeAdapter.java	(revision )
@@ -0,0 +1,80 @@
+package com.scene.mylib.view.swipelayout.adapters;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.support.v4.widget.SimpleCursorAdapter;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.scene.mylib.view.swipelayout.SwipeLayout;
+import com.scene.mylib.view.swipelayout.implments.SwipeItemMangerImpl;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeAdapterInterface;
+import com.scene.mylib.view.swipelayout.interfaces.SwipeItemMangerInterface;
+import com.scene.mylib.view.swipelayout.util.Attributes;
+
+import java.util.List;
+
+public abstract class SimpleCursorSwipeAdapter extends SimpleCursorAdapter implements SwipeItemMangerInterface, SwipeAdapterInterface {
+
+    private SwipeItemMangerImpl mItemManger = new SwipeItemMangerImpl(this);
+
+    protected SimpleCursorSwipeAdapter(Context context, int layout, Cursor c, String[] from, int[] to, int flags) {
+        super(context, layout, c, from, to, flags);
+    }
+
+    protected SimpleCursorSwipeAdapter(Context context, int layout, Cursor c, String[] from, int[] to) {
+        super(context, layout, c, from, to);
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        View v = super.getView(position, convertView, parent);
+        mItemManger.bind(v, position);
+        return v;
+    }
+
+    @Override
+    public void openItem(int position) {
+        mItemManger.openItem(position);
+    }
+
+    @Override
+    public void closeItem(int position) {
+        mItemManger.closeItem(position);
+    }
+
+    @Override
+    public void closeAllExcept(SwipeLayout layout) {
+        mItemManger.closeAllExcept(layout);
+    }
+
+    @Override
+    public List<Integer> getOpenItems() {
+        return mItemManger.getOpenItems();
+    }
+
+    @Override
+    public List<SwipeLayout> getOpenLayouts() {
+        return mItemManger.getOpenLayouts();
+    }
+
+    @Override
+    public void removeShownLayouts(SwipeLayout layout) {
+        mItemManger.removeShownLayouts(layout);
+    }
+
+    @Override
+    public boolean isOpen(int position) {
+        return mItemManger.isOpen(position);
+    }
+
+    @Override
+    public Attributes.Mode getMode() {
+        return mItemManger.getMode();
+    }
+
+    @Override
+    public void setMode(Attributes.Mode mode) {
+        mItemManger.setMode(mode);
+    }
+}
Index: app/src/main/res/layout/main_item.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/main_item.xml	(revision )
+++ app/src/main/res/layout/main_item.xml	(revision )
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:app="http://schemas.android.com/apk/res-auto"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:background="@color/white"
+              android:orientation="vertical">
+
+    <android.support.v7.widget.CardView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:cardBackgroundColor="@color/colorPrimary"
+        app:cardCornerRadius="10dp"
+        app:cardPreventCornerOverlap="true"
+        app:cardUseCompatPadding="true"
+        app:contentPadding="10dp">
+
+        <TextView
+            android:id="@+id/type"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center_horizontal"
+            android:text="测试"
+            android:textColor="@color/white"
+            android:textSize="14sp"/>
+    </android.support.v7.widget.CardView>
+</LinearLayout>
\ No newline at end of file
Index: mylib/src/main/res/layout/sample_common_list_footer_end.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/sample_common_list_footer_end.xml	(revision )
+++ mylib/src/main/res/layout/sample_common_list_footer_end.xml	(revision )
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center"
+    android:orientation="horizontal">
+
+    <TextView
+        android:id="@+id/loading_text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginLeft="@dimen/dp_4"
+        android:text="@string/list_footer_end"
+        android:textColor="@color/sample_common_list_bottom_text_color"
+        android:textSize="@dimen/sp_14" />
+</LinearLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/android/view/TipsView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/android/view/TipsView.java	(revision )
+++ common/src/main/java/com/scene/common/android/view/TipsView.java	(revision )
@@ -0,0 +1,127 @@
+package com.scene.common.android.view;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.LinearLayout;
+
+/**
+ * @author MaTianyu
+ * @date 2014-08-15
+ */
+public class TipsView extends LinearLayout {
+    protected View realView;
+    protected ViewGroup parentView;
+
+    protected Context context;
+    protected boolean isThisInLayout = false;
+
+    public TipsView(Context context) {
+        this(context, (AttributeSet) null);
+    }
+
+    public TipsView(Context context, AttributeSet attrs) {
+        this(context, attrs, null, null);
+    }
+
+    public TipsView(Context context, View realView, View tipView) {
+        this(context, null, realView, tipView);
+    }
+
+    public TipsView(Context context, View realView) {
+        this(context, null, realView, null);
+    }
+
+    public TipsView(Context context, AttributeSet attrs, View realView, View tipView) {
+        super(context, attrs);
+        this.context = context;
+        initSelf();
+        setRealView(realView);
+        setTipView(tipView);
+    }
+
+    public void initSelf() {
+        setOrientation(HORIZONTAL);
+        setGravity(Gravity.CENTER);
+    }
+
+    public TipsView setTipView(View tipView) {
+        if (tipView != null) {
+            removeAllViews();
+            addView(tipView);
+        }
+        return this;
+    }
+
+    public TipsView setTipView(int resID) {
+        removeAllViews();
+        LayoutInflater.from(context).inflate(resID, this, true);
+        return this;
+    }
+
+
+    public View getRealView() {
+        return realView;
+    }
+
+
+    public TipsView setRealView(View realView) {
+        if (realView != null) {
+            showRealView();
+            this.realView = realView;
+            parentView = (ViewGroup) realView.getParent();
+            setLayoutParams(realView.getLayoutParams());
+        }
+        return this;
+    }
+
+
+    public void showRealView() {
+        if (realView != null && parentView != null) {
+            if (isThisInLayout) {
+                for (int i = 0, size = parentView.getChildCount(); i < size; i++) {
+                    if (parentView.getChildAt(i) == this) {
+                        parentView.removeView(this);
+                        //realView.setId(getId());
+                        //setId(0);
+                        parentView.addView(realView, i);
+                        isThisInLayout = false;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    public void showTipsView() {
+        if (realView != null && parentView != null) {
+            if (!isThisInLayout) {
+                for (int i = 0, size = parentView.getChildCount(); i < size; i++) {
+                    if (parentView.getChildAt(i) == realView) {
+                        parentView.removeView(realView);
+                        //setId(realView.getId());
+                        //realView.setId(0);
+                        parentView.addView(this, i);
+                        isThisInLayout = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    public void gone() {
+        setVisibility(GONE);
+    }
+
+    public void visible() {
+        setVisibility(VISIBLE);
+    }
+
+    public void inVisible() {
+        setVisibility(INVISIBLE);
+    }
+}
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/HighlightView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/HighlightView.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/HighlightView.java	(revision )
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.chooseimagelib.simplecropimage;
+
+
+import android.graphics.*;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+
+import com.scene.chooseimagelib.R;
+
+// This class is used by CropImage to display a highlighted cropping rectangle
+// overlayed with the image. There are two coordinate spaces in use. One is
+// image, another is screen. computeLayout() uses mMatrix to map from image
+// space to screen space.
+class HighlightView {
+
+    @SuppressWarnings("unused")
+    private static final String TAG = "HighlightView";
+    View mContext;  // The View displaying the image.
+
+    public static final int GROW_NONE        = (1 << 0);
+    public static final int GROW_LEFT_EDGE   = (1 << 1);
+    public static final int GROW_RIGHT_EDGE  = (1 << 2);
+    public static final int GROW_TOP_EDGE    = (1 << 3);
+    public static final int GROW_BOTTOM_EDGE = (1 << 4);
+    public static final int MOVE             = (1 << 5);
+
+    public HighlightView(View ctx) {
+
+        mContext = ctx;
+    }
+
+    private void init() {
+
+        android.content.res.Resources resources = mContext.getResources();
+        mResizeDrawableWidth =
+                resources.getDrawable(R.drawable.camera_crop_width);
+        mResizeDrawableHeight =
+                resources.getDrawable(R.drawable.camera_crop_height);
+        mResizeDrawableDiagonal =
+                resources.getDrawable(R.drawable.indicator_autocrop);
+    }
+
+    boolean mIsFocused;
+    boolean mHidden;
+
+    public boolean hasFocus() {
+
+        return mIsFocused;
+    }
+
+    public void setFocus(boolean f) {
+
+        mIsFocused = f;
+    }
+
+    public void setHidden(boolean hidden) {
+
+        mHidden = hidden;
+    }
+
+    protected void draw(Canvas canvas) {
+
+        if (mHidden) {
+            return;
+        }
+        
+        Path path = new Path();
+        if (!hasFocus()) {
+            mOutlinePaint.setColor(0xFF000000);
+            canvas.drawRect(mDrawRect, mOutlinePaint);
+        } else {
+            Rect viewDrawingRect = new Rect();
+            mContext.getDrawingRect(viewDrawingRect);
+            if (mCircle) {
+				
+		canvas.save();
+
+                float width = mDrawRect.width();
+                float height = mDrawRect.height();
+                path.addCircle(mDrawRect.left + (width / 2),
+                        mDrawRect.top + (height / 2),
+                        width / 2,
+                        Path.Direction.CW);
+				mOutlinePaint.setColor(0xFFEF04D6);
+                
+		canvas.clipPath(path, Region.Op.DIFFERENCE);
+            	canvas.drawRect(viewDrawingRect,
+                    hasFocus() ? mFocusPaint : mNoFocusPaint);
+
+            	canvas.restore();
+
+
+            } else {
+				
+		Rect topRect = new Rect(viewDrawingRect.left, viewDrawingRect.top, viewDrawingRect.right, mDrawRect.top );
+	        if (topRect.width() > 0 && topRect.height() > 0) {
+	        	canvas.drawRect(topRect, hasFocus() ? mFocusPaint : mNoFocusPaint);
+            	}
+	        Rect bottomRect = new Rect(viewDrawingRect.left, mDrawRect.bottom, viewDrawingRect.right, viewDrawingRect.bottom);
+	        if (bottomRect.width() > 0 && bottomRect.height() > 0) {
+	        	canvas.drawRect(bottomRect, hasFocus() ? mFocusPaint : mNoFocusPaint);
+            	}
+            	Rect leftRect = new Rect(viewDrawingRect.left, topRect.bottom, mDrawRect.left, bottomRect.top);
+	        if (leftRect.width() > 0 && leftRect.height() > 0) {
+	        	canvas.drawRect(leftRect, hasFocus() ? mFocusPaint : mNoFocusPaint);
+    		}
+            	Rect rightRect = new Rect(mDrawRect.right, topRect.bottom, viewDrawingRect.right, bottomRect.top);
+	        if (rightRect.width() > 0 && rightRect.height() > 0) {
+	                canvas.drawRect(rightRect, hasFocus() ? mFocusPaint : mNoFocusPaint);
+	        }
+
+                path.addRect(new RectF(mDrawRect), Path.Direction.CW);
+            
+		mOutlinePaint.setColor(0xFFFF8A00);    
+
+            }
+            
+			
+            canvas.drawPath(path, mOutlinePaint);
+
+            if (mMode == ModifyMode.Grow) {
+                if (mCircle) {
+                    int width = mResizeDrawableDiagonal.getIntrinsicWidth();
+                    int height = mResizeDrawableDiagonal.getIntrinsicHeight();
+
+                    int d = (int) Math.round(Math.cos(/*45deg*/Math.PI / 4D)
+                            * (mDrawRect.width() / 2D));
+                    int x = mDrawRect.left
+                            + (mDrawRect.width() / 2) + d - width / 2;
+                    int y = mDrawRect.top
+                            + (mDrawRect.height() / 2) - d - height / 2;
+                    mResizeDrawableDiagonal.setBounds(x, y,
+                            x + mResizeDrawableDiagonal.getIntrinsicWidth(),
+                            y + mResizeDrawableDiagonal.getIntrinsicHeight());
+                    mResizeDrawableDiagonal.draw(canvas);
+                } else {
+                    int left = mDrawRect.left + 1;
+                    int right = mDrawRect.right + 1;
+                    int top = mDrawRect.top + 4;
+                    int bottom = mDrawRect.bottom + 3;
+
+                    int widthWidth =
+                            mResizeDrawableWidth.getIntrinsicWidth() / 2;
+                    int widthHeight =
+                            mResizeDrawableWidth.getIntrinsicHeight() / 2;
+                    int heightHeight =
+                            mResizeDrawableHeight.getIntrinsicHeight() / 2;
+                    int heightWidth =
+                            mResizeDrawableHeight.getIntrinsicWidth() / 2;
+
+                    int xMiddle = mDrawRect.left
+                            + ((mDrawRect.right - mDrawRect.left) / 2);
+                    int yMiddle = mDrawRect.top
+                            + ((mDrawRect.bottom - mDrawRect.top) / 2);
+
+                    mResizeDrawableWidth.setBounds(left - widthWidth,
+                            yMiddle - widthHeight,
+                            left + widthWidth,
+                            yMiddle + widthHeight);
+                    mResizeDrawableWidth.draw(canvas);
+
+                    mResizeDrawableWidth.setBounds(right - widthWidth,
+                            yMiddle - widthHeight,
+                            right + widthWidth,
+                            yMiddle + widthHeight);
+                    mResizeDrawableWidth.draw(canvas);
+
+                    mResizeDrawableHeight.setBounds(xMiddle - heightWidth,
+                            top - heightHeight,
+                            xMiddle + heightWidth,
+                            top + heightHeight);
+                    mResizeDrawableHeight.draw(canvas);
+
+                    mResizeDrawableHeight.setBounds(xMiddle - heightWidth,
+                            bottom - heightHeight,
+                            xMiddle + heightWidth,
+                            bottom + heightHeight);
+                    mResizeDrawableHeight.draw(canvas);
+                }
+            }
+        }
+    }
+
+    public ModifyMode getMode() {
+
+        return mMode;
+    }
+
+    public void setMode(ModifyMode mode) {
+
+        if (mode != mMode) {
+            mMode = mode;
+            mContext.invalidate();
+        }
+    }
+
+    // Determines which edges are hit by touching at (x, y).
+    public int getHit(float x, float y) {
+
+        Rect r = computeLayout();
+        final float hysteresis = 20F;
+        int retval = GROW_NONE;
+
+        if (mCircle) {
+            float distX = x - r.centerX();
+            float distY = y - r.centerY();
+            int distanceFromCenter =
+                    (int) Math.sqrt(distX * distX + distY * distY);
+            int radius = mDrawRect.width() / 2;
+            int delta = distanceFromCenter - radius;
+            if (Math.abs(delta) <= hysteresis) {
+                if (Math.abs(distY) > Math.abs(distX)) {
+                    if (distY < 0) {
+                        retval = GROW_TOP_EDGE;
+                    } else {
+                        retval = GROW_BOTTOM_EDGE;
+                    }
+                } else {
+                    if (distX < 0) {
+                        retval = GROW_LEFT_EDGE;
+                    } else {
+                        retval = GROW_RIGHT_EDGE;
+                    }
+                }
+            } else if (distanceFromCenter < radius) {
+                retval = MOVE;
+            } else {
+                retval = GROW_NONE;
+            }
+        } else {
+            // verticalCheck makes sure the position is between the top and
+            // the bottom edge (with some tolerance). Similar for horizCheck.
+            boolean verticalCheck = (y >= r.top - hysteresis)
+                    && (y < r.bottom + hysteresis);
+            boolean horizCheck = (x >= r.left - hysteresis)
+                    && (x < r.right + hysteresis);
+
+            // Check whether the position is near some edge(s).
+            if ((Math.abs(r.left - x) < hysteresis) && verticalCheck) {
+                retval |= GROW_LEFT_EDGE;
+            }
+            if ((Math.abs(r.right - x) < hysteresis) && verticalCheck) {
+                retval |= GROW_RIGHT_EDGE;
+            }
+            if ((Math.abs(r.top - y) < hysteresis) && horizCheck) {
+                retval |= GROW_TOP_EDGE;
+            }
+            if ((Math.abs(r.bottom - y) < hysteresis) && horizCheck) {
+                retval |= GROW_BOTTOM_EDGE;
+            }
+
+            // Not near any edge but inside the rectangle: move.
+            if (retval == GROW_NONE && r.contains((int) x, (int) y)) {
+                retval = MOVE;
+            }
+        }
+        return retval;
+    }
+
+    // Handles motion (dx, dy) in screen space.
+    // The "edge" parameter specifies which edges the user is dragging.
+    void handleMotion(int edge, float dx, float dy) {
+
+        Rect r = computeLayout();
+        if (edge == GROW_NONE) {
+            return;
+        } else if (edge == MOVE) {
+            // Convert to image space before sending to moveBy().
+            moveBy(dx * (mCropRect.width() / r.width()),
+                    dy * (mCropRect.height() / r.height()));
+        } else {
+            if (((GROW_LEFT_EDGE | GROW_RIGHT_EDGE) & edge) == 0) {
+                dx = 0;
+            }
+
+            if (((GROW_TOP_EDGE | GROW_BOTTOM_EDGE) & edge) == 0) {
+                dy = 0;
+            }
+
+            // Convert to image space before sending to growBy().
+            float xDelta = dx * (mCropRect.width() / r.width());
+            float yDelta = dy * (mCropRect.height() / r.height());
+            growBy((((edge & GROW_LEFT_EDGE) != 0) ? -1 : 1) * xDelta,
+                    (((edge & GROW_TOP_EDGE) != 0) ? -1 : 1) * yDelta);
+        }
+    }
+
+    // Grows the cropping rectange by (dx, dy) in image space.
+    void moveBy(float dx, float dy) {
+
+        Rect invalRect = new Rect(mDrawRect);
+
+        mCropRect.offset(dx, dy);
+
+        // Put the cropping rectangle inside image rectangle.
+        mCropRect.offset(
+                Math.max(0, mImageRect.left - mCropRect.left),
+                Math.max(0, mImageRect.top - mCropRect.top));
+
+        mCropRect.offset(
+                Math.min(0, mImageRect.right - mCropRect.right),
+                Math.min(0, mImageRect.bottom - mCropRect.bottom));
+
+        mDrawRect = computeLayout();
+        invalRect.union(mDrawRect);
+        invalRect.inset(-10, -10);
+        mContext.invalidate(invalRect);
+    }
+
+    // Grows the cropping rectange by (dx, dy) in image space.
+    void growBy(float dx, float dy) {
+
+        if (mMaintainAspectRatio) {
+            if (dx != 0) {
+                dy = dx / mInitialAspectRatio;
+            } else if (dy != 0) {
+                dx = dy * mInitialAspectRatio;
+            }
+        }
+
+        // Don't let the cropping rectangle grow too fast.
+        // Grow at most half of the difference between the image rectangle and
+        // the cropping rectangle.
+        RectF r = new RectF(mCropRect);
+        if (dx > 0F && r.width() + 2 * dx > mImageRect.width()) {
+            float adjustment = (mImageRect.width() - r.width()) / 2F;
+            dx = adjustment;
+            if (mMaintainAspectRatio) {
+                dy = dx / mInitialAspectRatio;
+            }
+        }
+        if (dy > 0F && r.height() + 2 * dy > mImageRect.height()) {
+            float adjustment = (mImageRect.height() - r.height()) / 2F;
+            dy = adjustment;
+            if (mMaintainAspectRatio) {
+                dx = dy * mInitialAspectRatio;
+            }
+        }
+
+        r.inset(-dx, -dy);
+
+        // Don't let the cropping rectangle shrink too fast.
+        final float widthCap = 25F;
+        if (r.width() < widthCap) {
+            r.inset(-(widthCap - r.width()) / 2F, 0F);
+        }
+        float heightCap = mMaintainAspectRatio
+                ? (widthCap / mInitialAspectRatio)
+                : widthCap;
+        if (r.height() < heightCap) {
+            r.inset(0F, -(heightCap - r.height()) / 2F);
+        }
+
+        // Put the cropping rectangle inside the image rectangle.
+        if (r.left < mImageRect.left) {
+            r.offset(mImageRect.left - r.left, 0F);
+        } else if (r.right > mImageRect.right) {
+            r.offset(-(r.right - mImageRect.right), 0);
+        }
+        if (r.top < mImageRect.top) {
+            r.offset(0F, mImageRect.top - r.top);
+        } else if (r.bottom > mImageRect.bottom) {
+            r.offset(0F, -(r.bottom - mImageRect.bottom));
+        }
+
+        mCropRect.set(r);
+        mDrawRect = computeLayout();
+        mContext.invalidate();
+    }
+
+    // Returns the cropping rectangle in image space.
+    public Rect getCropRect() {
+
+        return new Rect((int) mCropRect.left, (int) mCropRect.top,
+                (int) mCropRect.right, (int) mCropRect.bottom);
+    }
+
+    // Maps the cropping rectangle from image space to screen space.
+    private Rect computeLayout() {
+
+        RectF r = new RectF(mCropRect.left, mCropRect.top,
+                mCropRect.right, mCropRect.bottom);
+        mMatrix.mapRect(r);
+        return new Rect(Math.round(r.left), Math.round(r.top),
+                Math.round(r.right), Math.round(r.bottom));
+    }
+
+    public void invalidate() {
+
+        mDrawRect = computeLayout();
+    }
+
+    public void setup(Matrix m, Rect imageRect, RectF cropRect, boolean circle,
+                      boolean maintainAspectRatio) {
+
+        if (circle) {
+            maintainAspectRatio = true;
+        }
+        mMatrix = new Matrix(m);
+
+        mCropRect = cropRect;
+        mImageRect = new RectF(imageRect);
+        mMaintainAspectRatio = maintainAspectRatio;
+        mCircle = circle;
+
+        mInitialAspectRatio = mCropRect.width() / mCropRect.height();
+        mDrawRect = computeLayout();
+
+        mFocusPaint.setARGB(125, 50, 50, 50);
+        mNoFocusPaint.setARGB(125, 50, 50, 50);
+        mOutlinePaint.setStrokeWidth(3F);
+        mOutlinePaint.setStyle(Paint.Style.STROKE);
+        mOutlinePaint.setAntiAlias(true);
+
+        mMode = ModifyMode.None;
+        init();
+    }
+
+    enum ModifyMode {None, Move, Grow}
+
+    private ModifyMode mMode = ModifyMode.None;
+
+    Rect mDrawRect;  // in screen space
+    private RectF mImageRect;  // in image space
+    RectF  mCropRect;  // in image space
+    Matrix mMatrix;
+
+    private boolean mMaintainAspectRatio = false;
+    private float mInitialAspectRatio;
+    private boolean mCircle = false;
+
+    private Drawable mResizeDrawableWidth;
+    private Drawable mResizeDrawableHeight;
+    private Drawable mResizeDrawableDiagonal;
+
+    private final Paint mFocusPaint   = new Paint();
+    private final Paint mNoFocusPaint = new Paint();
+    private final Paint mOutlinePaint = new Paint();
+}
Index: common/src/main/java/com/scene/common/common/utils/PackageUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/PackageUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/PackageUtil.java	(revision )
@@ -0,0 +1,276 @@
+package com.scene.common.common.utils;
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.provider.Settings;
+import android.widget.Toast;
+import com.scene.common.common.assist.Check;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author MaTianyu
+ * @date 14-11-7
+ */
+public class PackageUtil {
+    /**
+     * App installation location flags of android system
+     */
+    public static final int APP_INSTALL_AUTO = 0;
+    public static final int APP_INSTALL_INTERNAL = 1;
+    public static final int APP_INSTALL_EXTERNAL = 2;
+
+    /**
+     * 调用系统安装应用
+     */
+    public static boolean install(Context context, File file) {
+        if (file == null || !file.exists() || !file.isFile()) {
+            return false;
+        }
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        intent.setDataAndType(Uri.fromFile(file), "application/vnd.android.package-archive");
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(intent);
+        return true;
+    }
+
+    /**
+     * 调用系统卸载应用
+     */
+    public static void uninstallApk(Context context, String packageName) {
+        Intent intent = new Intent(Intent.ACTION_DELETE);
+        Uri packageURI = Uri.parse("package:" + packageName);
+        intent.setData(packageURI);
+        context.startActivity(intent);
+    }
+
+    /**
+     * 打开已安装应用的详情
+     */
+    public static void goToInstalledAppDetails(Context context, String packageName) {
+        Intent intent = new Intent();
+        int sdkVersion = Build.VERSION.SDK_INT;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+            intent.setData(Uri.fromParts("package", packageName, null));
+        } else {
+            intent.setAction(Intent.ACTION_VIEW);
+            intent.setClassName("com.android.settings", "com.android.settings.InstalledAppDetails");
+            intent.putExtra((sdkVersion == Build.VERSION_CODES.FROYO ? "pkg"
+                    : "com.android.settings.ApplicationPkgName"), packageName);
+        }
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(intent);
+    }
+
+
+    /**
+     * 获取指定程序信息
+     */
+    public static ActivityManager.RunningTaskInfo getTopRunningTask(Context context) {
+        try {
+            ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+            // 得到当前正在运行的任务栈
+            List<ActivityManager.RunningTaskInfo> runningTasks = am.getRunningTasks(1);
+            // 得到前台显示的任务栈
+            ActivityManager.RunningTaskInfo runningTaskInfo = runningTasks.get(0);
+            return runningTaskInfo;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+
+    public static int getAppVersionCode(Context context) {
+        if (context != null) {
+            PackageManager pm = context.getPackageManager();
+            if (pm != null) {
+                PackageInfo pi;
+                try {
+                    pi = pm.getPackageInfo(context.getPackageName(), 0);
+                    if (pi != null) {
+                        return pi.versionCode;
+                    }
+                } catch (NameNotFoundException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * 获取当前系统安装应用的默认位置
+     *
+     * @return APP_INSTALL_AUTO or APP_INSTALL_INTERNAL or APP_INSTALL_EXTERNAL.
+     */
+    public static int getInstallLocation() {
+        ShellUtil.CommandResult commandResult = ShellUtil.execCommand(
+                "LD_LIBRARY_PATH=/vendor/lib:/system/lib pm get-install-location", false, true);
+        if (commandResult.result == 0 && commandResult.responseMsg != null && commandResult.responseMsg.length() > 0) {
+            try {
+                return Integer.parseInt(commandResult.responseMsg.substring(0, 1));
+            } catch (NumberFormatException e) {
+                e.printStackTrace();
+            }
+        }
+        return APP_INSTALL_AUTO;
+    }
+
+
+    /**
+     * get app package info
+     */
+    public static PackageInfo getAppPackageInfo(Context context) {
+        if (context != null) {
+            PackageManager pm = context.getPackageManager();
+            if (pm != null) {
+                PackageInfo pi;
+                try {
+                    return pm.getPackageInfo(context.getPackageName(), 0);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * whether context is system application
+     */
+    public static boolean isSystemApplication(Context context) {
+        if (context == null) {
+            return false;
+        }
+        return isSystemApplication(context, context.getPackageName());
+    }
+
+    /**
+     * whether packageName is system application
+     */
+    public static boolean isSystemApplication(Context context, String packageName) {
+        PackageManager packageManager = context.getPackageManager();
+        if (packageManager == null || packageName == null || packageName.length() == 0) {
+            return false;
+        }
+        try {
+            ApplicationInfo app = packageManager.getApplicationInfo(packageName, 0);
+            return (app != null && (app.flags & ApplicationInfo.FLAG_SYSTEM) > 0);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+    /**
+     * 获取已安装的全部应用信息
+     */
+    public static List<PackageInfo> getInsatalledPackages(Context context) {
+        return context.getPackageManager().getInstalledPackages(0);
+    }
+
+    /**
+     * 获取已安装的全部应用信息
+     */
+    public static boolean isInsatalled(Context context, String pkg) {
+        if (!Check.isEmpty(pkg)) {
+            List<PackageInfo> list = getInsatalledPackages(context);
+            if (!Check.isEmpty(list)) {
+                for (PackageInfo pi : list) {
+                    if (pkg.equalsIgnoreCase(pi.packageName)) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * 获取指定程序信息
+     */
+    public static ApplicationInfo getApplicationInfo(Context context, String pkg) {
+        try {
+            return context.getPackageManager().getApplicationInfo(pkg, 0);
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    /**
+     * 获取指定程序信息
+     */
+    public static PackageInfo getPackageInfo(Context context, String pkg) {
+        try {
+            return context.getPackageManager().getPackageInfo(pkg, 0);
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    /**
+     * 启动应用
+     */
+    public static boolean startAppByPackageName(Context context, String packageName) {
+        return startAppByPackageName(context, packageName, null);
+    }
+
+    /**
+     * 启动应用
+     */
+    public static boolean startAppByPackageName(Context context, String packageName, Map<String, String> param) {
+        PackageInfo pi = null;
+        try {
+            pi = context.getPackageManager().getPackageInfo(packageName, 0);
+            Intent resolveIntent = new Intent(Intent.ACTION_MAIN, null);
+            resolveIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT) {
+                resolveIntent.setPackage(pi.packageName);
+            }
+
+            List<ResolveInfo> apps = context.getPackageManager().queryIntentActivities(resolveIntent, 0);
+
+            ResolveInfo ri = apps.iterator().next();
+            if (ri != null) {
+                String packageName1 = ri.activityInfo.packageName;
+                String className = ri.activityInfo.name;
+
+                Intent intent = new Intent(Intent.ACTION_MAIN);
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                intent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+                ComponentName cn = new ComponentName(packageName1, className);
+
+                intent.setComponent(cn);
+                if (param != null) {
+                    for (Map.Entry<String, String> en : param.entrySet()) {
+                        intent.putExtra(en.getKey(), en.getValue());
+                    }
+                }
+                context.startActivity(intent);
+                return true;
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            Toast.makeText(context.getApplicationContext(), "启动失败",
+                    Toast.LENGTH_LONG).show();
+        }
+        return false;
+    }
+
+}
Index: mylib/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/values/colors.xml	(revision )
+++ mylib/src/main/res/values/colors.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="sample_common_list_bottom_text_color">#666666</color>
+
+    <!--apsts-->
+    <color name="background_tab_pressed">#6633B5E5</color>
+    <color name="red">#E43F3E</color>
+</resources>
Index: mylib/src/main/java/com/scene/mylib/view/weight/LoadingFooter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/weight/LoadingFooter.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/weight/LoadingFooter.java	(revision )
@@ -0,0 +1,160 @@
+package com.scene.mylib.view.weight;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewStub;
+import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.scene.mylib.R;
+
+
+/**
+ * Created by scene on 2015/10/9.
+ * <p/>
+ * ListView/GridView/RecyclerView 分页加载时使用到的FooterView
+ */
+public class LoadingFooter extends RelativeLayout {
+
+    protected State mState = State.Normal;
+    private View mLoadingView;
+    private View mNetworkErrorView;
+    private View mTheEndView;
+    private ProgressBar mLoadingProgress;
+    private TextView mLoadingText;
+
+    public LoadingFooter(Context context) {
+        super(context);
+        init(context);
+    }
+
+    public LoadingFooter(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public LoadingFooter(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init(context);
+    }
+
+    public void init(Context context) {
+
+        inflate(context, R.layout.sample_common_list_footer, this);
+        setOnClickListener(null);
+
+        setState(State.Normal, true);
+    }
+
+    public State getState() {
+        return mState;
+    }
+
+    public void setState(State status ) {
+        setState(status, true);
+    }
+
+    /**
+     * 设置状态
+     *
+     * @param status
+     * @param showView 是否展示当前View
+     */
+    public void setState(State status, boolean showView) {
+        if (mState == status) {
+            return;
+        }
+        mState = status;
+
+        switch (status) {
+
+            case Normal:
+                setOnClickListener(null);
+                if (mLoadingView != null) {
+                    mLoadingView.setVisibility(GONE);
+                }
+
+                if (mTheEndView != null) {
+                    mTheEndView.setVisibility(GONE);
+                }
+
+                if (mNetworkErrorView != null) {
+                    mNetworkErrorView.setVisibility(GONE);
+                }
+
+                break;
+            case Loading:
+                setOnClickListener(null);
+                if (mTheEndView != null) {
+                    mTheEndView.setVisibility(GONE);
+                }
+
+                if (mNetworkErrorView != null) {
+                    mNetworkErrorView.setVisibility(GONE);
+                }
+
+                if (mLoadingView == null) {
+                    ViewStub viewStub = (ViewStub) findViewById(R.id.loading_viewstub);
+                    mLoadingView = viewStub.inflate();
+
+                    mLoadingProgress = (ProgressBar) mLoadingView.findViewById(R.id.loading_progress);
+                    mLoadingText = (TextView) mLoadingView.findViewById(R.id.loading_text);
+                } else {
+                    mLoadingView.setVisibility(VISIBLE);
+                }
+
+                mLoadingView.setVisibility(showView ? VISIBLE : GONE);
+
+                mLoadingProgress.setVisibility(View.VISIBLE);
+                mLoadingText.setText(R.string.list_footer_loading);
+                break;
+            case TheEnd:
+                //setOnClickListener(null);
+                if (mLoadingView != null) {
+                    mLoadingView.setVisibility(GONE);
+                }
+
+                if (mNetworkErrorView != null) {
+                    mNetworkErrorView.setVisibility(GONE);
+                }
+
+                if (mTheEndView == null) {
+                    ViewStub viewStub = (ViewStub) findViewById(R.id.end_viewstub);
+                    mTheEndView = viewStub.inflate();
+                } else {
+                    mTheEndView.setVisibility(VISIBLE);
+                }
+
+                mTheEndView.setVisibility(showView ? VISIBLE : GONE);
+                break;
+            case NetWorkError:
+
+                if (mLoadingView != null) {
+                    mLoadingView.setVisibility(GONE);
+                }
+
+                if (mTheEndView != null) {
+                    mTheEndView.setVisibility(GONE);
+                }
+
+                if (mNetworkErrorView == null) {
+                    ViewStub viewStub = (ViewStub) findViewById(R.id.network_error_viewstub);
+                    mNetworkErrorView = viewStub.inflate();
+                } else {
+                    mNetworkErrorView.setVisibility(VISIBLE);
+                }
+
+                mNetworkErrorView.setVisibility(showView ? VISIBLE : GONE);
+                break;
+            default:
+
+                break;
+        }
+    }
+
+    public static enum State {
+        Normal/**正常*/, TheEnd/**加载到最底了*/, Loading/**加载中..*/, NetWorkError/**网络异常*/
+    }
+}
\ No newline at end of file
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/build.gradle	(revision )
+++ app/build.gradle	(revision )
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        applicationId "com.scene.sceneandroiddemo"
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+    signingConfigs {
+        mycon {
+            storeFile file('C:\\Users\\Administrator\\Desktop\\SceneAndroidDemo\\SceneAndroidDemo.jks')
+            keyAlias 'SceneAndroidDemo'
+            keyPassword '123456'
+            storePassword '123456'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(include: ['*.jar'], dir: 'libs')
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+    //注解库
+    compile files('libs/butterknife-7.0.1.jar')
+    //基础库
+    compile project(':mylib')
+    //裁剪库目前没用
+    compile project(':ucrop')
+    //图片选择与裁剪库
+    compile project(':chooseimagelib')
+    //6.0权限验证库
+    compile project(':easypermissions')
+    //图片处理库 使用说明见https://github.com/renjunjia3/FrescoImageView
+    //基于fresco的基础上自定义的
+    compile project(':customfresco')
+    //时间轴
+    compile project(':timeline')
+    //工具库
+    compile project(':common')
+}
Index: chooseimagelib/src/main/res/drawable/selector_crop_button.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/res/drawable/selector_crop_button.xml	(revision )
+++ chooseimagelib/src/main/res/drawable/selector_crop_button.xml	(revision )
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_focused="true" android:state_pressed="true" android:drawable="@drawable/btn_crop_pressed"/>
+    <item android:state_focused="false" android:state_pressed="true" android:drawable="@drawable/btn_crop_pressed"/>
+    <item android:state_focused="true" android:drawable="@drawable/btn_crop_pressed"/>
+    <item android:state_focused="false" android:state_pressed="false" android:drawable="@drawable/btn_crop_operator"/>
+</selector>
Index: customfresco/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/AndroidManifest.xml	(revision )
+++ customfresco/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.scene.customfresco">
+
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
Index: app/src/main/res/layout/fragment4.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/fragment4.xml	(revision )
+++ app/src/main/res/layout/fragment4.xml	(revision )
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <android.support.v7.widget.RecyclerView
+        android:id="@+id/recyclerView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+</LinearLayout>
\ No newline at end of file
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/ImageChooseUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/ImageChooseUtil.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/ImageChooseUtil.java	(revision )
@@ -0,0 +1,126 @@
+package com.scene.chooseimagelib;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Build;
+import android.provider.MediaStore;
+
+import com.scene.chooseimagelib.simplecropimage.CropImage;
+
+/**
+ * 图片选择工具类
+ * Created by scene on 16/01/27.
+ */
+public class ImageChooseUtil {
+    public static final int GALLEY = 10001;
+    public static final int GALLEY_CROP = 10002;
+    public static final int GALLEY_KITKAT = 10003;
+    public static final int GALLEY_KITKAT_CROP = 10004;
+    public static final int CAMERA = 10005;
+    public static final int CAMERA_CROP = 10006;
+    public static final int CROP = 10007;
+
+
+    private static ImageChooseUtil instance = null;
+
+    public static synchronized ImageChooseUtil getInstance() {
+        if (instance == null) {
+            instance = new ImageChooseUtil();
+        }
+        return instance;
+    }
+
+    /**
+     * 打开相册
+     *
+     * @param mContext
+     */
+    public void openGalley(Context mContext, boolean isCrop) {
+        if (Build.VERSION.SDK_INT < 19) {
+            Intent intent = new Intent();
+            intent.setType("image/*");
+            intent.setAction(Intent.ACTION_GET_CONTENT);
+            if (isCrop) {
+                ((Activity) mContext).startActivityForResult(intent, GALLEY_CROP);
+            } else {
+                ((Activity) mContext).startActivityForResult(intent, GALLEY);
+            }
+        } else {
+            /**
+             * 4.4以上版本用这样的方式出来
+             */
+            Intent picture = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
+            if (isCrop) {
+                ((Activity) mContext).startActivityForResult(picture, GALLEY_KITKAT_CROP);
+            } else {
+                ((Activity) mContext).startActivityForResult(picture, GALLEY_KITKAT);
+            }
+        }
+    }
+
+    /**
+     * 打开相机
+     */
+    public void openCamera(Context mContext, Uri mTempUri, boolean isCrop) {
+
+        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
+        intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);// action is
+        // capture
+        //限制拍摄角度，解决三星机器问题
+        intent.putExtra(MediaStore.Images.Media.ORIENTATION, 0);
+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mTempUri);
+        if (isCrop) {
+            ((Activity) mContext).startActivityForResult(intent, CAMERA_CROP);
+        } else {
+            ((Activity) mContext).startActivityForResult(intent, CAMERA);
+        }
+    }
+
+    /**
+     * 调用系统裁剪
+     *
+     * @param uri
+     */
+    public void cropImageUri(Context mContext, Uri uri, Uri mTempUri) {
+        Intent intent = new Intent("com.android.camera.action.CROP");
+        intent.setDataAndType(uri, "image/*");
+        intent.putExtra("crop", "true");
+        intent.putExtra("aspectX", 1);
+        intent.putExtra("aspectY", 1);
+        intent.putExtra("scale", true);
+        intent.putExtra("return-data", false);
+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mTempUri);
+        intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
+        intent.putExtra("noFaceDetection", true); // no face detection
+        ((Activity) mContext).startActivityForResult(intent, CROP);
+    }
+
+    /**
+     * 第三方的裁剪
+     *
+     * @param mContext
+     * @param filepath
+     */
+    public void cropImageUri(Context mContext, String filepath, Uri mTempUri,int imgSize) {
+        // create explicit intent
+        Intent intent = new Intent(mContext, CropImage.class);
+        // tell CropImage activity to look for image to crop
+        intent.putExtra(CropImage.IMAGE_PATH, filepath);
+        intent.putExtra(CropImage.IMAGE_SAVE_PATH, mTempUri);
+        // allow CropImage activity to rescale image
+        intent.putExtra(CropImage.SCALE, true);
+        // if the aspect ratio is fixed to ratio 3/2
+        intent.putExtra(CropImage.ASPECT_X, 1);
+        intent.putExtra(CropImage.ASPECT_Y, 1);
+        intent.putExtra(CropImage.OUTPUT_X,imgSize);
+        intent.putExtra(CropImage.OUTPUT_Y,imgSize);
+
+        // start activity CropImage with certain request code and listen
+        // for result
+        ((Activity) mContext).startActivityForResult(intent, CROP);
+    }
+
+}
Index: common/src/main/java/com/scene/common/common/io/stream/StringBuilderWriter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/io/stream/StringBuilderWriter.java	(revision )
+++ common/src/main/java/com/scene/common/common/io/stream/StringBuilderWriter.java	(revision )
@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.scene.common.common.io.stream;
+
+import java.io.Serializable;
+import java.io.Writer;
+
+/**
+ * {@link Writer} implementation that outputs to a {@link StringBuilder}.
+ * <p>
+ * <strong>NOTE:</strong> This implementation, as an alternative to
+ * <code>java.io.StringWriter</code>, provides an <i>un-synchronized</i>
+ * (i.e. for use in a single thread) implementation for better performance.
+ * For safe usage with multiple {@link Thread}s then
+ * <code>java.io.StringWriter</code> should be used.
+ *
+ * @version $Id: StringBuilderWriter.java 1304052 2012-03-22 20:55:29Z ggregory $
+ * @since 2.0
+ */
+public class StringBuilderWriter extends Writer implements Serializable {
+
+    private final StringBuilder builder;
+
+    /**
+     * Construct a new {@link StringBuilder} instance with default capacity.
+     */
+    public StringBuilderWriter() {
+        this.builder = new StringBuilder();
+    }
+
+    /**
+     * Construct a new {@link StringBuilder} instance with the specified capacity.
+     *
+     * @param capacity The initial capacity of the underlying {@link StringBuilder}
+     */
+    public StringBuilderWriter(int capacity) {
+        this.builder = new StringBuilder(capacity);
+    }
+
+    /**
+     * Construct a new instance with the specified {@link StringBuilder}.
+     *
+     * @param builder The String builder
+     */
+    public StringBuilderWriter(StringBuilder builder) {
+        this.builder = builder != null ? builder : new StringBuilder();
+    }
+
+    /**
+     * Append a single character to this Writer.
+     *
+     * @param value The character to append
+     * @return This writer instance
+     */
+    @Override
+    public Writer append(char value) {
+        builder.append(value);
+        return this;
+    }
+
+    /**
+     * Append a character sequence to this Writer.
+     *
+     * @param value The character to append
+     * @return This writer instance
+     */
+    @Override
+    public Writer append(CharSequence value) {
+        builder.append(value);
+        return this;
+    }
+
+    /**
+     * Append a portion of a character sequence to the {@link StringBuilder}.
+     *
+     * @param value The character to append
+     * @param start The index of the first character
+     * @param end The index of the last character + 1
+     * @return This writer instance
+     */
+    @Override
+    public Writer append(CharSequence value, int start, int end) {
+        builder.append(value, start, end);
+        return this;
+    }
+
+    /**
+     * Closing this writer has no effect. 
+     */
+    @Override
+    public void close() {
+    }
+
+    /**
+     * Flushing this writer has no effect. 
+     */
+    @Override
+    public void flush() {
+    }
+
+
+    /**
+     * Write a String to the {@link StringBuilder}.
+     * 
+     * @param value The value to write
+     */
+    @Override
+    public void write(String value) {
+        if (value != null) {
+            builder.append(value);
+        }
+    }
+
+    /**
+     * Write a portion of a character array to the {@link StringBuilder}.
+     *
+     * @param value The value to write
+     * @param offset The index of the first character
+     * @param length The number of characters to write
+     */
+    @Override
+    public void write(char[] value, int offset, int length) {
+        if (value != null) {
+            builder.append(value, offset, length);
+        }
+    }
+
+    /**
+     * Return the underlying builder.
+     *
+     * @return The underlying builder
+     */
+    public StringBuilder getBuilder() {
+        return builder;
+    }
+
+    /**
+     * Returns {@link StringBuilder#toString()}.
+     *
+     * @return The contents of the String builder.
+     */
+    @Override
+    public String toString() {
+        return builder.toString();
+    }
+}
Index: mylib/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/values/styles.xml	(revision )
+++ mylib/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,92 @@
+<resources>
+    <!--自定义加载时处理不同状态显示-->
+    <declare-styleable name="LoadStateView">
+        <attr name="loadingProgressBarWidth" format="dimension" />
+        <attr name="loadingProgressBarHeight" format="dimension" />
+        <attr name="loadingBackgroundColor" format="color" />
+
+        <attr name="emptyImageWidth" format="dimension" />
+        <attr name="emptyImageHeight" format="dimension" />
+        <attr name="emptyTitleTextSize" format="dimension" />
+        <attr name="emptyContentTextSize" format="dimension" />
+        <attr name="emptyTitleTextColor" format="color" />
+        <attr name="emptyContentTextColor" format="color" />
+        <attr name="emptyBackgroundColor" format="color" />
+
+        <attr name="errorImageWidth" format="dimension" />
+        <attr name="errorImageHeight" format="dimension" />
+        <attr name="errorTitleTextSize" format="dimension" />
+        <attr name="errorContentTextSize" format="dimension" />
+        <attr name="errorTitleTextColor" format="color" />
+        <attr name="errorContentTextColor" format="color" />
+        <attr name="errorButtonTextColor" format="color" />
+        <attr name="errorBackgroundColor" format="color" />
+    </declare-styleable>
+
+    <!--自定义tab-->
+    <declare-styleable name="AdvancedPagerSlidingTabStrip">
+        <attr name="tabViewIndicatorColor" format="color" />
+        <attr name="tabViewUnderlineColor" format="color" />
+        <attr name="tabViewDividerColor" format="color" />
+        <attr name="tabViewTextSelectColor" format="color" />
+        <attr name="tabViewIndicatorHeight" format="dimension" />
+        <attr name="tabViewUnderlineHeight" format="dimension" />
+        <attr name="tabViewDividerPadding" format="dimension" />
+        <attr name="tabViewPaddingLeftRight" format="dimension" />
+        <attr name="tabViewPaddingTopBottom" format="dimension" />
+        <attr name="tabViewScrollOffset" format="dimension" />
+        <attr name="tabViewBackground" format="reference" />
+        <attr name="tabViewShouldExpand" format="boolean" />
+        <attr name="tabViewTextAllCaps" format="boolean" />
+        <attr name="tabViewDrawMode" format="enum">
+            <enum name="normal" value="0" />
+            <enum name="text" value="1" />
+        </attr>
+    </declare-styleable>
+
+    <!--自定义ratingbar-->
+    <declare-styleable name="ProperRatingBar">
+        <!-- Total number of ticks to show. Default is '5' -->
+        <attr name="prb_totalTicks" format="integer" />
+        <!-- Use this to set rating from xml. Default is '3' -->
+        <attr name="prb_defaultRating" format="integer" />
+        <!-- If set to 'true' - use will be able to change rating by clicking. Default is 'false' -->
+        <attr name="prb_clickable" format="boolean" />
+        <!-- Symbol to be used as a tick. Default is '$' -->
+        <attr name="prb_symbolicTick" format="string" />
+        <!-- Text size of symbolic tick. Default is '15sp' -->
+        <attr name="android:textSize" />
+        <!-- Text style of symbolic tick. Possible: 'bold', 'italic', 'normal'. Default is 'normal'. -->
+        <attr name="android:textStyle" />
+        <!-- Color of symbolic tick that is not selected (not rated). Default is '#FF000000' (black). -->
+        <attr name="prb_symbolicTickNormalColor" format="reference|color" />
+        <!-- Color of symbolic tick that is selected (rated). Default is '#FF888888' (gray). -->
+        <attr name="prb_symbolicTickSelectedColor" format="reference|color" />
+        <!-- Drawable resource to use as a tick that is not selected (not rated). No default value. -->
+        <attr name="prb_tickNormalDrawable" format="reference" />
+        <!-- Drawable resource to use as a tick that is selected (rated). No default value. -->
+        <attr name="prb_tickSelectedDrawable" format="reference" />
+        <!-- Margin to be applied to tick drawables. Only applies to drawable-type ticks. Default is '1dp' (gray). -->
+        <attr name="prb_tickSpacing" format="dimension" />
+    </declare-styleable>
+    <item name="prb_child_tag_id" type="id" />
+
+    <!--自定义的侧滑删除-->
+    <declare-styleable name="SwipeLayout">
+        <attr name="drag_edge">
+            <flag name="left" value="1" />
+            <flag name="right" value="2" />
+            <flag name="top" value="4" />
+            <flag name="bottom" value="8" />
+        </attr>
+        <attr name="leftEdgeSwipeOffset" format="dimension" />
+        <attr name="rightEdgeSwipeOffset" format="dimension" />
+        <attr name="topEdgeSwipeOffset" format="dimension" />
+        <attr name="bottomEdgeSwipeOffset" format="dimension" />
+        <attr name="show_mode" format="enum">
+            <enum name="lay_down" value="0" />
+            <enum name="pull_out" value="1" />
+        </attr>
+        <attr name="clickToClose" format="boolean" />
+    </declare-styleable>
+</resources>
Index: timeline/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timeline/src/main/AndroidManifest.xml	(revision )
+++ timeline/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.scene.timeline">
+
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
Index: chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/MonitoredActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/MonitoredActivity.java	(revision )
+++ chooseimagelib/src/main/java/com/scene/chooseimagelib/simplecropimage/MonitoredActivity.java	(revision )
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.scene.chooseimagelib.simplecropimage;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+import java.util.ArrayList;
+
+public class MonitoredActivity extends Activity {
+
+    private final ArrayList<LifeCycleListener> mListeners =
+            new ArrayList<LifeCycleListener>();
+
+    public static interface LifeCycleListener {
+
+        public void onActivityCreated(MonitoredActivity activity);
+
+        public void onActivityDestroyed(MonitoredActivity activity);
+
+        public void onActivityPaused(MonitoredActivity activity);
+
+        public void onActivityResumed(MonitoredActivity activity);
+
+        public void onActivityStarted(MonitoredActivity activity);
+
+        public void onActivityStopped(MonitoredActivity activity);
+    }
+
+    public static class LifeCycleAdapter implements LifeCycleListener {
+
+        public void onActivityCreated(MonitoredActivity activity) {
+
+        }
+
+        public void onActivityDestroyed(MonitoredActivity activity) {
+
+        }
+
+        public void onActivityPaused(MonitoredActivity activity) {
+
+        }
+
+        public void onActivityResumed(MonitoredActivity activity) {
+
+        }
+
+        public void onActivityStarted(MonitoredActivity activity) {
+
+        }
+
+        public void onActivityStopped(MonitoredActivity activity) {
+
+        }
+    }
+
+    public void addLifeCycleListener(LifeCycleListener listener) {
+
+        if (mListeners.contains(listener)) return;
+        mListeners.add(listener);
+    }
+
+    public void removeLifeCycleListener(LifeCycleListener listener) {
+
+        mListeners.remove(listener);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+
+        super.onCreate(savedInstanceState);
+        for (LifeCycleListener listener : mListeners) {
+            listener.onActivityCreated(this);
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+
+        super.onDestroy();
+        for (LifeCycleListener listener : mListeners) {
+            listener.onActivityDestroyed(this);
+        }
+    }
+
+    @Override
+    protected void onStart() {
+
+        super.onStart();
+        for (LifeCycleListener listener : mListeners) {
+            listener.onActivityStarted(this);
+        }
+    }
+
+    @Override
+    protected void onStop() {
+
+        super.onStop();
+        for (LifeCycleListener listener : mListeners) {
+            listener.onActivityStopped(this);
+        }
+    }
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/activity/SelectAndCropImageActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/activity/SelectAndCropImageActivity.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/activity/SelectAndCropImageActivity.java	(revision )
@@ -0,0 +1,194 @@
+package com.scene.sceneandroiddemo.ui.activity;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v7.widget.Toolbar;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.scene.chooseimagelib.ImageChooseUtil;
+import com.scene.chooseimagelib.simplecropimage.CropImage;
+import com.scene.sceneandroiddemo.BaseActivity;
+import com.scene.sceneandroiddemo.FileUtil;
+import com.scene.sceneandroiddemo.PermissionConfig;
+import com.scene.sceneandroiddemo.R;
+
+import java.io.File;
+
+import butterknife.Bind;
+import butterknife.OnClick;
+
+/**
+ * 图片选择与裁剪
+ * 目前通过相册选取照片进行裁剪有问题
+ * 以后在慢慢优化
+ * Created by scene on 16/01/27.
+ */
+public class SelectAndCropImageActivity extends BaseActivity {
+    @Bind(R.id.toolbar)
+    Toolbar toolbar;
+    @Bind(R.id.img)
+    ImageView img;
+
+    //图片缓存uri
+    private Uri mTempUri, mTempCropUri;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        initToolBar();
+    }
+
+    @Override
+    protected int setLayoutResId() {
+        return R.layout.activity_select_and_crop_image;
+    }
+
+    @OnClick(R.id.galley)
+    public void onClickGalley() {
+        //检查权限
+        setPermissionType(PermissionConfig.TYPE_PERMISSION_1);
+        applyStoragePermission();
+    }
+
+    @OnClick(R.id.camera)
+    public void onClickCamera() {
+        setPermissionType(PermissionConfig.TYPE_PERMISSION_1);
+        applyCameraPermission();
+    }
+
+    @OnClick(R.id.galleyCrop)
+    public void onClickGalleyCrop() {
+        setPermissionType(PermissionConfig.TYPE_PERMISSION_2);
+        applyStoragePermission();
+    }
+
+    @OnClick(R.id.cameraCrop)
+    public void onClickCameraCrop() {
+        setPermissionType(PermissionConfig.TYPE_PERMISSION_2);
+        applyCameraPermission();
+    }
+
+    private void initToolBar() {
+        toolbar.setTitle("图片选择与裁剪");
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+        }
+        toolbar.setNavigationOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                finish();
+            }
+        });
+    }
+
+    /**
+     * 相机权限成功
+     */
+    @Override
+    public void onCameraPermissionSuccess(int type) {
+        if (type == PermissionConfig.TYPE_PERMISSION_1) {
+            initTempUri();
+            ImageChooseUtil.getInstance().openCamera(mContext, mTempUri, false);
+        } else if (type == PermissionConfig.TYPE_PERMISSION_2) {
+            initTempUri();
+            ImageChooseUtil.getInstance().openCamera(mContext, mTempUri, true);
+        }
+    }
+
+    /**
+     * 存储空间权限成功
+     *
+     * @param type
+     */
+    @Override
+    public void onStoragePermissionSuccess(int type) {
+        if (type == PermissionConfig.TYPE_PERMISSION_1) {
+            ImageChooseUtil.getInstance().openGalley(mContext, false);
+        } else if (type == PermissionConfig.TYPE_PERMISSION_2) {
+            ImageChooseUtil.getInstance().openGalley(mContext, true);
+        }
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        //判断是否是4.4以上版本
+        final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+        if (resultCode != Activity.RESULT_OK) {
+            FileUtil.delTempFile(mContext);
+            return;
+        }
+        switch (requestCode) {
+            case ImageChooseUtil.GALLEY:
+                if (null != data) {
+                    Uri uri = data.getData();
+                    img.setImageURI(uri);
+                }
+                break;
+            case ImageChooseUtil.GALLEY_KITKAT:
+                if (null != data) {
+                    Uri uri = data.getData();
+                    // 先将这个uri转换为path，然后再转换为uri
+                    String thePath = FileUtil.getPath(mContext, uri);
+                    Uri uri2 = Uri.fromFile(new File(thePath));
+                    img.setImageURI(uri2);
+                }
+                break;
+            case ImageChooseUtil.CAMERA:
+                if (mTempUri != null) {
+                    img.setImageURI(mTempUri);
+                }
+                break;
+            case ImageChooseUtil.GALLEY_CROP:
+                if (null != data) {
+                    initCropUri();
+                    Uri uri = data.getData();
+                    String thePath = FileUtil.getPath(mContext, uri);
+                    ImageChooseUtil.getInstance().cropImageUri(mContext, thePath, mTempUri, 300);
+                }
+                break;
+            case ImageChooseUtil.GALLEY_KITKAT_CROP:
+                if (null != data) {
+                    Uri uri = data.getData();
+                    // 先将这个uri转换为path，然后再转换为uri
+                    String thePath = FileUtil.getPath(mContext, uri);
+                    Uri uri2 = Uri.fromFile(new File(thePath));
+                    ImageChooseUtil.getInstance().cropImageUri(mContext, uri2.getPath(), mTempCropUri, 300);
+                }
+                break;
+            case ImageChooseUtil.CAMERA_CROP:
+                if (mTempUri != null) {
+                    ImageChooseUtil.getInstance().cropImageUri(mContext, mTempUri.getPath(), mTempUri, 300);
+                }
+            case ImageChooseUtil.CROP:
+                String path = data.getStringExtra(CropImage.IMAGE_PATH);
+                if (path != null) {
+                    img.setImageBitmap(BitmapFactory.decodeFile(path));
+                }
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    /**
+     * 获取缓存uri
+     */
+    private void initTempUri() {
+        FileUtil.delTempFile(mContext);
+        mTempUri = FileUtil.getTempUri(mContext);
+    }
+
+    /**
+     * 获取裁剪缓存uri
+     */
+    private void initCropUri() {
+        mTempCropUri = FileUtil.getTempUri(mContext);
+    }
+}
Index: common/src/main/java/com/scene/common/common/utils/NumberUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/NumberUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/NumberUtil.java	(revision )
@@ -0,0 +1,82 @@
+package com.scene.common.common.utils;
+
+/**
+ * @author MaTianyu
+ * @date 2014-11-21
+ */
+public class NumberUtil {
+
+    public static int convertToint(String intStr, int defValue) {
+        try {
+            return Integer.parseInt(intStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return defValue;
+    }
+
+    public static long convertTolong(String longStr, long defValue) {
+        try {
+            return Long.parseLong(longStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return defValue;
+    }
+
+    public static float convertTofloat(String fStr, float defValue) {
+        try {
+            return Float.parseFloat(fStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return defValue;
+    }
+
+    public static double convertTodouble(String dStr, double defValue) {
+        try {
+            return Double.parseDouble(dStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return defValue;
+    }
+
+
+    public static Integer convertToInteger(String intStr) {
+        try {
+            return Integer.parseInt(intStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static Long convertToLong(String longStr) {
+        try {
+            return Long.parseLong(longStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static Float convertToFloat(String fStr) {
+        try {
+            return Float.parseFloat(fStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static Double convertToDouble(String dStr) {
+        try {
+            return Double.parseDouble(dStr);
+        } catch (NumberFormatException e) {
+            //e.printStackTrace();
+        }
+        return null;
+    }
+
+}
Index: ucrop/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/build.gradle	(revision )
+++ ucrop/build.gradle	(revision )
@@ -0,0 +1,29 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion '23.0.2'
+
+    defaultConfig {
+        minSdkVersion 10
+        targetSdkVersion 23
+        versionCode 2
+        versionName "1.0.1"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    resourcePrefix 'ucrop_'
+}
+
+dependencies {
+    compile 'com.android.support:appcompat-v7:23.1.1'
+}
Index: mylib/src/main/java/com/scene/mylib/view/tab/AdvancedPagerSlidingTabStrip.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/tab/AdvancedPagerSlidingTabStrip.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/tab/AdvancedPagerSlidingTabStrip.java	(revision )
@@ -0,0 +1,926 @@
+package com.scene.mylib.view.tab;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.Typeface;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.content.res.ResourcesCompat;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.SparseArray;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+import android.widget.HorizontalScrollView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.scene.mylib.R;
+
+import java.util.Locale;
+
+/**
+ * Created by scene on 2015/8/10.
+ */
+public class AdvancedPagerSlidingTabStrip extends HorizontalScrollView {
+
+    public interface IconTabProvider {
+        public <T extends Object> T getPageIcon(int position);
+        public <T extends Object> T getPageSelectIcon(int position);
+        public String getPageIconText(int position);
+    }
+
+    public interface ViewTabProvider{
+//        public View onCreateIconView(int position, View view, ViewGroup parent);
+        public View onSelectIconView(int position, View view, ViewGroup parent);
+        public View onIconView(int position, View view, ViewGroup parent);
+        public String getPageIconText(int position);
+    }
+
+    // @formatter:off
+    private static final int[] ATTRS = new int[]{
+            android.R.attr.textSize,
+            android.R.attr.textColor
+    };
+    // @formatter:on
+    private LinearLayout.LayoutParams expandedTabLayoutParams;
+
+    private final PageListener pageListener = new PageListener();
+    public ViewPager.OnPageChangeListener delegatePageListener;
+
+    private LinearLayout tabsContainer;
+    private ViewPager pager;
+
+    private int tabCount;
+
+    private int currentPosition = 0;
+    private float currentPositionOffset = 0f;
+
+    private Paint rectPaint;
+    private Paint dividerPaint;
+
+    private boolean checkedTabWidths = false;
+
+    private int indicatorColor = 0xFF666666;
+    private int underlineColor = 0x1A000000;
+    private int dividerColor = 0x1A000000;
+
+    private boolean shouldExpand = true;
+    private boolean textAllCaps = true;
+
+    private int scrollOffset = 52;
+    private int indicatorHeight = 3;
+    private int underlineHeight = 2;
+    private int dividerPadding = 12;
+    private int tabPadding = 24;
+    private int tabPaddingTopBottom = 0;
+    private int dividerWidth = 1;
+
+    private int tabTextSize = 15;
+    private int tabTextColor = 0xFF666666;
+    private int tabTextSelectColor = 0xFF666666;
+    private Typeface tabTypeface = null;
+    private int tabTypefaceStyle = Typeface.NORMAL;
+    private int tabDrawMode = DRAW_MODE_NORMAL;
+
+    public static final int DRAW_MODE_NORMAL = 0;
+    public static final int DRAW_MODE_TEXT = 1;
+
+    private int lastScrollX = 0;
+
+    private int tabBackgroundResId = R.drawable.psts_background_tab;
+//    private int tabBackgroundResId;
+
+    private Locale locale;
+
+    public AdvancedPagerSlidingTabStrip(Context context) {
+        this(context, null);
+    }
+
+    public AdvancedPagerSlidingTabStrip(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public AdvancedPagerSlidingTabStrip(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        setFillViewport(true);
+        setWillNotDraw(false);
+
+        tabsContainer = new LinearLayout(context);
+        tabsContainer.setOrientation(LinearLayout.HORIZONTAL);
+        tabsContainer.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        addView(tabsContainer);
+
+        DisplayMetrics dm = getResources().getDisplayMetrics();
+
+        scrollOffset = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, scrollOffset, dm);
+        indicatorHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, indicatorHeight, dm);
+        underlineHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, underlineHeight, dm);
+        dividerPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerPadding, dm);
+        tabPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, tabPadding, dm);
+        dividerWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerWidth, dm);
+        tabTextSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, tabTextSize, dm);
+
+        // get system attrs (android:textSize and android:textColor)
+
+        TypedArray a = context.obtainStyledAttributes(attrs, ATTRS);
+
+        tabTextSize = a.getDimensionPixelSize(0, tabTextSize);
+        tabTextColor = a.getColor(1, tabTextColor);
+
+        a.recycle();
+
+        // get custom attrs
+
+
+        a = context.obtainStyledAttributes(attrs, R.styleable.AdvancedPagerSlidingTabStrip);
+
+        indicatorColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewIndicatorColor, indicatorColor);
+        underlineColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewUnderlineColor, underlineColor);
+        dividerColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewDividerColor, dividerColor);
+        indicatorHeight = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewIndicatorHeight, indicatorHeight);
+        underlineHeight = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewUnderlineHeight, underlineHeight);
+        dividerPadding = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewDividerPadding, dividerPadding);
+        tabPadding = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewPaddingLeftRight, tabPadding);
+        tabPaddingTopBottom = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewPaddingTopBottom, tabPaddingTopBottom);
+        tabBackgroundResId = a.getResourceId(R.styleable.AdvancedPagerSlidingTabStrip_tabViewBackground, tabBackgroundResId);
+        shouldExpand = a.getBoolean(R.styleable.AdvancedPagerSlidingTabStrip_tabViewShouldExpand, shouldExpand);
+        scrollOffset = a.getDimensionPixelSize(R.styleable.AdvancedPagerSlidingTabStrip_tabViewScrollOffset, scrollOffset);
+        textAllCaps = a.getBoolean(R.styleable.AdvancedPagerSlidingTabStrip_tabViewTextAllCaps, textAllCaps);
+        tabTextSelectColor = a.getColor(R.styleable.AdvancedPagerSlidingTabStrip_tabViewTextSelectColor, dividerColor);
+        tabDrawMode = a.getInteger(R.styleable.AdvancedPagerSlidingTabStrip_tabViewDrawMode,DRAW_MODE_NORMAL);
+
+        a.recycle();
+
+        rectPaint = new Paint();
+        rectPaint.setAntiAlias(true);
+        rectPaint.setStyle(Style.FILL);
+
+        dividerPaint = new Paint();
+        dividerPaint.setAntiAlias(true);
+        dividerPaint.setStrokeWidth(dividerWidth);
+
+//        defaultTabLayoutParams = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+        expandedTabLayoutParams = new LinearLayout.LayoutParams(0, LayoutParams.MATCH_PARENT, 1.0f);
+
+        if (locale == null) {
+            locale = getResources().getConfiguration().locale;
+        }
+
+        if(mViewTabCache == null){
+            mViewTabCache = new SparseArray<>();
+        }
+    }
+
+    public void setViewPager(ViewPager pager) {
+        this.pager = pager;
+
+        if (pager.getAdapter() == null) {
+            throw new IllegalStateException("ViewPager does not have adapter instance.");
+        }
+
+        pager.addOnPageChangeListener(pageListener);
+
+        notifyDataSetChanged();
+    }
+
+    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
+        this.delegatePageListener = listener;
+    }
+
+    public void notifyDataSetChanged() {
+
+        tabsContainer.removeAllViews();
+
+        tabCount = pager.getAdapter().getCount();
+
+        for (int i = 0; i < tabCount; i++) {
+
+            if (pager.getAdapter() instanceof IconTabProvider) {
+                addIconTab(i, ((IconTabProvider) pager.getAdapter()).getPageIcon(i), ((IconTabProvider) pager.getAdapter()).getPageIconText(i));
+            } else if(pager.getAdapter() instanceof ViewTabProvider){
+                addViewTab(i, ((ViewTabProvider) pager.getAdapter()));
+            } else {
+//                addIconTab(i, R.drawable.home_categry_icon_n, pager.getAdapter().getPageTitle(i).toString());
+
+                addTextTab(i, pager.getAdapter().getPageTitle(i).toString());
+            }
+
+        }
+
+        updateTabStyles();
+
+        checkedTabWidths = false;
+
+        getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
+
+            @SuppressWarnings("deprecation")
+            @SuppressLint("NewApi")
+            @Override
+            public void onGlobalLayout() {
+
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                }
+
+                currentPosition = pager.getCurrentItem();
+                scrollToChild(currentPosition, 0);
+            }
+        });
+
+        pageListener.onPageSelected(0);//default
+
+    }
+
+    private void addTextTab(final int position, String title) {
+
+        RelativeLayout tab = new RelativeLayout(getContext());
+        tab.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                scrollToChild(position, 0);
+                pager.setCurrentItem(position);
+            }
+        });
+
+        TextView txt = new TextView(getContext());
+        txt.setText(title);
+        txt.setFocusable(true);
+        txt.setGravity(Gravity.CENTER);
+        txt.setSingleLine();
+        txt.setId(R.id.id_tab_txt);
+        RelativeLayout.LayoutParams txtParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
+        txtParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        txt.setLayoutParams(txtParams);
+
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(getResources().getDimensionPixelSize(R.dimen.psts_dot_wh), getResources().getDimensionPixelSize(R.dimen.psts_dot_wh));
+        TextView dot = new TextView(getContext());
+        dot.setTextColor(Color.WHITE);
+        dot.setBackgroundColor(Color.BLUE);
+        dot.setGravity(Gravity.CENTER);
+        dot.setSingleLine();
+        dot.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimensionPixelSize(R.dimen.psts_dot_txt_size));
+        //16 new
+        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            dot.setBackground(ResourcesCompat.getDrawable(getResources(), R.drawable.apsts_tips, null));
+        }else{
+            dot.setBackgroundDrawable(ResourcesCompat.getDrawable(getResources(), R.drawable.apsts_tips, null));
+        }
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+        layoutParams.setMargins(0, getResources().getDimensionPixelSize(R.dimen.psts_dot_m_top), getResources().getDimensionPixelSize(R.dimen.psts_dot_m_right), 0);
+        dot.setLayoutParams(layoutParams);
+
+        tab.addView(txt);
+        tab.addView(dot);
+        dot.setVisibility(View.GONE);
+        tabsContainer.addView(tab);
+
+    }
+
+    public void showDot(int index) {
+        RelativeLayout tab = (RelativeLayout) tabsContainer.getChildAt(index);
+        TextView dot_layout = (TextView) tab.getChildAt(tab.getChildCount() - 1);
+        dot_layout.setText("");
+        RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams)dot_layout.getLayoutParams();
+        layoutParams.width = getResources().getDimensionPixelSize(R.dimen.psts_dot_wh);
+        layoutParams.height = getResources().getDimensionPixelSize(R.dimen.psts_dot_wh);
+
+        dot_layout.setVisibility(View.VISIBLE);
+    }
+
+    public void showDot(int index,String dotTxt) {
+        RelativeLayout tab = (RelativeLayout) tabsContainer.getChildAt(index);
+        TextView dot_layout = (TextView) tab.getChildAt(tab.getChildCount() - 1);
+        RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams)dot_layout.getLayoutParams();
+        layoutParams.width = RelativeLayout.LayoutParams.WRAP_CONTENT;
+        layoutParams.height = RelativeLayout.LayoutParams.WRAP_CONTENT;
+        dot_layout.setText(dotTxt);
+        dot_layout.setVisibility(View.VISIBLE);
+    }
+
+    public void hideDot(int index) {
+        RelativeLayout tab = (RelativeLayout) tabsContainer.getChildAt(index);
+        TextView dot_layout = (TextView) tab.getChildAt(tab.getChildCount() - 1);
+        dot_layout.setVisibility(View.GONE);
+    }
+
+    private SparseArray<View> mViewTabCache;//缓存
+
+    private View getTabView(int position){
+        return mViewTabCache.get(position);
+    }
+
+    private void setTabView( int position ,View view){
+        mViewTabCache.put(position, view);
+    }
+
+    private void addViewTab(final int position, ViewTabProvider provider) {
+
+        RelativeLayout tab = new RelativeLayout(getContext());
+        tab.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                scrollToChild(position, 0);
+                pager.setCurrentItem(position);
+            }
+        });
+
+        //文本和图
+        TextView txt = new TextView(getContext());
+        txt.setText(provider.getPageIconText(position));
+        txt.setFocusable(true);
+        txt.setGravity(Gravity.CENTER);
+        txt.setSingleLine();
+        txt.setId(R.id.id_tab_txt);
+        RelativeLayout.LayoutParams txtParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
+        txtParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
+        txtParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
+        txt.setLayoutParams(txtParams);
+
+        //使用缓存
+        View view = provider.onIconView(position, getTabView(position), tab);
+        setTabView(position, view);//保存view到缓存中
+        RelativeLayout.LayoutParams viewLayoutParams
+                = (RelativeLayout.LayoutParams)view.getLayoutParams();
+        viewLayoutParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
+        viewLayoutParams.addRule(RelativeLayout.ABOVE, R.id.id_tab_txt);
+
+
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(getResources().getDimensionPixelSize(R.dimen.psts_dot_wh), getResources().getDimensionPixelSize(R.dimen.psts_dot_wh));
+        TextView dot = new TextView(getContext());
+        dot.setTextColor(Color.WHITE);
+        dot.setBackgroundColor(Color.BLUE);
+        dot.setGravity(Gravity.CENTER);
+        dot.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimensionPixelSize(R.dimen.psts_dot_txt_size));
+        dot.setSingleLine();
+        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            dot.setBackground(ResourcesCompat.getDrawable(getResources(), R.drawable.apsts_tips, null));
+        }else {
+            dot.setBackgroundDrawable(ResourcesCompat.getDrawable(getResources(), R.drawable.apsts_tips, null));
+        }
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+        layoutParams.setMargins(0, 0, getResources().getDimensionPixelSize(R.dimen.psts_dot_m_right), 0);
+
+        dot.setLayoutParams(layoutParams);
+
+        tab.addView(txt);
+        tab.addView(view);
+        tab.addView(dot);
+        dot.setVisibility(View.GONE);
+        tabsContainer.addView(tab);
+
+    }
+
+    private void addIconTab(final int position, Object res, String text) {
+
+        RelativeLayout tab = new RelativeLayout(getContext());
+        tab.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                scrollToChild(position, 0);
+                pager.setCurrentItem(position);
+            }
+        });
+
+        //文本和图
+        TextView txt = new TextView(getContext());
+        txt.setText(text);
+        txt.setFocusable(true);
+        txt.setGravity(Gravity.CENTER);
+        txt.setSingleLine();
+        txt.setId(R.id.id_tab_txt);
+        RelativeLayout.LayoutParams txtParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
+        txtParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        txt.setLayoutParams(txtParams);
+
+        setViewResource(res, txt);
+
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(getResources().getDimensionPixelSize(R.dimen.psts_dot_wh), getResources().getDimensionPixelSize(R.dimen.psts_dot_wh));
+        TextView dot = new TextView(getContext());
+        dot.setTextColor(Color.WHITE);
+        dot.setBackgroundColor(Color.BLUE);
+        dot.setGravity(Gravity.CENTER);
+        dot.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimensionPixelSize(R.dimen.psts_dot_txt_size));
+        dot.setSingleLine();
+        dot.setBackgroundDrawable(ResourcesCompat.getDrawable(getResources(), R.drawable.apsts_tips, null));
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+        layoutParams.setMargins(0, 0, getResources().getDimensionPixelSize(R.dimen.psts_dot_m_right), 0);
+
+        dot.setLayoutParams(layoutParams);
+
+        tab.addView(txt);
+        tab.addView(dot);
+        dot.setVisibility(View.GONE);
+        tabsContainer.addView(tab);
+
+    }
+
+    public View getTabAt(int pos) {
+        if (pos >= tabsContainer.getChildCount()) {
+            throw new IllegalStateException("pos is too big.");
+        }
+        return tabsContainer.getChildAt(pos);
+    }
+
+    private void updateTabStyles() {
+
+        for (int i = 0; i < tabCount; i++) {
+
+            View v = tabsContainer.getChildAt(i);
+
+            //v.setLayoutParams(defaultTabLayoutParams);
+            //my modify
+            v.setLayoutParams(expandedTabLayoutParams);
+            v.setBackgroundResource(tabBackgroundResId);
+            if (shouldExpand) {
+                v.setPadding(0, 0, 0, 0);
+            } else {
+                v.setPadding(tabPadding, tabPaddingTopBottom, tabPadding, tabPaddingTopBottom);
+            }
+
+            if (v instanceof RelativeLayout) {
+
+                RelativeLayout tab = (RelativeLayout) v;
+                TextView tv = (TextView)tab.getChildAt(0);
+                tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, tabTextSize);
+                tv.setTypeface(tabTypeface, tabTypefaceStyle);
+                tv.setTextColor(tabTextColor);
+
+                // setAllCaps() is only available from API 14, so the upper case is made manually if we are on a
+                // pre-ICS-build
+                if (textAllCaps) {
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+                        tv.setAllCaps(true);
+                    } else {
+                        tv.setText(tv.getText().toString().toUpperCase(locale));
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        if (!shouldExpand || MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.UNSPECIFIED) {
+            return;
+        }
+
+        int myWidth = getMeasuredWidth();
+        int childWidth = 0;
+        for (int i = 0; i < tabCount; i++) {
+            childWidth += tabsContainer.getChildAt(i).getMeasuredWidth();
+        }
+
+        if (!checkedTabWidths && childWidth > 0 && myWidth > 0) {
+
+            if (childWidth <= myWidth) {
+                for (int i = 0; i < tabCount; i++) {
+                    tabsContainer.getChildAt(i).setLayoutParams(expandedTabLayoutParams);
+                }
+            }
+
+            checkedTabWidths = true;
+        }
+    }
+
+    private void scrollToChild(int position, int offset) {
+
+        if (tabCount == 0) {
+            return;
+        }
+
+        int newScrollX = tabsContainer.getChildAt(position).getLeft() + offset;
+
+        if (position > 0 || offset > 0) {
+            newScrollX -= scrollOffset;
+        }
+
+        if (newScrollX != lastScrollX) {
+            lastScrollX = newScrollX;
+            scrollTo(newScrollX, 0);
+        }
+
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (isInEditMode() || tabCount == 0) {
+            return;
+        }
+
+        if(tabDrawMode == DRAW_MODE_NORMAL) {
+            drawTabNormalMode(canvas);
+        }else {
+            drawTabTextMode(canvas);
+        }
+    }
+
+    private void drawTabNormalMode(Canvas canvas){
+        final int height = getHeight();
+
+        // 设置提示下划线的颜色
+
+        rectPaint.setColor(indicatorColor);
+
+        // default: line below current tab
+        View currentTab = tabsContainer.getChildAt(currentPosition);
+        float lineLeft = currentTab.getLeft();
+        float lineRight = currentTab.getRight();
+
+        // if there is an offset, start interpolating left and right coordinates between current and next tab
+        if (currentPositionOffset > 0f && currentPosition < tabCount - 1) {
+
+            View nextTab = tabsContainer.getChildAt(currentPosition + 1);
+            final float nextTabLeft = nextTab.getLeft();
+            final float nextTabRight = nextTab.getRight();
+
+            lineLeft = (currentPositionOffset * nextTabLeft + (1f - currentPositionOffset) * lineLeft);
+            lineRight = (currentPositionOffset * nextTabRight + (1f - currentPositionOffset) * lineRight);
+
+        }
+
+        //绘制提示下划线
+        canvas.drawRect(lineLeft , height - indicatorHeight, lineRight , height, rectPaint);
+
+        // 绘制下划线
+
+        rectPaint.setColor(underlineColor);
+        canvas.drawRect(0, height - underlineHeight, tabsContainer.getWidth(), height, rectPaint);
+
+        // 绘制分割线
+
+        dividerPaint.setColor(dividerColor);
+        for (int i = 0; i < tabCount - 1; i++) {
+            View tab = tabsContainer.getChildAt(i);
+            canvas.drawLine(tab.getRight(), dividerPadding, tab.getRight(), height - dividerPadding, dividerPaint);
+        }
+    }
+
+    private void drawTabTextMode(Canvas canvas){
+
+        final int height = getHeight();
+
+        // 设置提示下划线的颜色
+
+        rectPaint.setColor(indicatorColor);
+
+        // default: line below current tab
+        View currentTab = tabsContainer.getChildAt(currentPosition);
+        float lineLeft = currentTab.getLeft();
+//        float lineRight = currentTab.getRight();
+
+        View currentTextView = ((RelativeLayout)currentTab).getChildAt(0);
+        float currentTextViewLeft = currentTextView.getLeft();
+        float currentTextViewRight = currentTextView.getRight();
+
+        // if there is an offset, start interpolating left and right coordinates between current and next tab
+        if (currentPositionOffset > 0f && currentPosition < tabCount - 1) {
+
+            View nextTab = tabsContainer.getChildAt(currentPosition + 1);
+            final float nextTabLeft = nextTab.getLeft();
+//            final float nextTabRight = nextTab.getRight();
+
+            lineLeft = (currentPositionOffset * nextTabLeft + (1f - currentPositionOffset) * lineLeft);
+//            lineRight = (currentPositionOffset * nextTabRight + (1f - currentPositionOffset) * lineRight);
+
+            View nextTextView = ((RelativeLayout)nextTab).getChildAt(0);
+            float nextTextViewLeft = nextTextView.getLeft();
+            float nextTextViewRight = nextTextView.getRight();
+
+            currentTextViewLeft = (currentPositionOffset * nextTextViewLeft + (1f - currentPositionOffset) * currentTextViewLeft);
+            currentTextViewRight = (currentPositionOffset * nextTextViewRight + (1f - currentPositionOffset) * currentTextViewRight);
+        }
+
+        //绘制提示下划线
+        canvas.drawRect(lineLeft + currentTextViewLeft, height - indicatorHeight, lineLeft + currentTextViewRight , height, rectPaint);
+
+
+//        rectPaint.setColor(underlineColor);
+//        canvas.drawRect(0, height - underlineHeight, tabsContainer.getWidth(), height, rectPaint);
+
+//        for(int i = 0 ; i < tabCount - 1 ; i ++){
+//            View tab = tabsContainer.getChildAt(i);
+//            View tabTextView = ((LinearLayout)tab).getChildAt(0);
+//            canvas.drawRect(tab.getLeft() + tabTextView.getLeft(), height - underlineHeight, tab.getLeft() + tabTextView.getRight(), height, rectPaint);
+//        }
+
+        // 分割线paint
+
+        dividerPaint.setColor(dividerColor);
+
+        // 下划线paint
+        rectPaint.setColor(underlineColor);
+
+        for (int i = 0; i < tabCount; i++) {
+            View tab = tabsContainer.getChildAt(i);
+            //绘制分割线
+            if(i < tabCount - 1) {
+                canvas.drawLine(tab.getRight(), dividerPadding, tab.getRight(), height - dividerPadding, dividerPaint);
+            }
+            View tabTextView = ((RelativeLayout)tab).getChildAt(0);
+            canvas.drawRect(tab.getLeft() + tabTextView.getLeft(), height - underlineHeight, tab.getLeft() + tabTextView.getRight(), height, rectPaint);
+        }
+    }
+
+    private class PageListener implements ViewPager.OnPageChangeListener {
+
+        @Override
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+
+            currentPosition = position;
+            currentPositionOffset = positionOffset;
+
+            if (tabsContainer != null && tabsContainer.getChildAt(position) != null) {
+                scrollToChild(position, (int) (positionOffset * tabsContainer.getChildAt(position).getWidth()));
+            }
+
+            invalidate();
+
+            if (delegatePageListener != null) {
+                delegatePageListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
+            }
+        }
+
+        @Override
+        public void onPageScrollStateChanged(int state) {
+            if (state == ViewPager.SCROLL_STATE_IDLE) {
+                scrollToChild(pager.getCurrentItem(), 0);
+            }
+
+            if (delegatePageListener != null) {
+                delegatePageListener.onPageScrollStateChanged(state);
+            }
+        }
+
+        @Override
+        public void onPageSelected(int position) {
+
+            setSelectItem(position);
+
+            if (delegatePageListener != null) {
+                delegatePageListener.onPageSelected(position);
+            }
+        }
+
+    }
+
+    private void setViewResource(Object obj , TextView view){
+        if(obj instanceof Integer) {
+            int resId = (int) obj;
+            if (resId != 0) {
+                view.setCompoundDrawablesWithIntrinsicBounds(0, resId, 0, 0);
+            }
+        }else if(obj instanceof Bitmap){
+            Bitmap bitmap = (Bitmap) obj;
+            if (bitmap != null) {
+                view.setCompoundDrawablesWithIntrinsicBounds(null, new BitmapDrawable(getResources(),bitmap), null, null);
+            }
+        }else if(obj instanceof Drawable){
+            Drawable drawable = (Drawable) obj;
+            if (drawable != null) {
+                view.setCompoundDrawablesWithIntrinsicBounds(null, drawable, null, null);
+            }
+        }
+    }
+
+    public void setSelectItem(int position){
+        for (int i = 0; i < tabsContainer.getChildCount(); i++) {
+            RelativeLayout linearLayout = ((RelativeLayout) tabsContainer.getChildAt(i));
+            if (i == position) {
+                ((TextView) linearLayout.getChildAt(0)).setTextColor(tabTextSelectColor);
+                if (pager.getAdapter() instanceof IconTabProvider) {
+                    Object obj = ((IconTabProvider) pager.getAdapter()).getPageSelectIcon(i);
+                    setViewResource(obj, (TextView) linearLayout.getChildAt(0));
+//                    ().setCompoundDrawablesWithIntrinsicBounds(0, ((IconTabProvider) pager.getAdapter()).getPageIconSelectResId(i), 0, 0);
+                }else if(pager.getAdapter() instanceof ViewTabProvider){
+                    View view = ((ViewTabProvider) pager.getAdapter()).onSelectIconView(i,getTabView(i),linearLayout);
+                    setTabView(i,view);
+                }
+//                    ((TextView) linearLayout.getChildAt(0)).setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.home_categry_icon_f_n, 0, 0);
+            } else {
+                ((TextView) linearLayout.getChildAt(0)).setTextColor(tabTextColor);
+                if (pager.getAdapter() instanceof IconTabProvider) {
+                    Object obj = ((IconTabProvider) pager.getAdapter()).getPageIcon(i);
+                    setViewResource(obj, (TextView) linearLayout.getChildAt(0));
+//                    ((TextView) linearLayout.getChildAt(0)).setCompoundDrawablesWithIntrinsicBounds(0, ((IconTabProvider) pager.getAdapter()).getPageIconResId(i), 0, 0);
+                }else if(pager.getAdapter() instanceof ViewTabProvider){
+                    View view = ((ViewTabProvider) pager.getAdapter()).onIconView(i, getTabView(i), linearLayout);
+                    setTabView(i,view);
+                }
+//                    ((TextView) linearLayout.getChildAt(0)).setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.home_categry_icon_n, 0, 0);
+
+            }
+        }
+    }
+
+    public void setIndicatorColor(int indicatorColor) {
+        this.indicatorColor = indicatorColor;
+        invalidate();
+    }
+
+    public void setIndicatorColorResource(int resId) {
+        this.indicatorColor = getResources().getColor(resId);
+        invalidate();
+    }
+
+    public int getIndicatorColor() {
+        return this.indicatorColor;
+    }
+
+    public void setIndicatorHeight(int indicatorLineHeightPx) {
+        this.indicatorHeight = indicatorLineHeightPx;
+        invalidate();
+    }
+
+    public int getIndicatorHeight() {
+        return indicatorHeight;
+    }
+
+    public void setUnderlineColor(int underlineColor) {
+        this.underlineColor = underlineColor;
+        invalidate();
+    }
+
+    public void setUnderlineColorResource(int resId) {
+        this.underlineColor = getResources().getColor(resId);
+        invalidate();
+    }
+
+    public int getUnderlineColor() {
+        return underlineColor;
+    }
+
+    public void setDividerColor(int dividerColor) {
+        this.dividerColor = dividerColor;
+        invalidate();
+    }
+
+    public void setDividerColorResource(int resId) {
+        this.dividerColor = getResources().getColor(resId);
+        invalidate();
+    }
+
+    public int getDividerColor() {
+        return dividerColor;
+    }
+
+    public void setUnderlineHeight(int underlineHeightPx) {
+        this.underlineHeight = underlineHeightPx;
+        invalidate();
+    }
+
+    public int getUnderlineHeight() {
+        return underlineHeight;
+    }
+
+    public void setDividerPadding(int dividerPaddingPx) {
+        this.dividerPadding = dividerPaddingPx;
+        invalidate();
+    }
+
+    public int getDividerPadding() {
+        return dividerPadding;
+    }
+
+    public void setScrollOffset(int scrollOffsetPx) {
+        this.scrollOffset = scrollOffsetPx;
+        invalidate();
+    }
+
+    public int getScrollOffset() {
+        return scrollOffset;
+    }
+
+    public void setShouldExpand(boolean shouldExpand) {
+        this.shouldExpand = shouldExpand;
+        requestLayout();
+    }
+
+    public boolean getShouldExpand() {
+        return shouldExpand;
+    }
+
+    public boolean isTextAllCaps() {
+        return textAllCaps;
+    }
+
+    public void setAllCaps(boolean textAllCaps) {
+        this.textAllCaps = textAllCaps;
+    }
+
+    public void setTextSize(int textSizePx) {
+        this.tabTextSize = textSizePx;
+        updateTabStyles();
+    }
+
+    public int getTextSize() {
+        return tabTextSize;
+    }
+
+    public void setTextColor(int textColor) {
+        this.tabTextColor = textColor;
+        updateTabStyles();
+    }
+
+    public void setTextColorResource(int resId) {
+        this.tabTextColor = getResources().getColor(resId);
+        updateTabStyles();
+    }
+
+    public int getTextColor() {
+        return tabTextColor;
+    }
+
+    public void setTypeface(Typeface typeface, int style) {
+        this.tabTypeface = typeface;
+        this.tabTypefaceStyle = style;
+        updateTabStyles();
+    }
+
+    public void setTabBackground(int resId) {
+        this.tabBackgroundResId = resId;
+    }
+
+    public int getTabBackground() {
+        return tabBackgroundResId;
+    }
+
+    public void setTabPaddingLeftRight(int paddingPx) {
+        this.tabPadding = paddingPx;
+        updateTabStyles();
+    }
+
+    public int getTabPaddingLeftRight() {
+        return tabPadding;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        SavedState savedState = (SavedState) state;
+        super.onRestoreInstanceState(savedState.getSuperState());
+        currentPosition = savedState.currentPosition;
+        requestLayout();
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+        SavedState savedState = new SavedState(superState);
+        savedState.currentPosition = currentPosition;
+        return savedState;
+    }
+
+    static class SavedState extends BaseSavedState {
+        int currentPosition;
+
+        public SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        private SavedState(Parcel in) {
+            super(in);
+            currentPosition = in.readInt();
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            super.writeToParcel(dest, flags);
+            dest.writeInt(currentPosition);
+        }
+
+        public static final Creator<SavedState> CREATOR = new Creator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+}
Index: easypermissions/src/main/java/pub/devrel/easypermissions/AfterPermissionGranted.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- easypermissions/src/main/java/pub/devrel/easypermissions/AfterPermissionGranted.java	(revision )
+++ easypermissions/src/main/java/pub/devrel/easypermissions/AfterPermissionGranted.java	(revision )
@@ -0,0 +1,29 @@
+/*
+ * Copyright Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package pub.devrel.easypermissions;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface AfterPermissionGranted {
+
+    int value();
+
+}
Index: mylib/src/main/res/drawable/sample_footer_loading_progress.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/drawable/sample_footer_loading_progress.xml	(revision )
+++ mylib/src/main/res/drawable/sample_footer_loading_progress.xml	(revision )
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <item>
+        <rotate
+            android:drawable="@drawable/sample_footer_loading"
+            android:duration="500"
+            android:fromDegrees="0.0"
+            android:pivotX="50.0%"
+            android:pivotY="50.0%"
+            android:toDegrees="360.0" />
+    </item>
+
+</layer-list>
\ No newline at end of file
Index: customfresco/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/res/values/strings.xml	(revision )
+++ customfresco/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">CustomFresco</string>
+</resources>
Index: app/src/main/res/layout/activity_custom_rating_bar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_custom_rating_bar.xml	(revision )
+++ app/src/main/res/layout/activity_custom_rating_bar.xml	(revision )
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    tools:context="com.scene.sceneandroiddemo.ui.activity.CustomRatingBarActivity">
+
+    <com.scene.mylib.view.ratingbar.ProperRatingBar
+        android:id="@+id/ratingBar"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_horizontal"
+        android:layout_margin="15dp"
+        app:prb_clickable="true"
+        app:prb_defaultRating="4"
+        app:prb_tickNormalDrawable="@mipmap/ic_star_normal"
+        app:prb_tickSelectedDrawable="@mipmap/ic_star_selected"
+        app:prb_tickSpacing="5dp"
+        app:prb_totalTicks="5" />
+
+</RelativeLayout>
Index: ucrop/src/main/java/com/yalantis/ucrop/util/CubicEasing.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/src/main/java/com/yalantis/ucrop/util/CubicEasing.java	(revision )
+++ ucrop/src/main/java/com/yalantis/ucrop/util/CubicEasing.java	(revision )
@@ -0,0 +1,17 @@
+package com.yalantis.ucrop.util;
+
+public final class CubicEasing {
+
+    public static float easeOut(float time, float start, float end, float duration) {
+        return end * ((time = time / duration - 1.0f) * time * time + 1.0f) + start;
+    }
+
+    public static float easeIn(float time, float start, float end, float duration) {
+        return end * (time /= duration) * time * time + start;
+    }
+
+    public static float easeInOut(float time, float start, float end, float duration) {
+        return (time /= duration / 2.0f) < 1.0f ? end / 2.0f * time * time * time + start : end / 2.0f * ((time -= 2.0f) * time * time + 2.0f) + start;
+    }
+
+}
Index: mylib/src/main/res/layout/sample_common_list_footer_loading.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/layout/sample_common_list_footer_loading.xml	(revision )
+++ mylib/src/main/res/layout/sample_common_list_footer_loading.xml	(revision )
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/loading_view"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center"
+    android:orientation="horizontal">
+
+    <ProgressBar
+        android:id="@+id/loading_progress"
+        android:layout_width="@dimen/dp_22"
+        android:layout_height="@dimen/dp_22"
+        android:layout_marginRight="@dimen/dp_4"
+        android:indeterminateDrawable="@drawable/sample_footer_loading_progress" />
+
+    <TextView
+        android:id="@+id/loading_text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginLeft="@dimen/dp_4"
+        android:text="@string/list_footer_loading"
+        android:textColor="@color/sample_common_list_bottom_text_color"
+        android:textSize="@dimen/sp_14" />
+</LinearLayout>
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/utils/AlarmUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/utils/AlarmUtil.java	(revision )
+++ common/src/main/java/com/scene/common/common/utils/AlarmUtil.java	(revision )
@@ -0,0 +1,55 @@
+package com.scene.common.common.utils;
+
+import android.annotation.TargetApi;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+
+/**
+ * @author MaTianyu @http://litesuits.com
+ * @date 2015-08-22
+ */
+public class AlarmUtil {
+    /**
+     * 开启定时器
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void startAlarmIntent(Context context, int triggerAtMillis, PendingIntent pendingIntent) {
+        AlarmManager manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+        manager.set(AlarmManager.RTC_WAKEUP,triggerAtMillis, pendingIntent);
+    }
+
+    /**
+     * 关闭定时器
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void stopAlarmIntent(Context context, PendingIntent pendingIntent) {
+        AlarmManager manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
+        manager.cancel(pendingIntent);
+    }
+
+    /**
+     * 开启轮询服务
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void startAlarmService(Context context, int triggerAtMillis, Class<?> cls, String action) {
+        Intent intent = new Intent(context, cls);
+        intent.setAction(action);
+        PendingIntent pendingIntent = PendingIntent.getService(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        startAlarmIntent(context, triggerAtMillis,pendingIntent);
+    }
+
+    /**
+     * 停止启轮询服务
+     */
+    @TargetApi(Build.VERSION_CODES.CUPCAKE)
+    public static void stopAlarmService(Context context, Class<?> cls, String action) {
+        Intent intent = new Intent(context, cls);
+        intent.setAction(action);
+        PendingIntent pendingIntent = PendingIntent.getService(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        stopAlarmIntent(context, pendingIntent);
+    }
+
+}
Index: app/src/main/java/com/scene/sceneandroiddemo/FileUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/FileUtil.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/FileUtil.java	(revision )
@@ -0,0 +1,355 @@
+package com.scene.sceneandroiddemo;
+
+import android.annotation.TargetApi;
+import android.content.ContentUris;
+import android.content.Context;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Environment;
+import android.os.StatFs;
+import android.provider.DocumentsContract;
+import android.provider.MediaStore;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Created by scene on 16/01/27.
+ */
+public class FileUtil {
+    public static final String IMAGE_TEMP_DIR = "/SCENE/temp/image/";
+
+    /**
+     * 获取sdk根目录
+     *
+     * @param context
+     * @param uniqueName
+     * @return
+     */
+    public static File getImageDir(Context context, String uniqueName) {
+
+        if (Environment.MEDIA_MOUNTED.equals(Environment
+                .getExternalStorageState())) {
+
+            return new File(Environment.getExternalStorageDirectory().getPath()
+                    + uniqueName);
+
+        } else {
+            return new File(context.getCacheDir().getPath() + File.separator
+                    + uniqueName);
+        }
+    }
+
+    /**
+     * Check how much usable space is available at a given path.
+     *
+     * @param path The path to check
+     * @return The space available in bytes,磁盘剩余空间
+     */
+    public static long getUsableSpace(File path) {
+        final StatFs stats = new StatFs(path.getPath());
+        return (long) stats.getBlockSize() * (long) stats.getAvailableBlocks();
+    }
+
+    /**
+     * 对空间进行判断，如果不存在进行创建
+     *
+     * @param context
+     */
+    public static File makeImageDirs(Context context) {
+        File imageDir = getImageDir(context, IMAGE_TEMP_DIR);
+        if (imageDir != null) {
+            if (!imageDir.exists()) {
+                imageDir.mkdirs();
+            }
+        }
+
+        return imageDir;
+
+        // getUsableSpace(file) > size
+    }
+
+    /**
+     * 复制文件
+     *
+     * @param oldPath
+     * @param newPath
+     */
+    public static void copyFile(String oldPath, String newPath) {
+        try {
+            int bytesum = 0;
+            int byteread = 0;
+            File oldfile = new File(oldPath);
+            if (oldfile.exists()) { //文件存在时
+                InputStream inStream = new FileInputStream(oldPath); //读入原文件
+                FileOutputStream fs = new FileOutputStream(newPath);
+                byte[] buffer = new byte[1444];
+                int length;
+                while ((byteread = inStream.read(buffer)) != -1) {
+                    bytesum += byteread; //字节数 文件大小
+                    System.out.println(bytesum);
+                    fs.write(buffer, 0, byteread);
+                }
+                inStream.close();
+            }
+        } catch (Exception e) {
+            System.out.println("复制单个文件操作出错");
+            e.printStackTrace();
+
+        }
+    }
+
+    /**
+     * 保存图片文件到本地
+     *
+     * @param imageName
+     * @param bitmap
+     * @param context
+     * @throws Exception
+     */
+    public static void saveImage(String imageName, Bitmap bitmap,
+                                 Context context) throws Exception {
+
+        File file = makeImageDirs(context);
+        File imageFile = new File(file.getPath(), imageName);
+
+        FileOutputStream outStream = new FileOutputStream(imageFile);
+        bitmap.compress(Bitmap.CompressFormat.PNG, 100, outStream);
+        outStream.flush();
+        outStream.close();
+
+    }
+
+    public static void saveImage(String imageName, Context context)
+            throws Exception {
+        File file = makeImageDirs(context);
+
+        File temp = getTempFile(context);
+        FileInputStream inputStream = new FileInputStream(temp);
+
+        File imageFile = new File(file.getPath(), imageName);
+        FileOutputStream outputStream = new FileOutputStream(imageFile);
+
+        // 缓冲数组
+        byte[] b = new byte[1024 * 5];
+        int len;
+        while ((len = inputStream.read(b)) != -1) {
+            outputStream.write(b, 0, len);
+        }
+        // 刷新此缓冲的输出流
+        outputStream.flush();
+        outputStream.close();
+        inputStream.close();
+    }
+
+    /**
+     * 递归删除文件和文件夹
+     *
+     * @param file 要删除的根目录
+     */
+    public static void rcursionDeleteFile(File file) {
+        if (file.isFile()) {
+            System.out.print(file);
+            file.delete();
+            return;
+        }
+        if (file.isDirectory()) {
+            File[] childFile = file.listFiles();
+            if (childFile == null || childFile.length == 0) {
+                System.out.print(file);
+                file.delete();
+                return;
+            }
+            for (File f : childFile) {
+                rcursionDeleteFile(f);
+            }
+            file.delete();
+        }
+    }
+
+    /**
+     * @param context
+     * @return
+     */
+    public static Uri getTempUri(Context context) {
+        return Uri.fromFile(getTempFile(context));
+    }
+
+    //删除tempfile
+    public static void delTempFile(Context context) {
+        File file = new File(Environment.getExternalStorageDirectory()
+                .getPath() + IMAGE_TEMP_DIR);
+        if (file.exists()) {
+
+            rcursionDeleteFile(file);
+        }
+    }
+
+    public static File getTempFile(Context context) {
+        if (hasSd()) {
+            makeImageDirs(context);
+            String path = Environment.getExternalStorageDirectory()
+                    .getPath() + IMAGE_TEMP_DIR + System.currentTimeMillis() + ".png";
+            File file = new File(path);
+
+            Log.e("test", "image file path = " + path);
+            try {
+
+                file.createNewFile();
+            } catch (IOException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+            return file;
+        }
+
+        return null;
+    }
+
+    public static boolean hasSd() {
+        return Environment.MEDIA_MOUNTED.equals(Environment
+                .getExternalStorageState());
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    public static String getPath(final Context context, final Uri uri) {
+
+        final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+
+        // DocumentProvider
+        if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
+            // ExternalStorageProvider
+            if (isExternalStorageDocument(uri)) {
+                final String docId = DocumentsContract.getDocumentId(uri);
+                final String[] split = docId.split(":");
+                final String type = split[0];
+
+                if ("primary".equalsIgnoreCase(type)) {
+                    return Environment.getExternalStorageDirectory() + "/"
+                            + split[1];
+                }
+
+                // TODO handle non-primary volumes
+            }
+            // DownloadsProvider
+            else if (isDownloadsDocument(uri)) {
+                final String id = DocumentsContract.getDocumentId(uri);
+                final Uri contentUri = ContentUris.withAppendedId(
+                        Uri.parse("content://downloads/public_downloads"),
+                        Long.valueOf(id));
+
+                return getDataColumn(context, contentUri, null, null);
+            }
+            // MediaProvider
+            else if (isMediaDocument(uri)) {
+                final String docId = DocumentsContract.getDocumentId(uri);
+                final String[] split = docId.split(":");
+                final String type = split[0];
+
+                Uri contentUri = null;
+                if ("image".equals(type)) {
+                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+                } else if ("video".equals(type)) {
+                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
+                } else if ("audio".equals(type)) {
+                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
+                }
+
+                final String selection = "_id=?";
+                final String[] selectionArgs = new String[]{split[1]};
+
+                return getDataColumn(context, contentUri, selection,
+                        selectionArgs);
+            }
+        }
+        // MediaStore (and general)
+        else if ("content".equalsIgnoreCase(uri.getScheme())) {
+
+            // Return the remote address
+            if (isGooglePhotosUri(uri))
+                return uri.getLastPathSegment();
+
+            return getDataColumn(context, uri, null, null);
+        }
+        // File
+        else if ("file".equalsIgnoreCase(uri.getScheme())) {
+            return uri.getPath();
+        }
+
+        return null;
+    }
+
+    /**
+     * Get the value of the data column for this Uri. This is useful for
+     * MediaStore Uris, and other file-based ContentProviders.
+     *
+     * @param context       The context.
+     * @param uri           The Uri to query.
+     * @param selection     (Optional) Filter used in the query.
+     * @param selectionArgs (Optional) Selection arguments used in the query.
+     * @return The value of the _data column, which is typically a file path.
+     */
+    public static String getDataColumn(Context context, Uri uri, String selection,
+                                       String[] selectionArgs) {
+
+        Cursor cursor = null;
+        final String column = "_data";
+        final String[] projection = {column};
+
+        try {
+            cursor = context.getContentResolver().query(uri, projection,
+                    selection, selectionArgs, null);
+            if (cursor != null && cursor.moveToFirst()) {
+                final int index = cursor.getColumnIndexOrThrow(column);
+                return cursor.getString(index);
+            }
+        } finally {
+            if (cursor != null)
+                cursor.close();
+        }
+        return null;
+    }
+
+    /**
+     * @param uri The Uri to check.
+     * @return Whether the Uri authority is ExternalStorageProvider.
+     */
+    public static boolean isExternalStorageDocument(Uri uri) {
+        return "com.android.externalstorage.documents".equals(uri
+                .getAuthority());
+    }
+
+    /**
+     * @param uri The Uri to check.
+     * @return Whether the Uri authority is DownloadsProvider.
+     */
+    public static boolean isDownloadsDocument(Uri uri) {
+        return "com.android.providers.downloads.documents".equals(uri
+                .getAuthority());
+    }
+
+    /**
+     * @param uri The Uri to check.
+     * @return Whether the Uri authority is MediaProvider.
+     */
+    public static boolean isMediaDocument(Uri uri) {
+        return "com.android.providers.media.documents".equals(uri
+                .getAuthority());
+    }
+
+    /**
+     * @param uri The Uri to check.
+     * @return Whether the Uri authority is Google Photos.
+     */
+    public static boolean isGooglePhotosUri(Uri uri) {
+        return "com.google.android.apps.photos.content".equals(uri
+                .getAuthority());
+    }
+
+}
Index: app/src/main/res/drawable/tab_color_select.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/drawable/tab_color_select.xml	(revision )
+++ app/src/main/res/drawable/tab_color_select.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true" android:color="@color/home_bar_text_push"/>
+    <item android:state_selected="true" android:color="@color/home_bar_text_push"/>
+    <item android:state_selected="false" android:color="@color/textnormal"/>
+    <item android:state_focused="false" android:color="@color/textnormal"/>
+    <item android:color="@color/textnormal" />
+</selector>
\ No newline at end of file
Index: app/src/main/java/com/scene/sceneandroiddemo/ui/activity/WebViewDemo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/scene/sceneandroiddemo/ui/activity/WebViewDemo.java	(revision )
+++ app/src/main/java/com/scene/sceneandroiddemo/ui/activity/WebViewDemo.java	(revision )
@@ -0,0 +1,39 @@
+package com.scene.sceneandroiddemo.ui.activity;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.scene.sceneandroiddemo.R;
+
+import butterknife.Bind;
+import butterknife.ButterKnife;
+
+public class WebViewDemo extends Activity {
+
+    @Bind(R.id.webView)
+    WebView webView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_web_view_demo);
+        ButterKnife.bind(this);
+        init();
+    }
+    private void init(){
+        //WebView加载web资源
+        webView.loadUrl("http://baidu.com");
+        //覆盖WebView默认使用第三方或系统默认浏览器打开网页的行为，使网页用WebView打开
+        webView.setWebViewClient(new WebViewClient() {
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                // TODO Auto-generated method stub
+                //返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器
+                view.loadUrl(url);
+                return true;
+            }
+        });
+    }
+}
Index: app/src/main/res/layout/activity_main_tab.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_main_tab.xml	(revision )
+++ app/src/main/res/layout/activity_main_tab.xml	(revision )
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context="com.scene.sceneandroiddemo.MainTabActivity">
+    <android.support.v7.widget.Toolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="?attr/actionBarSize"
+        android:background="?attr/colorPrimary"/>
+    <com.scene.mylib.view.tab.AdvancedPagerSlidingTabStrip
+        android:id="@+id/tabs"
+        style="@style/pagertab_icon_style"
+        android:layout_width="match_parent"
+        android:layout_height="55dp"
+        android:layout_alignParentBottom="true"
+        android:fillViewport="false" />
+
+    <com.scene.mylib.view.tab.APSTSViewPager
+        android:id="@+id/vp_main"
+        android:layout_below="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_above="@id/tabs" />
+</RelativeLayout>
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradle/wrapper/gradle-wrapper.properties	(revision )
+++ gradle/wrapper/gradle-wrapper.properties	(revision )
@@ -0,0 +1,6 @@
+#Wed Oct 21 11:34:03 PDT 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision )
+++ .idea/misc.xml	(revision )
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="NullableNotNullManager">
+    <option name="myDefaultNullable" value="android.support.annotation.Nullable" />
+    <option name="myDefaultNotNull" value="android.support.annotation.NonNull" />
+    <option name="myNullables">
+      <value>
+        <list size="4">
+          <item index="0" class="java.lang.String" itemvalue="org.jetbrains.annotations.Nullable" />
+          <item index="1" class="java.lang.String" itemvalue="javax.annotation.Nullable" />
+          <item index="2" class="java.lang.String" itemvalue="edu.umd.cs.findbugs.annotations.Nullable" />
+          <item index="3" class="java.lang.String" itemvalue="android.support.annotation.Nullable" />
+        </list>
+      </value>
+    </option>
+    <option name="myNotNulls">
+      <value>
+        <list size="4">
+          <item index="0" class="java.lang.String" itemvalue="org.jetbrains.annotations.NotNull" />
+          <item index="1" class="java.lang.String" itemvalue="javax.annotation.Nonnull" />
+          <item index="2" class="java.lang.String" itemvalue="edu.umd.cs.findbugs.annotations.NonNull" />
+          <item index="3" class="java.lang.String" itemvalue="android.support.annotation.NonNull" />
+        </list>
+      </value>
+    </option>
+  </component>
+  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
+    <OptionsSetting value="true" id="Add" />
+    <OptionsSetting value="true" id="Remove" />
+    <OptionsSetting value="true" id="Checkout" />
+    <OptionsSetting value="true" id="Update" />
+    <OptionsSetting value="true" id="Status" />
+    <OptionsSetting value="true" id="Edit" />
+    <ConfirmationsSetting value="0" id="Add" />
+    <ConfirmationsSetting value="0" id="Remove" />
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/build/classes" />
+  </component>
+  <component name="ProjectType">
+    <option name="id" value="Android" />
+  </component>
+</project>
\ No newline at end of file
Index: common/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/build.gradle	(revision )
+++ common/build.gradle	(revision )
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+}
Index: mylib/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/AndroidManifest.xml	(revision )
+++ mylib/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,15 @@
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.scene.mylib">
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+    <application
+        android:allowBackup="true"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
Index: ucrop/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ucrop/proguard-rules.pro	(revision )
+++ ucrop/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/oleksii/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: customfresco/src/main/java/com/scene/customfresco/zoomable/DefaultZoomableController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- customfresco/src/main/java/com/scene/customfresco/zoomable/DefaultZoomableController.java	(revision )
+++ customfresco/src/main/java/com/scene/customfresco/zoomable/DefaultZoomableController.java	(revision )
@@ -0,0 +1,326 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.scene.customfresco.zoomable;
+
+import android.graphics.Matrix;
+import android.graphics.PointF;
+import android.graphics.RectF;
+import android.view.MotionEvent;
+
+import com.scene.customfresco.gestures.TransformGestureDetector;
+
+
+/**
+ * Zoomable controller that calculates transformation based on touch events.
+ */
+public class DefaultZoomableController
+        implements ZoomableController, TransformGestureDetector.Listener {
+
+  private TransformGestureDetector mGestureDetector;
+
+  private Listener mListener = null;
+
+  private boolean mIsEnabled = false;
+  private boolean mIsRotationEnabled = false;
+  private boolean mIsScaleEnabled = true;
+  private boolean mIsTranslationEnabled = true;
+
+  private float mMinScaleFactor = 1.0f;
+  private float mMaxScaleFactor = Float.POSITIVE_INFINITY;
+
+  private final RectF mViewBounds = new RectF();
+  private final RectF mImageBounds = new RectF();
+  private final RectF mTransformedImageBounds = new RectF();
+  private final Matrix mPreviousTransform = new Matrix();
+  private final Matrix mActiveTransform = new Matrix();
+  private final Matrix mActiveTransformInverse = new Matrix();
+  private final float[] mTempValues = new float[9];
+
+  public DefaultZoomableController(TransformGestureDetector gestureDetector) {
+    mGestureDetector = gestureDetector;
+    mGestureDetector.setListener(this);
+  }
+
+  public static DefaultZoomableController newInstance() {
+    return new DefaultZoomableController(TransformGestureDetector.newInstance());
+  }
+
+  @Override
+  public void setListener(Listener listener) {
+    mListener = listener;
+  }
+
+  /** Rests the controller. */
+  public void reset() {
+    mGestureDetector.reset();
+    mPreviousTransform.reset();
+    mActiveTransform.reset();
+  }
+
+  /** Sets whether the controller is enabled or not. */
+  @Override
+  public void setEnabled(boolean enabled) {
+    mIsEnabled = enabled;
+    if (!enabled) {
+      reset();
+    }
+  }
+
+  /** Returns whether the controller is enabled or not. */
+  @Override
+  public boolean isEnabled() {
+    return mIsEnabled;
+  }
+
+  /** Sets whether the rotation gesture is enabled or not. */
+  public void setRotationEnabled(boolean enabled) {
+    mIsRotationEnabled = enabled;
+  }
+
+  /** Gets whether the rotation gesture is enabled or not. */
+  public boolean isRotationEnabled() {
+    return  mIsRotationEnabled;
+  }
+
+  /** Sets whether the scale gesture is enabled or not. */
+  public void setScaleEnabled(boolean enabled) {
+    mIsScaleEnabled = enabled;
+  }
+
+  /** Gets whether the scale gesture is enabled or not. */
+  public boolean isScaleEnabled() {
+    return  mIsScaleEnabled;
+  }
+
+  /** Sets whether the translation gesture is enabled or not. */
+  public void setTranslationEnabled(boolean enabled) {
+    mIsTranslationEnabled = enabled;
+  }
+
+  /** Gets whether the translations gesture is enabled or not. */
+  public boolean isTranslationEnabled() {
+    return  mIsTranslationEnabled;
+  }
+
+  /** Gets the image bounds before zoomable transformation is applied. */
+  public RectF getImageBounds() {
+    return mImageBounds;
+  }
+
+  /** Sets the image bounds before zoomable transformation is applied. */
+  @Override
+  public void setImageBounds(RectF imageBounds) {
+    mImageBounds.set(imageBounds);
+  }
+
+  /** Gets the view bounds. */
+  public RectF getViewBounds() {
+    return mViewBounds;
+  }
+
+  /** Sets the view bounds. */
+  @Override
+  public void setViewBounds(RectF viewBounds) {
+    mViewBounds.set(viewBounds);
+  }
+
+  /** Gets the minimum scale factor allowed. */
+  public float getMinScaleFactor() {
+    return mMinScaleFactor;
+  }
+
+  /**
+   * Sets the minimum scale factor allowed.
+   * <p>
+   * Note that the hierarchy performs scaling as well, which
+   * is not accounted here, so the actual scale factor may differ.
+   */
+  public void setMinScaleFactor(float minScaleFactor) {
+    mMinScaleFactor = minScaleFactor;
+  }
+
+  /** Gets the maximum scale factor allowed. */
+  public float getMaxScaleFactor() {
+    return mMaxScaleFactor;
+  }
+
+  /**
+   * Sets the maximum scale factor allowed.
+   * <p>
+   * Note that the hierarchy performs scaling as well, which
+   * is not accounted here, so the actual scale factor may differ.
+   */
+  public void setMaxScaleFactor(float maxScaleFactor) {
+    mMaxScaleFactor = maxScaleFactor;
+  }
+
+  /**
+   * Maps point from the view's to the image's relative coordinate system.
+   * This takes into account the zoomable transformation.
+   */
+  public PointF mapViewToImage(PointF viewPoint) {
+    float[] points = mTempValues;
+    points[0] = viewPoint.x;
+    points[1] = viewPoint.y;
+    mActiveTransform.invert(mActiveTransformInverse);
+    mActiveTransformInverse.mapPoints(points, 0, points, 0, 1);
+    mapAbsoluteToRelative(points, points, 1);
+    return new PointF(points[0], points[1]);
+  }
+
+  /**
+   * Maps point from the image's relative to the view's coordinate system.
+   * This takes into account the zoomable transformation.
+   */
+  public PointF mapImageToView(PointF imagePoint) {
+    float[] points = mTempValues;
+    points[0] = imagePoint.x;
+    points[1] = imagePoint.y;
+    mapRelativeToAbsolute(points, points, 1);
+    mActiveTransform.mapPoints(points, 0, points, 0, 1);
+    return new PointF(points[0], points[1]);
+  }
+
+  private void mapAbsoluteToRelative(float[] destPoints, float[] srcPoints, int numPoints) {
+    for (int i = 0; i < numPoints; i++) {
+      destPoints[i * 2 + 0] = (srcPoints[i * 2 + 0] - mImageBounds.left) / mImageBounds.width();
+      destPoints[i * 2 + 1] = (srcPoints[i * 2 + 1] - mImageBounds.top) / mImageBounds.height();
+    }
+  }
+
+  private void mapRelativeToAbsolute(float[] destPoints, float[] srcPoints, int numPoints) {
+    for (int i = 0; i < numPoints; i++) {
+      destPoints[i * 2 + 0] = srcPoints[i * 2 + 0] * mImageBounds.width() + mImageBounds.left;
+      destPoints[i * 2 + 1] = srcPoints[i * 2 + 1] * mImageBounds.height() + mImageBounds.top;
+    }
+  }
+
+  /**
+   * Gets the zoomable transformation
+   * Internal matrix is exposed for performance reasons and is not to be modified by the callers.
+   */
+  @Override
+  public Matrix getTransform() {
+    return mActiveTransform;
+  }
+
+  /**
+   * Sets the zoomable transformation. Cancels the current gesture if one is happening.
+   */
+  public void setTransform(Matrix activeTransform) {
+    if (mGestureDetector.isGestureInProgress()) {
+      mGestureDetector.reset();
+    }
+    mActiveTransform.set(activeTransform);
+  }
+
+  /** Notifies controller of the received touch event.  */
+  @Override
+  public boolean onTouchEvent(MotionEvent event) {
+    if (mIsEnabled) {
+      return mGestureDetector.onTouchEvent(event);
+    }
+    return false;
+  }
+
+  public void zoomToImagePoint(float scale, PointF imagePoint) {
+    if (mGestureDetector.isGestureInProgress()) {
+      mGestureDetector.reset();
+    }
+    scale = limit(scale, mMinScaleFactor, mMaxScaleFactor);
+    float[] points = mTempValues;
+    points[0] = imagePoint.x;
+    points[1] = imagePoint.y;
+    mapRelativeToAbsolute(points, points, 1);
+    mActiveTransform.setScale(scale, scale, points[0], points[1]);
+    mActiveTransform.postTranslate(
+            mViewBounds.centerX() - points[0],
+            mViewBounds.centerY() - points[1]);
+    limitTranslation();
+  }
+
+  /* TransformGestureDetector.Listener methods  */
+
+  @Override
+  public void onGestureBegin(TransformGestureDetector detector) {
+    mPreviousTransform.set(mActiveTransform);
+  }
+
+  @Override
+  public void onGestureUpdate(TransformGestureDetector detector) {
+    mActiveTransform.set(mPreviousTransform);
+    if (mIsRotationEnabled) {
+      float angle = detector.getRotation() * (float) (180 / Math.PI);
+      mActiveTransform.postRotate(angle, detector.getPivotX(), detector.getPivotY());
+    }
+    if (mIsScaleEnabled) {
+      float scale = detector.getScale();
+      mActiveTransform.postScale(scale, scale, detector.getPivotX(), detector.getPivotY());
+    }
+    limitScale(detector.getPivotX(), detector.getPivotY());
+    if (mIsTranslationEnabled) {
+      mActiveTransform.postTranslate(detector.getTranslationX(), detector.getTranslationY());
+    }
+    if (limitTranslation()) {
+      mGestureDetector.restartGesture();
+    }
+    if (mListener != null) {
+      mListener.onTransformChanged(mActiveTransform);
+    }
+  }
+
+  @Override
+  public void onGestureEnd(TransformGestureDetector detector) {
+    mPreviousTransform.set(mActiveTransform);
+  }
+
+  /** Gets the current scale factor. */
+  @Override
+  public float getScaleFactor() {
+    mActiveTransform.getValues(mTempValues);
+    return mTempValues[Matrix.MSCALE_X];
+  }
+
+  private void limitScale(float pivotX, float pivotY) {
+    float currentScale = getScaleFactor();
+    float targetScale = limit(currentScale, mMinScaleFactor, mMaxScaleFactor);
+    if (targetScale != currentScale) {
+      float scale = targetScale / currentScale;
+      mActiveTransform.postScale(scale, scale, pivotX, pivotY);
+    }
+  }
+
+  private boolean limitTranslation() {
+    RectF bounds = mTransformedImageBounds;
+    bounds.set(mImageBounds);
+    mActiveTransform.mapRect(bounds);
+
+    float offsetLeft = getOffset(bounds.left, bounds.width(), mViewBounds.width());
+    float offsetTop = getOffset(bounds.top, bounds.height(), mViewBounds.height());
+    if (offsetLeft != bounds.left || offsetTop != bounds.top) {
+      mActiveTransform.postTranslate(offsetLeft - bounds.left, offsetTop - bounds.top);
+      return true;
+    }
+    return false;
+  }
+
+  private float getOffset(float offset, float imageDimension, float viewDimension) {
+    float diff = viewDimension - imageDimension;
+    return (diff > 0) ? diff / 2 : limit(offset, diff, 0);
+  }
+
+  private float limit(float value, float min, float max) {
+    return Math.min(Math.max(min, value), max);
+  }
+
+}
\ No newline at end of file
Index: common/src/main/java/com/scene/common/common/assist/TimeCounter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/TimeCounter.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/TimeCounter.java	(revision )
@@ -0,0 +1,59 @@
+package com.scene.common.common.assist;
+
+
+import com.scene.common.android.log.Log;
+
+/**
+ * Time Counter.
+ *
+ * @author MaTianyu
+ *         2013-12-11下午3:42:28
+ */
+public class TimeCounter {
+
+    private static final String TAG = TimeCounter.class.getSimpleName();
+    private long t;
+
+    public TimeCounter() {
+        start();
+    }
+
+    /**
+     * Count start.
+     */
+    public long start() {
+        t = System.currentTimeMillis();
+        return t;
+    }
+
+    /**
+     * Get duration and restart.
+     */
+    public long durationRestart() {
+        long now = System.currentTimeMillis();
+        long d = now - t;
+        t = now;
+        return d;
+    }
+
+    /**
+     * Get duration.
+     */
+    public long duration() {
+        return System.currentTimeMillis() - t;
+    }
+
+    /**
+     * Print duration.
+     */
+    public void printDuration(String tag) {
+        Log.i(TAG, tag + " :  " + duration());
+    }
+
+    /**
+     * Print duration.
+     */
+    public void printDurationRestart(String tag) {
+        Log.i(TAG, tag + " :  " + durationRestart());
+    }
+}
\ No newline at end of file
Index: mylib/src/main/res/values/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/res/values/dimens.xml	(revision )
+++ mylib/src/main/res/values/dimens.xml	(revision )
@@ -0,0 +1,18 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="dp_4">4dp</dimen>
+    <dimen name="dp_22">22dp</dimen>
+    <dimen name="dp_60">60dp</dimen>
+    <dimen name="sp_14">14sp</dimen>
+
+    <!--psts-->
+    <dimen name="psts_dot_wh">8dp</dimen>
+    <dimen name="psts_dot_m_right">9dp</dimen>
+    <dimen name="psts_dot_m_top">7dp</dimen>
+    <dimen name="psts_dot_linelayout_h">23dp</dimen>
+    <dimen name="psts_dot_txt_size">10sp</dimen>
+
+    <!--自定义评星条的大小和间隔-->
+    <dimen name="prb_symbolic_tick_default_text_size">15sp</dimen>
+    <dimen name="prb_drawable_tick_default_spacing">1dp</dimen>
+</resources>
Index: mylib/src/main/java/com/scene/mylib/view/recyclerview/EndlessRecyclerOnScrollListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- mylib/src/main/java/com/scene/mylib/view/recyclerview/EndlessRecyclerOnScrollListener.java	(revision )
+++ mylib/src/main/java/com/scene/mylib/view/recyclerview/EndlessRecyclerOnScrollListener.java	(revision )
@@ -0,0 +1,111 @@
+package com.scene.mylib.view.recyclerview;
+
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.StaggeredGridLayoutManager;
+import android.view.View;
+
+/**
+ * Created by scene on 2015/10/9.
+ * <p/>
+ * 继承自RecyclerView.OnScrollListener，可以监听到是否滑动到页面最低部
+ */
+public class EndlessRecyclerOnScrollListener extends RecyclerView.OnScrollListener implements OnListLoadNextPageListener {
+
+    /**
+     * 当前RecyclerView类型
+     */
+    protected LayoutManagerType layoutManagerType;
+
+    /**
+     * 最后一个的位置
+     */
+    private int[] lastPositions;
+
+    /**
+     * 最后一个可见的item的位置
+     */
+    private int lastVisibleItemPosition;
+
+    /**
+     * 当前滑动的状态
+     */
+    private int currentScrollState = 0;
+
+    @Override
+    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+        super.onScrolled(recyclerView, dx, dy);
+
+        RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
+
+        if (layoutManagerType == null) {
+            if (layoutManager instanceof LinearLayoutManager) {
+                layoutManagerType = LayoutManagerType.LinearLayout;
+            } else if (layoutManager instanceof GridLayoutManager) {
+                layoutManagerType = LayoutManagerType.GridLayout;
+            } else if (layoutManager instanceof StaggeredGridLayoutManager) {
+                layoutManagerType = LayoutManagerType.StaggeredGridLayout;
+            } else {
+                throw new RuntimeException(
+                        "Unsupported LayoutManager used. Valid ones are LinearLayoutManager, GridLayoutManager and StaggeredGridLayoutManager");
+            }
+        }
+
+        switch (layoutManagerType) {
+            case LinearLayout:
+                lastVisibleItemPosition = ((LinearLayoutManager) layoutManager).findLastVisibleItemPosition();
+                break;
+            case GridLayout:
+                lastVisibleItemPosition = ((GridLayoutManager) layoutManager).findLastVisibleItemPosition();
+                break;
+            case StaggeredGridLayout:
+                StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager;
+                if (lastPositions == null) {
+                    lastPositions = new int[staggeredGridLayoutManager.getSpanCount()];
+                }
+                staggeredGridLayoutManager.findLastVisibleItemPositions(lastPositions);
+                lastVisibleItemPosition = findMax(lastPositions);
+                break;
+        }
+    }
+
+    @Override
+    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+        super.onScrollStateChanged(recyclerView, newState);
+        currentScrollState = newState;
+        RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
+        int visibleItemCount = layoutManager.getChildCount();
+        int totalItemCount = layoutManager.getItemCount();
+        if ((visibleItemCount > 0 && currentScrollState == RecyclerView.SCROLL_STATE_IDLE && (lastVisibleItemPosition) >= totalItemCount - 1)) {
+            onLoadNextPage(recyclerView);
+        }
+    }
+
+    /**
+     * 取数组中最大值
+     *
+     * @param lastPositions
+     * @return
+     */
+    private int findMax(int[] lastPositions) {
+        int max = lastPositions[0];
+        for (int value : lastPositions) {
+            if (value > max) {
+                max = value;
+            }
+        }
+
+        return max;
+    }
+
+    @Override
+    public void onLoadNextPage(final View view) {
+    }
+
+    public static enum LayoutManagerType {
+        LinearLayout,
+        StaggeredGridLayout,
+        GridLayout
+    }
+}
Index: common/src/main/java/com/scene/common/common/assist/Check.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/main/java/com/scene/common/common/assist/Check.java	(revision )
+++ common/src/main/java/com/scene/common/common/assist/Check.java	(revision )
@@ -0,0 +1,33 @@
+package com.scene.common.common.assist;
+
+import java.util.Collection;
+import java.util.Map;
+
+/**
+ * 辅助判断
+ * 
+ * @author mty
+ * @date 2013-6-10下午5:50:57
+ */
+public class Check {
+
+	public static boolean isEmpty(CharSequence str) {
+		return isNull(str) || str.length() == 0;
+	}
+
+	public static boolean isEmpty(Object[] os) {
+		return isNull(os) || os.length == 0;
+	}
+
+	public static boolean isEmpty(Collection<?> l) {
+		return isNull(l) || l.isEmpty();
+	}
+
+	public static boolean isEmpty(Map<?, ?> m) {
+		return isNull(m) || m.isEmpty();
+	}
+
+	public static boolean isNull(Object o) {
+		return o == null;
+	}
+}
